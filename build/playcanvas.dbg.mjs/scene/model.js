/**
 * @license
 * PlayCanvas Engine v1.63.0-dev revision 9f3635a4e (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { RENDERSTYLE_WIREFRAME } from './constants.js';
import { MeshInstance } from './mesh-instance.js';
import { MorphInstance } from './morph-instance.js';
import { SkinInstance } from './skin-instance.js';

/**
 * A model is a graphical object that can be added to or removed from a scene. It contains a
 * hierarchy and any number of mesh instances.
 */
class Model {
  /**
   * The root node of the model's graph node hierarchy.
   *
   * @type {import('./graph-node.js').GraphNode|null}
   */

  /**
   * An array of MeshInstances contained in this model.
   *
   * @type {MeshInstance[]}
   */

  /**
   * An array of SkinInstances contained in this model.
   *
   * @type {SkinInstance[]}
   */

  /**
   * An array of MorphInstances contained in this model.
   *
   * @type {MorphInstance[]}
   */

  /**
   * Creates a new model.
   *
   * @example
   * // Create a new model
   * var model = new pc.Model();
   */
  constructor() {
    this.graph = null;
    this.meshInstances = [];
    this.skinInstances = [];
    this.morphInstances = [];
    this.cameras = [];
    this.lights = [];
    this._shadersVersion = 0;

    // used by the model component to flag that this model has been assigned
    this._immutable = false;
  }
  getGraph() {
    return this.graph;
  }
  setGraph(graph) {
    this.graph = graph;
  }
  getCameras() {
    return this.cameras;
  }
  setCameras(cameras) {
    this.cameras = cameras;
  }
  getLights() {
    return this.lights;
  }
  setLights(lights) {
    this.lights = lights;
  }
  getMaterials() {
    const materials = [];
    for (let i = 0; i < this.meshInstances.length; i++) {
      const meshInstance = this.meshInstances[i];
      if (materials.indexOf(meshInstance.material) === -1) {
        materials.push(meshInstance.material);
      }
    }
    return materials;
  }

  /**
   * Clones a model. The returned model has a newly created hierarchy and mesh instances, but
   * meshes are shared between the clone and the specified model.
   *
   * @returns {Model} A clone of the specified model.
   * @example
   * var clonedModel = model.clone();
   */
  clone() {
    // Duplicate the node hierarchy
    const srcNodes = [];
    const cloneNodes = [];
    const _duplicate = function _duplicate(node) {
      const newNode = node.clone();
      srcNodes.push(node);
      cloneNodes.push(newNode);
      for (let idx = 0; idx < node._children.length; idx++) {
        newNode.addChild(_duplicate(node._children[idx]));
      }
      return newNode;
    };
    const cloneGraph = _duplicate(this.graph);
    const cloneMeshInstances = [];
    const cloneSkinInstances = [];
    const cloneMorphInstances = [];

    // Clone the skin instances
    for (let i = 0; i < this.skinInstances.length; i++) {
      const skin = this.skinInstances[i].skin;
      const cloneSkinInstance = new SkinInstance(skin);

      // Resolve bone IDs to actual graph nodes
      const bones = [];
      for (let j = 0; j < skin.boneNames.length; j++) {
        const boneName = skin.boneNames[j];
        const bone = cloneGraph.findByName(boneName);
        bones.push(bone);
      }
      cloneSkinInstance.bones = bones;
      cloneSkinInstances.push(cloneSkinInstance);
    }

    // Clone the morph instances
    for (let i = 0; i < this.morphInstances.length; i++) {
      const morph = this.morphInstances[i].morph;
      const cloneMorphInstance = new MorphInstance(morph);
      cloneMorphInstances.push(cloneMorphInstance);
    }

    // Clone the mesh instances
    for (let i = 0; i < this.meshInstances.length; i++) {
      const meshInstance = this.meshInstances[i];
      const nodeIndex = srcNodes.indexOf(meshInstance.node);
      const cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);
      if (meshInstance.skinInstance) {
        const skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
        cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
      }
      if (meshInstance.morphInstance) {
        const morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
        cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
      }
      cloneMeshInstances.push(cloneMeshInstance);
    }
    const clone = new Model();
    clone.graph = cloneGraph;
    clone.meshInstances = cloneMeshInstances;
    clone.skinInstances = cloneSkinInstances;
    clone.morphInstances = cloneMorphInstances;
    clone.getGraph().syncHierarchy();
    return clone;
  }

  /**
   * Destroys skinning texture and possibly deletes vertex/index buffers of a model. Mesh is
   * reference-counted, so buffers are only deleted if all models with referencing mesh instances
   * were deleted. That means all in-scene models + the "base" one (asset.resource) which is
   * created when the model is parsed. It is recommended to use asset.unload() instead, which
   * will also remove the model from the scene.
   */
  destroy() {
    const meshInstances = this.meshInstances;
    for (let i = 0; i < meshInstances.length; i++) {
      meshInstances[i].destroy();
    }
    this.meshInstances.length = 0;
  }

  /**
   * Generates the necessary internal data for a model to be renderable as wireframe. Once this
   * function has been called, any mesh instance in the model can have its renderStyle property
   * set to {@link RENDERSTYLE_WIREFRAME}.
   *
   * @example
   * model.generateWireframe();
   * for (var i = 0; i < model.meshInstances.length; i++) {
   *     model.meshInstances[i].renderStyle = pc.RENDERSTYLE_WIREFRAME;
   * }
   */
  generateWireframe() {
    MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
  }
}

export { Model };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zY2VuZS9tb2RlbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRU5ERVJTVFlMRV9XSVJFRlJBTUUgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBNZXNoSW5zdGFuY2UgfSBmcm9tICcuL21lc2gtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgTW9ycGhJbnN0YW5jZSB9IGZyb20gJy4vbW9ycGgtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgU2tpbkluc3RhbmNlIH0gZnJvbSAnLi9za2luLWluc3RhbmNlLmpzJztcblxuLyoqXG4gKiBBIG1vZGVsIGlzIGEgZ3JhcGhpY2FsIG9iamVjdCB0aGF0IGNhbiBiZSBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gYSBzY2VuZS4gSXQgY29udGFpbnMgYVxuICogaGllcmFyY2h5IGFuZCBhbnkgbnVtYmVyIG9mIG1lc2ggaW5zdGFuY2VzLlxuICovXG5jbGFzcyBNb2RlbCB7XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3Qgbm9kZSBvZiB0aGUgbW9kZWwncyBncmFwaCBub2RlIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4vZ3JhcGgtbm9kZS5qcycpLkdyYXBoTm9kZXxudWxsfVxuICAgICAqL1xuICAgIGdyYXBoID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIE1lc2hJbnN0YW5jZXMgY29udGFpbmVkIGluIHRoaXMgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWVzaEluc3RhbmNlW119XG4gICAgICovXG4gICAgbWVzaEluc3RhbmNlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgU2tpbkluc3RhbmNlcyBjb250YWluZWQgaW4gdGhpcyBtb2RlbC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTa2luSW5zdGFuY2VbXX1cbiAgICAgKi9cbiAgICBza2luSW5zdGFuY2VzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBNb3JwaEluc3RhbmNlcyBjb250YWluZWQgaW4gdGhpcyBtb2RlbC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNb3JwaEluc3RhbmNlW119XG4gICAgICovXG4gICAgbW9ycGhJbnN0YW5jZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBtb2RlbFxuICAgICAqIHZhciBtb2RlbCA9IG5ldyBwYy5Nb2RlbCgpO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNhbWVyYXMgPSBbXTtcbiAgICAgICAgdGhpcy5saWdodHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9zaGFkZXJzVmVyc2lvbiA9IDA7XG5cbiAgICAgICAgLy8gdXNlZCBieSB0aGUgbW9kZWwgY29tcG9uZW50IHRvIGZsYWcgdGhhdCB0aGlzIG1vZGVsIGhhcyBiZWVuIGFzc2lnbmVkXG4gICAgICAgIHRoaXMuX2ltbXV0YWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldEdyYXBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaDtcbiAgICB9XG5cbiAgICBzZXRHcmFwaChncmFwaCkge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgfVxuXG4gICAgZ2V0Q2FtZXJhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhcztcbiAgICB9XG5cbiAgICBzZXRDYW1lcmFzKGNhbWVyYXMpIHtcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gY2FtZXJhcztcbiAgICB9XG5cbiAgICBnZXRMaWdodHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZ2h0cztcbiAgICB9XG5cbiAgICBzZXRMaWdodHMobGlnaHRzKSB7XG4gICAgICAgIHRoaXMubGlnaHRzID0gbGlnaHRzO1xuICAgIH1cblxuICAgIGdldE1hdGVyaWFscygpIHtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZXNoSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNoSW5zdGFuY2UgPSB0aGlzLm1lc2hJbnN0YW5jZXNbaV07XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWxzLmluZGV4T2YobWVzaEluc3RhbmNlLm1hdGVyaWFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHMucHVzaChtZXNoSW5zdGFuY2UubWF0ZXJpYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRlcmlhbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgbW9kZWwuIFRoZSByZXR1cm5lZCBtb2RlbCBoYXMgYSBuZXdseSBjcmVhdGVkIGhpZXJhcmNoeSBhbmQgbWVzaCBpbnN0YW5jZXMsIGJ1dFxuICAgICAqIG1lc2hlcyBhcmUgc2hhcmVkIGJldHdlZW4gdGhlIGNsb25lIGFuZCB0aGUgc3BlY2lmaWVkIG1vZGVsLlxuICAgICAqXG4gICAgICogQHJldHVybnMge01vZGVsfSBBIGNsb25lIG9mIHRoZSBzcGVjaWZpZWQgbW9kZWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY2xvbmVkTW9kZWwgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAqL1xuICAgIGNsb25lKCkge1xuXG4gICAgICAgIC8vIER1cGxpY2F0ZSB0aGUgbm9kZSBoaWVyYXJjaHlcbiAgICAgICAgY29uc3Qgc3JjTm9kZXMgPSBbXTtcbiAgICAgICAgY29uc3QgY2xvbmVOb2RlcyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IF9kdXBsaWNhdGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG5vZGUuY2xvbmUoKTtcblxuICAgICAgICAgICAgc3JjTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIGNsb25lTm9kZXMucHVzaChuZXdOb2RlKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIG5ld05vZGUuYWRkQ2hpbGQoX2R1cGxpY2F0ZShub2RlLl9jaGlsZHJlbltpZHhdKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNsb25lR3JhcGggPSBfZHVwbGljYXRlKHRoaXMuZ3JhcGgpO1xuICAgICAgICBjb25zdCBjbG9uZU1lc2hJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgY29uc3QgY2xvbmVTa2luSW5zdGFuY2VzID0gW107XG4gICAgICAgIGNvbnN0IGNsb25lTW9ycGhJbnN0YW5jZXMgPSBbXTtcblxuICAgICAgICAvLyBDbG9uZSB0aGUgc2tpbiBpbnN0YW5jZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraW5JbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNraW4gPSB0aGlzLnNraW5JbnN0YW5jZXNbaV0uc2tpbjtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lU2tpbkluc3RhbmNlID0gbmV3IFNraW5JbnN0YW5jZShza2luKTtcblxuICAgICAgICAgICAgLy8gUmVzb2x2ZSBib25lIElEcyB0byBhY3R1YWwgZ3JhcGggbm9kZXNcbiAgICAgICAgICAgIGNvbnN0IGJvbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNraW4uYm9uZU5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9uZU5hbWUgPSBza2luLmJvbmVOYW1lc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBib25lID0gY2xvbmVHcmFwaC5maW5kQnlOYW1lKGJvbmVOYW1lKTtcbiAgICAgICAgICAgICAgICBib25lcy5wdXNoKGJvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvbmVTa2luSW5zdGFuY2UuYm9uZXMgPSBib25lcztcblxuICAgICAgICAgICAgY2xvbmVTa2luSW5zdGFuY2VzLnB1c2goY2xvbmVTa2luSW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xvbmUgdGhlIG1vcnBoIGluc3RhbmNlc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9ycGhJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1vcnBoID0gdGhpcy5tb3JwaEluc3RhbmNlc1tpXS5tb3JwaDtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lTW9ycGhJbnN0YW5jZSA9IG5ldyBNb3JwaEluc3RhbmNlKG1vcnBoKTtcbiAgICAgICAgICAgIGNsb25lTW9ycGhJbnN0YW5jZXMucHVzaChjbG9uZU1vcnBoSW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xvbmUgdGhlIG1lc2ggaW5zdGFuY2VzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZXNoSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNoSW5zdGFuY2UgPSB0aGlzLm1lc2hJbnN0YW5jZXNbaV07XG4gICAgICAgICAgICBjb25zdCBub2RlSW5kZXggPSBzcmNOb2Rlcy5pbmRleE9mKG1lc2hJbnN0YW5jZS5ub2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lTWVzaEluc3RhbmNlID0gbmV3IE1lc2hJbnN0YW5jZShtZXNoSW5zdGFuY2UubWVzaCwgbWVzaEluc3RhbmNlLm1hdGVyaWFsLCBjbG9uZU5vZGVzW25vZGVJbmRleF0pO1xuXG4gICAgICAgICAgICBpZiAobWVzaEluc3RhbmNlLnNraW5JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNraW5JbnN0YW5jZUluZGV4ID0gdGhpcy5za2luSW5zdGFuY2VzLmluZGV4T2YobWVzaEluc3RhbmNlLnNraW5JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgY2xvbmVNZXNoSW5zdGFuY2Uuc2tpbkluc3RhbmNlID0gY2xvbmVTa2luSW5zdGFuY2VzW3NraW5JbnN0YW5jZUluZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lc2hJbnN0YW5jZS5tb3JwaEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9ycGhJbnN0YW5jZUluZGV4ID0gdGhpcy5tb3JwaEluc3RhbmNlcy5pbmRleE9mKG1lc2hJbnN0YW5jZS5tb3JwaEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBjbG9uZU1lc2hJbnN0YW5jZS5tb3JwaEluc3RhbmNlID0gY2xvbmVNb3JwaEluc3RhbmNlc1ttb3JwaEluc3RhbmNlSW5kZXhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbG9uZU1lc2hJbnN0YW5jZXMucHVzaChjbG9uZU1lc2hJbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBNb2RlbCgpO1xuICAgICAgICBjbG9uZS5ncmFwaCA9IGNsb25lR3JhcGg7XG4gICAgICAgIGNsb25lLm1lc2hJbnN0YW5jZXMgPSBjbG9uZU1lc2hJbnN0YW5jZXM7XG4gICAgICAgIGNsb25lLnNraW5JbnN0YW5jZXMgPSBjbG9uZVNraW5JbnN0YW5jZXM7XG4gICAgICAgIGNsb25lLm1vcnBoSW5zdGFuY2VzID0gY2xvbmVNb3JwaEluc3RhbmNlcztcblxuICAgICAgICBjbG9uZS5nZXRHcmFwaCgpLnN5bmNIaWVyYXJjaHkoKTtcblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgc2tpbm5pbmcgdGV4dHVyZSBhbmQgcG9zc2libHkgZGVsZXRlcyB2ZXJ0ZXgvaW5kZXggYnVmZmVycyBvZiBhIG1vZGVsLiBNZXNoIGlzXG4gICAgICogcmVmZXJlbmNlLWNvdW50ZWQsIHNvIGJ1ZmZlcnMgYXJlIG9ubHkgZGVsZXRlZCBpZiBhbGwgbW9kZWxzIHdpdGggcmVmZXJlbmNpbmcgbWVzaCBpbnN0YW5jZXNcbiAgICAgKiB3ZXJlIGRlbGV0ZWQuIFRoYXQgbWVhbnMgYWxsIGluLXNjZW5lIG1vZGVscyArIHRoZSBcImJhc2VcIiBvbmUgKGFzc2V0LnJlc291cmNlKSB3aGljaCBpc1xuICAgICAqIGNyZWF0ZWQgd2hlbiB0aGUgbW9kZWwgaXMgcGFyc2VkLiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYXNzZXQudW5sb2FkKCkgaW5zdGVhZCwgd2hpY2hcbiAgICAgKiB3aWxsIGFsc28gcmVtb3ZlIHRoZSBtb2RlbCBmcm9tIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBtZXNoSW5zdGFuY2VzID0gdGhpcy5tZXNoSW5zdGFuY2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc2hJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1lc2hJbnN0YW5jZXNbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzaEluc3RhbmNlcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgbmVjZXNzYXJ5IGludGVybmFsIGRhdGEgZm9yIGEgbW9kZWwgdG8gYmUgcmVuZGVyYWJsZSBhcyB3aXJlZnJhbWUuIE9uY2UgdGhpc1xuICAgICAqIGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZCwgYW55IG1lc2ggaW5zdGFuY2UgaW4gdGhlIG1vZGVsIGNhbiBoYXZlIGl0cyByZW5kZXJTdHlsZSBwcm9wZXJ0eVxuICAgICAqIHNldCB0byB7QGxpbmsgUkVOREVSU1RZTEVfV0lSRUZSQU1FfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbW9kZWwuZ2VuZXJhdGVXaXJlZnJhbWUoKTtcbiAgICAgKiBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVsLm1lc2hJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgKiAgICAgbW9kZWwubWVzaEluc3RhbmNlc1tpXS5yZW5kZXJTdHlsZSA9IHBjLlJFTkRFUlNUWUxFX1dJUkVGUkFNRTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZ2VuZXJhdGVXaXJlZnJhbWUoKSB7XG4gICAgICAgIE1lc2hJbnN0YW5jZS5fcHJlcGFyZVJlbmRlclN0eWxlRm9yQXJyYXkodGhpcy5tZXNoSW5zdGFuY2VzLCBSRU5ERVJTVFlMRV9XSVJFRlJBTUUpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTW9kZWwgfTtcbiJdLCJuYW1lcyI6WyJNb2RlbCIsImNvbnN0cnVjdG9yIiwiZ3JhcGgiLCJtZXNoSW5zdGFuY2VzIiwic2tpbkluc3RhbmNlcyIsIm1vcnBoSW5zdGFuY2VzIiwiY2FtZXJhcyIsImxpZ2h0cyIsIl9zaGFkZXJzVmVyc2lvbiIsIl9pbW11dGFibGUiLCJnZXRHcmFwaCIsInNldEdyYXBoIiwiZ2V0Q2FtZXJhcyIsInNldENhbWVyYXMiLCJnZXRMaWdodHMiLCJzZXRMaWdodHMiLCJnZXRNYXRlcmlhbHMiLCJtYXRlcmlhbHMiLCJpIiwibGVuZ3RoIiwibWVzaEluc3RhbmNlIiwiaW5kZXhPZiIsIm1hdGVyaWFsIiwicHVzaCIsImNsb25lIiwic3JjTm9kZXMiLCJjbG9uZU5vZGVzIiwiX2R1cGxpY2F0ZSIsIm5vZGUiLCJuZXdOb2RlIiwiaWR4IiwiX2NoaWxkcmVuIiwiYWRkQ2hpbGQiLCJjbG9uZUdyYXBoIiwiY2xvbmVNZXNoSW5zdGFuY2VzIiwiY2xvbmVTa2luSW5zdGFuY2VzIiwiY2xvbmVNb3JwaEluc3RhbmNlcyIsInNraW4iLCJjbG9uZVNraW5JbnN0YW5jZSIsIlNraW5JbnN0YW5jZSIsImJvbmVzIiwiaiIsImJvbmVOYW1lcyIsImJvbmVOYW1lIiwiYm9uZSIsImZpbmRCeU5hbWUiLCJtb3JwaCIsImNsb25lTW9ycGhJbnN0YW5jZSIsIk1vcnBoSW5zdGFuY2UiLCJub2RlSW5kZXgiLCJjbG9uZU1lc2hJbnN0YW5jZSIsIk1lc2hJbnN0YW5jZSIsIm1lc2giLCJza2luSW5zdGFuY2UiLCJza2luSW5zdGFuY2VJbmRleCIsIm1vcnBoSW5zdGFuY2UiLCJtb3JwaEluc3RhbmNlSW5kZXgiLCJzeW5jSGllcmFyY2h5IiwiZGVzdHJveSIsImdlbmVyYXRlV2lyZWZyYW1lIiwiX3ByZXBhcmVSZW5kZXJTdHlsZUZvckFycmF5IiwiUkVOREVSU1RZTEVfV0lSRUZSQU1FIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxLQUFLLENBQUM7QUFDUjtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUdJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBR0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFHSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUdJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lDLEVBQUFBLFdBQVdBLEdBQUc7SUFBQSxJQTlCZEMsQ0FBQUEsS0FBSyxHQUFHLElBQUksQ0FBQTtJQUFBLElBT1pDLENBQUFBLGFBQWEsR0FBRyxFQUFFLENBQUE7SUFBQSxJQU9sQkMsQ0FBQUEsYUFBYSxHQUFHLEVBQUUsQ0FBQTtJQUFBLElBT2xCQyxDQUFBQSxjQUFjLEdBQUcsRUFBRSxDQUFBO0lBVWYsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRSxDQUFBO0lBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUUsQ0FBQTtJQUVoQixJQUFJLENBQUNDLGVBQWUsR0FBRyxDQUFDLENBQUE7O0FBRXhCO0lBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsS0FBSyxDQUFBO0FBQzNCLEdBQUE7QUFFQUMsRUFBQUEsUUFBUUEsR0FBRztJQUNQLE9BQU8sSUFBSSxDQUFDUixLQUFLLENBQUE7QUFDckIsR0FBQTtFQUVBUyxRQUFRQSxDQUFDVCxLQUFLLEVBQUU7SUFD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
