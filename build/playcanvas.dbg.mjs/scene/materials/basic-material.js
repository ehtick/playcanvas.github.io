/**
 * @license
 * PlayCanvas Engine v1.62.0-dev revision 7d088032c (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { Debug } from '../../core/debug.js';
import { Color } from '../../core/math/color.js';
import { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';
import { SHADERDEF_SKIN, SHADERDEF_SCREENSPACE, SHADERDEF_INSTANCING, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_TEXTURE_BASED } from '../constants.js';
import { getProgramLibrary } from '../shader-lib/get-program-library.js';
import { basic } from '../shader-lib/programs/basic.js';
import { Material } from './material.js';

/**
 * A BasicMaterial is for rendering unlit geometry, either using a constant color or a color map
 * modulated with a color.
 *
 * @augments Material
 */
class BasicMaterial extends Material {
  /**
   * Create a new BasicMaterial instance.
   *
   * @example
   * // Create a new Basic material
   * var material = new pc.BasicMaterial();
   *
   * // Set the material to have a texture map that is multiplied by a red color
   * material.color.set(1, 0, 0);
   * material.colorMap = diffuseMap;
   *
   * // Notify the material that it has been modified
   * material.update();
   */
  constructor() {
    super();

    /**
     * The flat color of the material (RGBA, where each component is 0 to 1).
     *
     * @type {Color}
     */
    this.color = new Color(1, 1, 1, 1);
    this.colorUniform = new Float32Array(4);

    /**
     * The color map of the material (default is null). If specified, the color map is
     * modulated by the color property.
     *
     * @type {import('../../platform/graphics/texture.js').Texture|null}
     */
    this.colorMap = null;
    this.vertexColors = false;
  }

  /**
   * Copy a `BasicMaterial`.
   *
   * @param {BasicMaterial} source - The material to copy from.
   * @returns {BasicMaterial} The destination material.
   */
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.colorMap = source.colorMap;
    this.vertexColors = source.vertexColors;
    return this;
  }
  updateUniforms(device, scene) {
    this.clearParameters();
    this.colorUniform[0] = this.color.r;
    this.colorUniform[1] = this.color.g;
    this.colorUniform[2] = this.color.b;
    this.colorUniform[3] = this.color.a;
    this.setParameter('uColor', this.colorUniform);
    if (this.colorMap) {
      this.setParameter('texture_diffuseMap', this.colorMap);
    }
  }
  getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
    // Note: this is deprecated function Editor and possibly other projects use: they define
    // updateShader callback on their BasicMaterial, so we handle it here.
    if (this.updateShader) {
      Debug.deprecated('pc.BasicMaterial.updateShader is deprecated');
      this.updateShader(device, scene, objDefs, staticLightList, pass, sortedLights);
      return this.shader;
    }
    const options = {
      skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
      screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
      useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
      useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
      useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
      useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
      alphaTest: this.alphaTest > 0,
      vertexColors: this.vertexColors,
      diffuseMap: !!this.colorMap,
      pass: pass
    };
    const processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);
    const library = getProgramLibrary(device);
    library.register('basic', basic);
    return library.getProgram('basic', options, processingOptions);
  }
}

export { BasicMaterial };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzaWMtbWF0ZXJpYWwuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvYmFzaWMtbWF0ZXJpYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29yZS9tYXRoL2NvbG9yLmpzJztcblxuaW1wb3J0IHsgU2hhZGVyUHJvY2Vzc29yT3B0aW9ucyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci1wcm9jZXNzb3Itb3B0aW9ucy5qcyc7XG5cbmltcG9ydCB7XG4gICAgU0hBREVSREVGX0lOU1RBTkNJTkcsIFNIQURFUkRFRl9NT1JQSF9OT1JNQUwsIFNIQURFUkRFRl9NT1JQSF9QT1NJVElPTiwgU0hBREVSREVGX01PUlBIX1RFWFRVUkVfQkFTRUQsXG4gICAgU0hBREVSREVGX1NDUkVFTlNQQUNFLCBTSEFERVJERUZfU0tJTlxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0UHJvZ3JhbUxpYnJhcnkgfSBmcm9tICcuLi9zaGFkZXItbGliL2dldC1wcm9ncmFtLWxpYnJhcnkuanMnO1xuaW1wb3J0IHsgYmFzaWMgfSBmcm9tICcuLi9zaGFkZXItbGliL3Byb2dyYW1zL2Jhc2ljLmpzJztcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9tYXRlcmlhbC5qcyc7XG5cbi8qKlxuICogQSBCYXNpY01hdGVyaWFsIGlzIGZvciByZW5kZXJpbmcgdW5saXQgZ2VvbWV0cnksIGVpdGhlciB1c2luZyBhIGNvbnN0YW50IGNvbG9yIG9yIGEgY29sb3IgbWFwXG4gKiBtb2R1bGF0ZWQgd2l0aCBhIGNvbG9yLlxuICpcbiAqIEBhdWdtZW50cyBNYXRlcmlhbFxuICovXG5jbGFzcyBCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBCYXNpY01hdGVyaWFsIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQmFzaWMgbWF0ZXJpYWxcbiAgICAgKiB2YXIgbWF0ZXJpYWwgPSBuZXcgcGMuQmFzaWNNYXRlcmlhbCgpO1xuICAgICAqXG4gICAgICogLy8gU2V0IHRoZSBtYXRlcmlhbCB0byBoYXZlIGEgdGV4dHVyZSBtYXAgdGhhdCBpcyBtdWx0aXBsaWVkIGJ5IGEgcmVkIGNvbG9yXG4gICAgICogbWF0ZXJpYWwuY29sb3Iuc2V0KDEsIDAsIDApO1xuICAgICAqIG1hdGVyaWFsLmNvbG9yTWFwID0gZGlmZnVzZU1hcDtcbiAgICAgKlxuICAgICAqIC8vIE5vdGlmeSB0aGUgbWF0ZXJpYWwgdGhhdCBpdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAqIG1hdGVyaWFsLnVwZGF0ZSgpO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmxhdCBjb2xvciBvZiB0aGUgbWF0ZXJpYWwgKFJHQkEsIHdoZXJlIGVhY2ggY29tcG9uZW50IGlzIDAgdG8gMSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtDb2xvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7XG4gICAgICAgIHRoaXMuY29sb3JVbmlmb3JtID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIG1hcCBvZiB0aGUgbWF0ZXJpYWwgKGRlZmF1bHQgaXMgbnVsbCkuIElmIHNwZWNpZmllZCwgdGhlIGNvbG9yIG1hcCBpc1xuICAgICAgICAgKiBtb2R1bGF0ZWQgYnkgdGhlIGNvbG9yIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy90ZXh0dXJlLmpzJykuVGV4dHVyZXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xvck1hcCA9IG51bGw7XG4gICAgICAgIHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBhIGBCYXNpY01hdGVyaWFsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFzaWNNYXRlcmlhbH0gc291cmNlIC0gVGhlIG1hdGVyaWFsIHRvIGNvcHkgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QmFzaWNNYXRlcmlhbH0gVGhlIGRlc3RpbmF0aW9uIG1hdGVyaWFsLlxuICAgICAqL1xuICAgIGNvcHkoc291cmNlKSB7XG4gICAgICAgIHN1cGVyLmNvcHkoc291cmNlKTtcblxuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICAgICAgdGhpcy5jb2xvck1hcCA9IHNvdXJjZS5jb2xvck1hcDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVVuaWZvcm1zKGRldmljZSwgc2NlbmUpIHtcbiAgICAgICAgdGhpcy5jbGVhclBhcmFtZXRlcnMoKTtcblxuICAgICAgICB0aGlzLmNvbG9yVW5pZm9ybVswXSA9IHRoaXMuY29sb3IucjtcbiAgICAgICAgdGhpcy5jb2xvclVuaWZvcm1bMV0gPSB0aGlzLmNvbG9yLmc7XG4gICAgICAgIHRoaXMuY29sb3JVbmlmb3JtWzJdID0gdGhpcy5jb2xvci5iO1xuICAgICAgICB0aGlzLmNvbG9yVW5pZm9ybVszXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoJ3VDb2xvcicsIHRoaXMuY29sb3JVbmlmb3JtKTtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JNYXApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKCd0ZXh0dXJlX2RpZmZ1c2VNYXAnLCB0aGlzLmNvbG9yTWFwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNoYWRlclZhcmlhbnQoZGV2aWNlLCBzY2VuZSwgb2JqRGVmcywgc3RhdGljTGlnaHRMaXN0LCBwYXNzLCBzb3J0ZWRMaWdodHMsIHZpZXdVbmlmb3JtRm9ybWF0LCB2aWV3QmluZEdyb3VwRm9ybWF0KSB7XG5cbiAgICAgICAgLy8gTm90ZTogdGhpcyBpcyBkZXByZWNhdGVkIGZ1bmN0aW9uIEVkaXRvciBhbmQgcG9zc2libHkgb3RoZXIgcHJvamVjdHMgdXNlOiB0aGV5IGRlZmluZVxuICAgICAgICAvLyB1cGRhdGVTaGFkZXIgY2FsbGJhY2sgb24gdGhlaXIgQmFzaWNNYXRlcmlhbCwgc28gd2UgaGFuZGxlIGl0IGhlcmUuXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVNoYWRlcikge1xuICAgICAgICAgICAgRGVidWcuZGVwcmVjYXRlZCgncGMuQmFzaWNNYXRlcmlhbC51cGRhdGVTaGFkZXIgaXMgZGVwcmVjYXRlZCcpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTaGFkZXIoZGV2aWNlLCBzY2VuZSwgb2JqRGVmcywgc3RhdGljTGlnaHRMaXN0LCBwYXNzLCBzb3J0ZWRMaWdodHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNraW46IG9iakRlZnMgJiYgKG9iakRlZnMgJiBTSEFERVJERUZfU0tJTikgIT09IDAsXG4gICAgICAgICAgICBzY3JlZW5TcGFjZTogb2JqRGVmcyAmJiAob2JqRGVmcyAmIFNIQURFUkRFRl9TQ1JFRU5TUEFDRSkgIT09IDAsXG4gICAgICAgICAgICB1c2VJbnN0YW5jaW5nOiBvYmpEZWZzICYmIChvYmpEZWZzICYgU0hBREVSREVGX0lOU1RBTkNJTkcpICE9PSAwLFxuICAgICAgICAgICAgdXNlTW9ycGhQb3NpdGlvbjogb2JqRGVmcyAmJiAob2JqRGVmcyAmIFNIQURFUkRFRl9NT1JQSF9QT1NJVElPTikgIT09IDAsXG4gICAgICAgICAgICB1c2VNb3JwaE5vcm1hbDogb2JqRGVmcyAmJiAob2JqRGVmcyAmIFNIQURFUkRFRl9NT1JQSF9OT1JNQUwpICE9PSAwLFxuICAgICAgICAgICAgdXNlTW9ycGhUZXh0dXJlQmFzZWQ6IG9iakRlZnMgJiYgKG9iakRlZnMgJiBTSEFERVJERUZfTU9SUEhfVEVYVFVSRV9CQVNFRCkgIT09IDAsXG5cbiAgICAgICAgICAgIGFscGhhVGVzdDogdGhpcy5hbHBoYVRlc3QgPiAwLFxuICAgICAgICAgICAgdmVydGV4Q29sb3JzOiB0aGlzLnZlcnRleENvbG9ycyxcbiAgICAgICAgICAgIGRpZmZ1c2VNYXA6ICEhdGhpcy5jb2xvck1hcCxcbiAgICAgICAgICAgIHBhc3M6IHBhc3NcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBwcm9jZXNzaW5nT3B0aW9ucyA9IG5ldyBTaGFkZXJQcm9jZXNzb3JPcHRpb25zKHZpZXdVbmlmb3JtRm9ybWF0LCB2aWV3QmluZEdyb3VwRm9ybWF0KTtcblxuICAgICAgICBjb25zdCBsaWJyYXJ5ID0gZ2V0UHJvZ3JhbUxpYnJhcnkoZGV2aWNlKTtcbiAgICAgICAgbGlicmFyeS5yZWdpc3RlcignYmFzaWMnLCBiYXNpYyk7XG5cbiAgICAgICAgcmV0dXJuIGxpYnJhcnkuZ2V0UHJvZ3JhbSgnYmFzaWMnLCBvcHRpb25zLCBwcm9jZXNzaW5nT3B0aW9ucyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYXNpY01hdGVyaWFsIH07XG4iXSwibmFtZXMiOlsiQmFzaWNNYXRlcmlhbCIsIk1hdGVyaWFsIiwiY29uc3RydWN0b3IiLCJjb2xvciIsIkNvbG9yIiwiY29sb3JVbmlmb3JtIiwiRmxvYXQzMkFycmF5IiwiY29sb3JNYXAiLCJ2ZXJ0ZXhDb2xvcnMiLCJjb3B5Iiwic291cmNlIiwidXBkYXRlVW5pZm9ybXMiLCJkZXZpY2UiLCJzY2VuZSIsImNsZWFyUGFyYW1ldGVycyIsInIiLCJnIiwiYiIsImEiLCJzZXRQYXJhbWV0ZXIiLCJnZXRTaGFkZXJWYXJpYW50Iiwib2JqRGVmcyIsInN0YXRpY0xpZ2h0TGlzdCIsInBhc3MiLCJzb3J0ZWRMaWdodHMiLCJ2aWV3VW5pZm9ybUZvcm1hdCIsInZpZXdCaW5kR3JvdXBGb3JtYXQiLCJ1cGRhdGVTaGFkZXIiLCJEZWJ1ZyIsImRlcHJlY2F0ZWQiLCJzaGFkZXIiLCJvcHRpb25zIiwic2tpbiIsIlNIQURFUkRFRl9TS0lOIiwic2NyZWVuU3BhY2UiLCJTSEFERVJERUZfU0NSRUVOU1BBQ0UiLCJ1c2VJbnN0YW5jaW5nIiwiU0hBREVSREVGX0lOU1RBTkNJTkciLCJ1c2VNb3JwaFBvc2l0aW9uIiwiU0hBREVSREVGX01PUlBIX1BPU0lUSU9OIiwidXNlTW9ycGhOb3JtYWwiLCJTSEFERVJERUZfTU9SUEhfTk9STUFMIiwidXNlTW9ycGhUZXh0dXJlQmFzZWQiLCJTSEFERVJERUZfTU9SUEhfVEVYVFVSRV9CQVNFRCIsImFscGhhVGVzdCIsImRpZmZ1c2VNYXAiLCJwcm9jZXNzaW5nT3B0aW9ucyIsIlNoYWRlclByb2Nlc3Nvck9wdGlvbnMiLCJsaWJyYXJ5IiwiZ2V0UHJvZ3JhbUxpYnJhcnkiLCJyZWdpc3RlciIsImJhc2ljIiwiZ2V0UHJvZ3JhbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLGFBQWEsU0FBU0MsUUFBUSxDQUFDO0FBQ2pDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsRUFBQUEsV0FBVyxHQUFHO0FBQ1YsSUFBQSxLQUFLLEVBQUUsQ0FBQTs7QUFFUDtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ1EsSUFBQSxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FB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
