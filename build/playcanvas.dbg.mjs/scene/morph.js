/**
 * @license
 * PlayCanvas Engine v1.62.0-dev revision 7d088032c (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { Debug } from '../core/debug.js';
import { RefCountedObject } from '../core/ref-counted-object.js';
import { Vec3 } from '../core/math/vec3.js';
import { FloatPacking } from '../core/math/float-packing.js';
import { BoundingBox } from '../core/shape/bounding-box.js';
import { Texture } from '../platform/graphics/texture.js';
import { VertexBuffer } from '../platform/graphics/vertex-buffer.js';
import { VertexFormat } from '../platform/graphics/vertex-format.js';
import { PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGB32F, BUFFER_STATIC, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, SEMANTIC_ATTR15, TYPE_FLOAT32 } from '../platform/graphics/constants.js';
import { GraphicsDeviceAccess } from '../platform/graphics/graphics-device-access.js';

// value added to floats which are used as ints on the shader side to avoid values being rounded to one less occasionally
const _floatRounding = 0.2;

/**
 * Contains a list of {@link MorphTarget}, a combined delta AABB and some associated data.
 */
class Morph extends RefCountedObject {
  /**
   * Create a new Morph instance.
   *
   * @param {import('./morph-target.js').MorphTarget[]} targets - A list of morph targets.
   * @param {import('../platform/graphics/graphics-device.js').GraphicsDevice} graphicsDevice -
   * The graphics device used to manage this morph target.
   */
  constructor(targets, graphicsDevice) {
    super();
    Debug.assertDeprecated(graphicsDevice, "Morph constructor takes a GraphicsDevice as a parameter, and it was not provided.");
    this.device = graphicsDevice || GraphicsDeviceAccess.get();

    // validation
    targets.forEach(target => Debug.assert(!target.used, 'The target specified has already been used to create a Morph, use its clone instead.'));
    this._targets = targets.slice();

    // default to texture based morphing if available
    if (this.device.supportsMorphTargetTexturesCore) {
      // pick renderable format - prefer half-float
      if (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable) {
        this._renderTextureFormat = PIXELFORMAT_RGBA16F;
      } else if (this.device.extTextureFloat && this.device.textureFloatRenderable) {
        this._renderTextureFormat = PIXELFORMAT_RGBA32F;
      }

      // pick texture format - prefer half-float
      if (this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable) {
        this._textureFormat = PIXELFORMAT_RGBA16F;
      } else if (this.device.extTextureFloat) {
        this._textureFormat = PIXELFORMAT_RGB32F;
      }

      // if both available, enable texture morphing
      if (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {
        this._useTextureMorph = true;
      }
    }
    this._init();
    this._updateMorphFlags();
    this._calculateAabb();
  }
  get morphPositions() {
    return this._morphPositions;
  }
  get morphNormals() {
    return this._morphNormals;
  }
  get maxActiveTargets() {
    // no limit when texture morph based
    if (this._useTextureMorph) return this._targets.length;
    return this._morphPositions && this._morphNormals ? 4 : 8;
  }
  get useTextureMorph() {
    return this._useTextureMorph;
  }
  _init() {
    // try to init texture based morphing
    if (this._useTextureMorph) {
      this._useTextureMorph = this._initTextureBased();
    }

    // if texture morphing is not set up, use attribute based morphing
    if (!this._useTextureMorph) {
      for (let i = 0; i < this._targets.length; i++) {
        this._targets[i]._initVertexBuffers(this.device);
      }
    }

    // finalize init
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i]._postInit();
    }
  }
  _initTextureBased() {
    // collect all source delta arrays to find sparse set of vertices
    const deltaArrays = [],
      deltaInfos = [];
    for (let i = 0; i < this._targets.length; i++) {
      const target = this._targets[i];
      if (target.options.deltaPositions) {
        deltaArrays.push(target.options.deltaPositions);
        deltaInfos.push({
          target: target,
          name: 'texturePositions'
        });
      }
      if (target.options.deltaNormals) {
        deltaArrays.push(target.options.deltaNormals);
        deltaInfos.push({
          target: target,
          name: 'textureNormals'
        });
      }
    }

    // find sparse set for all target deltas into usedDataIndices and build vertex id buffer
    const ids = [],
      usedDataIndices = [];
    let freeIndex = 1; // reserve slot 0 for zero delta
    const dataCount = deltaArrays[0].length;
    for (let v = 0; v < dataCount; v += 3) {
      // find if vertex is morphed by any target
      let vertexUsed = false;
      for (let i = 0; i < deltaArrays.length; i++) {
        const data = deltaArrays[i];

        // if non-zero delta
        if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
          vertexUsed = true;
          break;
        }
      }
      if (vertexUsed) {
        ids.push(freeIndex + _floatRounding);
        usedDataIndices.push(v / 3);
        freeIndex++;
      } else {
        // non morphed vertices would be all mapped to pixel 0 of texture
        ids.push(0 + _floatRounding);
      }
    }

    // max texture size: vertexBufferIds is stored in float32 format, giving us 2^24 range, so can address 4096 texture at maximum
    // TODO: on webgl2 we could store this in uint32 format and remove this limit
    const maxTextureSize = Math.min(this.device.maxTextureSize, 4096);

    // texture size for freeIndex pixels - roughly square
    let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
    morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
    const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);

    // if data cannot fit into max size texture, fail this set up
    if (morphTextureHeight > maxTextureSize) {
      return false;
    }
    this.morphTextureWidth = morphTextureWidth;
    this.morphTextureHeight = morphTextureHeight;

    // texture format based vars
    let halfFloat = false;
    let numComponents = 3; // RGB32 is used
    const float2Half = FloatPacking.float2Half;
    if (this._textureFormat === PIXELFORMAT_RGBA16F) {
      halfFloat = true;
      numComponents = 4; // RGBA16 is used, RGB16 does not work
    }

    // build texture for each delta array, all textures are the same size
    for (let i = 0; i < deltaArrays.length; i++) {
      const data = deltaArrays[i];
      const texture = this._createTexture('MorphTarget', this._textureFormat);
      const packedDeltas = texture.lock();

      // copy full arrays into sparse arrays and convert format (skip 0th pixel - used by non-morphed vertices)
      for (let v = 0; v < usedDataIndices.length; v++) {
        const index = usedDataIndices[v];
        if (halfFloat) {
          packedDeltas[v * numComponents + numComponents] = float2Half(data[index * 3]);
          packedDeltas[v * numComponents + numComponents + 1] = float2Half(data[index * 3 + 1]);
          packedDeltas[v * numComponents + numComponents + 2] = float2Half(data[index * 3 + 2]);
        } else {
          packedDeltas[v * numComponents + numComponents] = data[index * 3];
          packedDeltas[v * numComponents + numComponents + 1] = data[index * 3 + 1];
          packedDeltas[v * numComponents + numComponents + 2] = data[index * 3 + 2];
        }
      }

      // create texture and assign it to target
      texture.unlock();
      const target = deltaInfos[i].target;
      target._setTexture(deltaInfos[i].name, texture);
    }

    // create vertex stream with vertex_id used to map vertex to texture
    const formatDesc = [{
      semantic: SEMANTIC_ATTR15,
      components: 1,
      type: TYPE_FLOAT32
    }];
    this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));
    return true;
  }

  /**
   * Frees video memory allocated by this object.
   */
  destroy() {
    var _this$vertexBufferIds;
    (_this$vertexBufferIds = this.vertexBufferIds) == null ? void 0 : _this$vertexBufferIds.destroy();
    this.vertexBufferIds = null;
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i].destroy();
    }
    this._targets.length = 0;
  }

  /**
   * The array of morph targets.
   *
   * @type {import('./morph-target.js').MorphTarget[]}
   */
  get targets() {
    return this._targets;
  }
  _updateMorphFlags() {
    // find out if this morph needs to morph positions and normals
    this._morphPositions = false;
    this._morphNormals = false;
    for (let i = 0; i < this._targets.length; i++) {
      const target = this._targets[i];
      if (target.morphPositions) {
        this._morphPositions = true;
      }
      if (target.morphNormals) {
        this._morphNormals = true;
      }
    }
  }
  _calculateAabb() {
    // calculate min and max expansion size
    // Note: This represents average case, where most morph targets expand the mesh within the same area. It does not
    // represent the stacked worst case scenario where all morphs could be enabled at the same time, as this can result
    // in a very large aabb. In cases like this, the users should specify customAabb for Model/Render component.
    const min = new Vec3();
    const max = new Vec3();
    for (let i = 0; i < this._targets.length; i++) {
      const targetAabb = this._targets[i].aabb;
      min.min(targetAabb.getMin());
      max.max(targetAabb.getMax());
    }
    this.aabb = new BoundingBox();
    this.aabb.setMinMax(min, max);
  }

  // creates texture. Used to create both source morph target data, as well as render target used to morph these into, positions and normals
  _createTexture(name, format) {
    return new Texture(this.device, {
      width: this.morphTextureWidth,
      height: this.morphTextureHeight,
      format: format,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: name
    });
  }
}

export { Morph };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ycGguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zY2VuZS9tb3JwaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZyB9IGZyb20gJy4uL2NvcmUvZGVidWcuanMnO1xuaW1wb3J0IHsgUmVmQ291bnRlZE9iamVjdCB9IGZyb20gJy4uL2NvcmUvcmVmLWNvdW50ZWQtb2JqZWN0LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9jb3JlL21hdGgvdmVjMy5qcyc7XG5pbXBvcnQgeyBGbG9hdFBhY2tpbmcgfSBmcm9tICcuLi9jb3JlL21hdGgvZmxvYXQtcGFja2luZy5qcyc7XG5pbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gJy4uL2NvcmUvc2hhcGUvYm91bmRpbmctYm94LmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi9wbGF0Zm9ybS9ncmFwaGljcy90ZXh0dXJlLmpzJztcbmltcG9ydCB7IFZlcnRleEJ1ZmZlciB9IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL3ZlcnRleC1idWZmZXIuanMnO1xuaW1wb3J0IHsgVmVydGV4Rm9ybWF0IH0gZnJvbSAnLi4vcGxhdGZvcm0vZ3JhcGhpY3MvdmVydGV4LWZvcm1hdC5qcyc7XG5cbmltcG9ydCB7XG4gICAgQlVGRkVSX1NUQVRJQywgVFlQRV9GTE9BVDMyLCBTRU1BTlRJQ19BVFRSMTUsIEFERFJFU1NfQ0xBTVBfVE9fRURHRSwgRklMVEVSX05FQVJFU1QsXG4gICAgUElYRUxGT1JNQVRfUkdCQTE2RiwgUElYRUxGT1JNQVRfUkdCMzJGLCBQSVhFTEZPUk1BVF9SR0JBMzJGXG59IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBHcmFwaGljc0RldmljZUFjY2VzcyB9IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL2dyYXBoaWNzLWRldmljZS1hY2Nlc3MuanMnO1xuXG4vLyB2YWx1ZSBhZGRlZCB0byBmbG9hdHMgd2hpY2ggYXJlIHVzZWQgYXMgaW50cyBvbiB0aGUgc2hhZGVyIHNpZGUgdG8gYXZvaWQgdmFsdWVzIGJlaW5nIHJvdW5kZWQgdG8gb25lIGxlc3Mgb2NjYXNpb25hbGx5XG5jb25zdCBfZmxvYXRSb3VuZGluZyA9IDAuMjtcblxuLyoqXG4gKiBDb250YWlucyBhIGxpc3Qgb2Yge0BsaW5rIE1vcnBoVGFyZ2V0fSwgYSBjb21iaW5lZCBkZWx0YSBBQUJCIGFuZCBzb21lIGFzc29jaWF0ZWQgZGF0YS5cbiAqL1xuY2xhc3MgTW9ycGggZXh0ZW5kcyBSZWZDb3VudGVkT2JqZWN0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTW9ycGggaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9tb3JwaC10YXJnZXQuanMnKS5Nb3JwaFRhcmdldFtdfSB0YXJnZXRzIC0gQSBsaXN0IG9mIG1vcnBoIHRhcmdldHMuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3BsYXRmb3JtL2dyYXBoaWNzL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSBncmFwaGljc0RldmljZSAtXG4gICAgICogVGhlIGdyYXBoaWNzIGRldmljZSB1c2VkIHRvIG1hbmFnZSB0aGlzIG1vcnBoIHRhcmdldC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRzLCBncmFwaGljc0RldmljZSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIERlYnVnLmFzc2VydERlcHJlY2F0ZWQoZ3JhcGhpY3NEZXZpY2UsIFwiTW9ycGggY29uc3RydWN0b3IgdGFrZXMgYSBHcmFwaGljc0RldmljZSBhcyBhIHBhcmFtZXRlciwgYW5kIGl0IHdhcyBub3QgcHJvdmlkZWQuXCIpO1xuICAgICAgICB0aGlzLmRldmljZSA9IGdyYXBoaWNzRGV2aWNlIHx8IEdyYXBoaWNzRGV2aWNlQWNjZXNzLmdldCgpO1xuXG4gICAgICAgIC8vIHZhbGlkYXRpb25cbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiBEZWJ1Zy5hc3NlcnQoIXRhcmdldC51c2VkLCAnVGhlIHRhcmdldCBzcGVjaWZpZWQgaGFzIGFscmVhZHkgYmVlbiB1c2VkIHRvIGNyZWF0ZSBhIE1vcnBoLCB1c2UgaXRzIGNsb25lIGluc3RlYWQuJykpO1xuICAgICAgICB0aGlzLl90YXJnZXRzID0gdGFyZ2V0cy5zbGljZSgpO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dHVyZSBiYXNlZCBtb3JwaGluZyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuZGV2aWNlLnN1cHBvcnRzTW9ycGhUYXJnZXRUZXh0dXJlc0NvcmUpIHtcblxuICAgICAgICAgICAgLy8gcGljayByZW5kZXJhYmxlIGZvcm1hdCAtIHByZWZlciBoYWxmLWZsb2F0XG4gICAgICAgICAgICBpZiAodGhpcy5kZXZpY2UuZXh0VGV4dHVyZUhhbGZGbG9hdCAmJiB0aGlzLmRldmljZS50ZXh0dXJlSGFsZkZsb2F0UmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVGb3JtYXQgPSBQSVhFTEZPUk1BVF9SR0JBMTZGO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRldmljZS5leHRUZXh0dXJlRmxvYXQgJiYgdGhpcy5kZXZpY2UudGV4dHVyZUZsb2F0UmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVGb3JtYXQgPSBQSVhFTEZPUk1BVF9SR0JBMzJGO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwaWNrIHRleHR1cmUgZm9ybWF0IC0gcHJlZmVyIGhhbGYtZmxvYXRcbiAgICAgICAgICAgIGlmICh0aGlzLmRldmljZS5leHRUZXh0dXJlSGFsZkZsb2F0ICYmIHRoaXMuZGV2aWNlLnRleHR1cmVIYWxmRmxvYXRVcGRhdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlRm9ybWF0ID0gUElYRUxGT1JNQVRfUkdCQTE2RjtcbiAgICAgICAgICAgIH0gZWxzZSAgaWYgKHRoaXMuZGV2aWNlLmV4dFRleHR1cmVGbG9hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVGb3JtYXQgPSBQSVhFTEZPUk1BVF9SR0IzMkY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXZhaWxhYmxlLCBlbmFibGUgdGV4dHVyZSBtb3JwaGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmVGb3JtYXQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90ZXh0dXJlRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VUZXh0dXJlTW9ycGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVNb3JwaEZsYWdzKCk7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUFhYmIoKTtcbiAgICB9XG5cbiAgICBnZXQgbW9ycGhQb3NpdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3JwaFBvc2l0aW9ucztcbiAgICB9XG5cbiAgICBnZXQgbW9ycGhOb3JtYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9ycGhOb3JtYWxzO1xuICAgIH1cblxuICAgIGdldCBtYXhBY3RpdmVUYXJnZXRzKCkge1xuXG4gICAgICAgIC8vIG5vIGxpbWl0IHdoZW4gdGV4dHVyZSBtb3JwaCBiYXNlZFxuICAgICAgICBpZiAodGhpcy5fdXNlVGV4dHVyZU1vcnBoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5fbW9ycGhQb3NpdGlvbnMgJiYgdGhpcy5fbW9ycGhOb3JtYWxzKSA/IDQgOiA4O1xuICAgIH1cblxuICAgIGdldCB1c2VUZXh0dXJlTW9ycGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VUZXh0dXJlTW9ycGg7XG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGluaXQgdGV4dHVyZSBiYXNlZCBtb3JwaGluZ1xuICAgICAgICBpZiAodGhpcy5fdXNlVGV4dHVyZU1vcnBoKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VUZXh0dXJlTW9ycGggPSB0aGlzLl9pbml0VGV4dHVyZUJhc2VkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0ZXh0dXJlIG1vcnBoaW5nIGlzIG5vdCBzZXQgdXAsIHVzZSBhdHRyaWJ1dGUgYmFzZWQgbW9ycGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLl91c2VUZXh0dXJlTW9ycGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldHNbaV0uX2luaXRWZXJ0ZXhCdWZmZXJzKHRoaXMuZGV2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsaXplIGluaXRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRzW2ldLl9wb3N0SW5pdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2luaXRUZXh0dXJlQmFzZWQoKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgYWxsIHNvdXJjZSBkZWx0YSBhcnJheXMgdG8gZmluZCBzcGFyc2Ugc2V0IG9mIHZlcnRpY2VzXG4gICAgICAgIGNvbnN0IGRlbHRhQXJyYXlzID0gW10sIGRlbHRhSW5mb3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXRzW2ldO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLmRlbHRhUG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVsdGFBcnJheXMucHVzaCh0YXJnZXQub3B0aW9ucy5kZWx0YVBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgZGVsdGFJbmZvcy5wdXNoKHsgdGFyZ2V0OiB0YXJnZXQsIG5hbWU6ICd0ZXh0dXJlUG9zaXRpb25zJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQub3B0aW9ucy5kZWx0YU5vcm1hbHMpIHtcbiAgICAgICAgICAgICAgICBkZWx0YUFycmF5cy5wdXNoKHRhcmdldC5vcHRpb25zLmRlbHRhTm9ybWFscyk7XG4gICAgICAgICAgICAgICAgZGVsdGFJbmZvcy5wdXNoKHsgdGFyZ2V0OiB0YXJnZXQsIG5hbWU6ICd0ZXh0dXJlTm9ybWFscycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHNwYXJzZSBzZXQgZm9yIGFsbCB0YXJnZXQgZGVsdGFzIGludG8gdXNlZERhdGFJbmRpY2VzIGFuZCBidWlsZCB2ZXJ0ZXggaWQgYnVmZmVyXG4gICAgICAgIGNvbnN0IGlkcyA9IFtdLCB1c2VkRGF0YUluZGljZXMgPSBbXTtcbiAgICAgICAgbGV0IGZyZWVJbmRleCA9IDE7ICAvLyByZXNlcnZlIHNsb3QgMCBmb3IgemVybyBkZWx0YVxuICAgICAgICBjb25zdCBkYXRhQ291bnQgPSBkZWx0YUFycmF5c1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgZGF0YUNvdW50OyB2ICs9IDMpIHtcblxuICAgICAgICAgICAgLy8gZmluZCBpZiB2ZXJ0ZXggaXMgbW9ycGhlZCBieSBhbnkgdGFyZ2V0XG4gICAgICAgICAgICBsZXQgdmVydGV4VXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YUFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkZWx0YUFycmF5c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG5vbi16ZXJvIGRlbHRhXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbdl0gIT09IDAgfHwgZGF0YVt2ICsgMV0gIT09IDAgfHwgZGF0YVt2ICsgMl0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZlcnRleFVzZWQpIHtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChmcmVlSW5kZXggKyBfZmxvYXRSb3VuZGluZyk7XG4gICAgICAgICAgICAgICAgdXNlZERhdGFJbmRpY2VzLnB1c2godiAvIDMpO1xuICAgICAgICAgICAgICAgIGZyZWVJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub24gbW9ycGhlZCB2ZXJ0aWNlcyB3b3VsZCBiZSBhbGwgbWFwcGVkIHRvIHBpeGVsIDAgb2YgdGV4dHVyZVxuICAgICAgICAgICAgICAgIGlkcy5wdXNoKDAgKyBfZmxvYXRSb3VuZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXggdGV4dHVyZSBzaXplOiB2ZXJ0ZXhCdWZmZXJJZHMgaXMgc3RvcmVkIGluIGZsb2F0MzIgZm9ybWF0LCBnaXZpbmcgdXMgMl4yNCByYW5nZSwgc28gY2FuIGFkZHJlc3MgNDA5NiB0ZXh0dXJlIGF0IG1heGltdW1cbiAgICAgICAgLy8gVE9ETzogb24gd2ViZ2wyIHdlIGNvdWxkIHN0b3JlIHRoaXMgaW4gdWludDMyIGZvcm1hdCBhbmQgcmVtb3ZlIHRoaXMgbGltaXRcbiAgICAgICAgY29uc3QgbWF4VGV4dHVyZVNpemUgPSBNYXRoLm1pbih0aGlzLmRldmljZS5tYXhUZXh0dXJlU2l6ZSwgNDA5Nik7XG5cbiAgICAgICAgLy8gdGV4dHVyZSBzaXplIGZvciBmcmVlSW5kZXggcGl4ZWxzIC0gcm91Z2hseSBzcXVhcmVcbiAgICAgICAgbGV0IG1vcnBoVGV4dHVyZVdpZHRoID0gTWF0aC5jZWlsKE1hdGguc3FydChmcmVlSW5kZXgpKTtcbiAgICAgICAgbW9ycGhUZXh0dXJlV2lkdGggPSBNYXRoLm1pbihtb3JwaFRleHR1cmVXaWR0aCwgbWF4VGV4dHVyZVNpemUpO1xuICAgICAgICBjb25zdCBtb3JwaFRleHR1cmVIZWlnaHQgPSBNYXRoLmNlaWwoZnJlZUluZGV4IC8gbW9ycGhUZXh0dXJlV2lkdGgpO1xuXG4gICAgICAgIC8vIGlmIGRhdGEgY2Fubm90IGZpdCBpbnRvIG1heCBzaXplIHRleHR1cmUsIGZhaWwgdGhpcyBzZXQgdXBcbiAgICAgICAgaWYgKG1vcnBoVGV4dHVyZUhlaWdodCA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vcnBoVGV4dHVyZVdpZHRoID0gbW9ycGhUZXh0dXJlV2lkdGg7XG4gICAgICAgIHRoaXMubW9ycGhUZXh0dXJlSGVpZ2h0ID0gbW9ycGhUZXh0dXJlSGVpZ2h0O1xuXG4gICAgICAgIC8vIHRleHR1cmUgZm9ybWF0IGJhc2VkIHZhcnNcbiAgICAgICAgbGV0IGhhbGZGbG9hdCA9IGZhbHNlO1xuICAgICAgICBsZXQgbnVtQ29tcG9uZW50cyA9IDM7ICAvLyBSR0IzMiBpcyB1c2VkXG4gICAgICAgIGNvbnN0IGZsb2F0MkhhbGYgPSBGbG9hdFBhY2tpbmcuZmxvYXQySGFsZjtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVGb3JtYXQgPT09IFBJWEVMRk9STUFUX1JHQkExNkYpIHtcbiAgICAgICAgICAgIGhhbGZGbG9hdCA9IHRydWU7XG4gICAgICAgICAgICBudW1Db21wb25lbnRzID0gNDsgIC8vIFJHQkExNiBpcyB1c2VkLCBSR0IxNiBkb2VzIG5vdCB3b3JrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCB0ZXh0dXJlIGZvciBlYWNoIGRlbHRhIGFycmF5LCBhbGwgdGV4dHVyZXMgYXJlIHRoZSBzYW1lIHNpemVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YUFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRlbHRhQXJyYXlzW2ldO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZSgnTW9ycGhUYXJnZXQnLCB0aGlzLl90ZXh0dXJlRm9ybWF0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tlZERlbHRhcyA9IHRleHR1cmUubG9jaygpO1xuXG4gICAgICAgICAgICAvLyBjb3B5IGZ1bGwgYXJyYXlzIGludG8gc3BhcnNlIGFycmF5cyBhbmQgY29udmVydCBmb3JtYXQgKHNraXAgMHRoIHBpeGVsIC0gdXNlZCBieSBub24tbW9ycGhlZCB2ZXJ0aWNlcylcbiAgICAgICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdXNlZERhdGFJbmRpY2VzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VkRGF0YUluZGljZXNbdl07XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFsZkZsb2F0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tlZERlbHRhc1t2ICogbnVtQ29tcG9uZW50cyArIG51bUNvbXBvbmVudHNdID0gZmxvYXQySGFsZihkYXRhW2luZGV4ICogM10pO1xuICAgICAgICAgICAgICAgICAgICBwYWNrZWREZWx0YXNbdiAqIG51bUNvbXBvbmVudHMgKyBudW1Db21wb25lbnRzICsgMV0gPSBmbG9hdDJIYWxmKGRhdGFbaW5kZXggKiAzICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWNrZWREZWx0YXNbdiAqIG51bUNvbXBvbmVudHMgKyBudW1Db21wb25lbnRzICsgMl0gPSBmbG9hdDJIYWxmKGRhdGFbaW5kZXggKiAzICsgMl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tlZERlbHRhc1t2ICogbnVtQ29tcG9uZW50cyArIG51bUNvbXBvbmVudHNdID0gZGF0YVtpbmRleCAqIDNdO1xuICAgICAgICAgICAgICAgICAgICBwYWNrZWREZWx0YXNbdiAqIG51bUNvbXBvbmVudHMgKyBudW1Db21wb25lbnRzICsgMV0gPSBkYXRhW2luZGV4ICogMyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBwYWNrZWREZWx0YXNbdiAqIG51bUNvbXBvbmVudHMgKyBudW1Db21wb25lbnRzICsgMl0gPSBkYXRhW2luZGV4ICogMyArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRleHR1cmUgYW5kIGFzc2lnbiBpdCB0byB0YXJnZXRcbiAgICAgICAgICAgIHRleHR1cmUudW5sb2NrKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBkZWx0YUluZm9zW2ldLnRhcmdldDtcbiAgICAgICAgICAgIHRhcmdldC5fc2V0VGV4dHVyZShkZWx0YUluZm9zW2ldLm5hbWUsIHRleHR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHZlcnRleCBzdHJlYW0gd2l0aCB2ZXJ0ZXhfaWQgdXNlZCB0byBtYXAgdmVydGV4IHRvIHRleHR1cmVcbiAgICAgICAgY29uc3QgZm9ybWF0RGVzYyA9IFt7IHNlbWFudGljOiBTRU1BTlRJQ19BVFRSMTUsIGNvbXBvbmVudHM6IDEsIHR5cGU6IFRZUEVfRkxPQVQzMiB9XTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJJZHMgPSBuZXcgVmVydGV4QnVmZmVyKHRoaXMuZGV2aWNlLCBuZXcgVmVydGV4Rm9ybWF0KHRoaXMuZGV2aWNlLCBmb3JtYXREZXNjKSwgaWRzLmxlbmd0aCwgQlVGRkVSX1NUQVRJQywgbmV3IEZsb2F0MzJBcnJheShpZHMpKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcmVlcyB2aWRlbyBtZW1vcnkgYWxsb2NhdGVkIGJ5IHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVySWRzPy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVySWRzID0gbnVsbDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldHNbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhcmdldHMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgbW9ycGggdGFyZ2V0cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4vbW9ycGgtdGFyZ2V0LmpzJykuTW9ycGhUYXJnZXRbXX1cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldHM7XG4gICAgfVxuXG4gICAgX3VwZGF0ZU1vcnBoRmxhZ3MoKSB7XG5cbiAgICAgICAgLy8gZmluZCBvdXQgaWYgdGhpcyBtb3JwaCBuZWVkcyB0byBtb3JwaCBwb3NpdGlvbnMgYW5kIG5vcm1hbHNcbiAgICAgICAgdGhpcy5fbW9ycGhQb3NpdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW9ycGhOb3JtYWxzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tpXTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubW9ycGhQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3JwaFBvc2l0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm1vcnBoTm9ybWFscykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vcnBoTm9ybWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlQWFiYigpIHtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgbWluIGFuZCBtYXggZXhwYW5zaW9uIHNpemVcbiAgICAgICAgLy8gTm90ZTogVGhpcyByZXByZXNlbnRzIGF2ZXJhZ2UgY2FzZSwgd2hlcmUgbW9zdCBtb3JwaCB0YXJnZXRzIGV4cGFuZCB0aGUgbWVzaCB3aXRoaW4gdGhlIHNhbWUgYXJlYS4gSXQgZG9lcyBub3RcbiAgICAgICAgLy8gcmVwcmVzZW50IHRoZSBzdGFja2VkIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2hlcmUgYWxsIG1vcnBocyBjb3VsZCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUsIGFzIHRoaXMgY2FuIHJlc3VsdFxuICAgICAgICAvLyBpbiBhIHZlcnkgbGFyZ2UgYWFiYi4gSW4gY2FzZXMgbGlrZSB0aGlzLCB0aGUgdXNlcnMgc2hvdWxkIHNwZWNpZnkgY3VzdG9tQWFiYiBmb3IgTW9kZWwvUmVuZGVyIGNvbXBvbmVudC5cbiAgICAgICAgY29uc3QgbWluID0gbmV3IFZlYzMoKTtcbiAgICAgICAgY29uc3QgbWF4ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBYWJiID0gdGhpcy5fdGFyZ2V0c1tpXS5hYWJiO1xuICAgICAgICAgICAgbWluLm1pbih0YXJnZXRBYWJiLmdldE1pbigpKTtcbiAgICAgICAgICAgIG1heC5tYXgodGFyZ2V0QWFiYi5nZXRNYXgoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFhYmIgPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICAgICAgdGhpcy5hYWJiLnNldE1pbk1heChtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlcyB0ZXh0dXJlLiBVc2VkIHRvIGNyZWF0ZSBib3RoIHNvdXJjZSBtb3JwaCB0YXJnZXQgZGF0YSwgYXMgd2VsbCBhcyByZW5kZXIgdGFyZ2V0IHVzZWQgdG8gbW9ycGggdGhlc2UgaW50bywgcG9zaXRpb25zIGFuZCBub3JtYWxzXG4gICAgX2NyZWF0ZVRleHR1cmUobmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZSh0aGlzLmRldmljZSwge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMubW9ycGhUZXh0dXJlV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMubW9ycGhUZXh0dXJlSGVpZ2h0LFxuICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgICAgICBjdWJlbWFwOiBmYWxzZSxcbiAgICAgICAgICAgIG1pcG1hcHM6IGZhbHNlLFxuICAgICAgICAgICAgbWluRmlsdGVyOiBGSUxURVJfTkVBUkVTVCxcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogRklMVEVSX05FQVJFU1QsXG4gICAgICAgICAgICBhZGRyZXNzVTogQUREUkVTU19DTEFNUF9UT19FREdFLFxuICAgICAgICAgICAgYWRkcmVzc1Y6IEFERFJFU1NfQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBNb3JwaCB9O1xuIl0sIm5hbWVzIjpbIl9mbG9hdFJvdW5kaW5nIiwiTW9ycGgiLCJSZWZDb3VudGVkT2JqZWN0IiwiY29uc3RydWN0b3IiLCJ0YXJnZXRzIiwiZ3JhcGhpY3NEZXZpY2UiLCJEZWJ1ZyIsImFzc2VydERlcHJlY2F0ZWQiLCJkZXZpY2UiLCJHcmFwaGljc0RldmljZUFjY2VzcyIsImdldCIsImZvckVhY2giLCJ0YXJnZXQiLCJhc3NlcnQiLCJ1c2VkIiwiX3RhcmdldHMiLCJzbGljZSIsInN1cHBvcnRzTW9ycGhUYXJnZXRUZXh0dXJlc0NvcmUiLCJleHRUZXh0dXJlSGFsZkZsb2F0IiwidGV4dHVyZUhhbGZGbG9hdFJlbmRlcmFibGUiLCJfcmVuZGVyVGV4dHVyZUZvcm1hdCIsIlBJWEVMRk9STUFUX1JHQkExNkYiLCJleHRUZXh0dXJlRmxvYXQiLCJ0ZXh0dXJlRmxvYXRSZW5kZXJhYmxlIiwiUElYRUxGT1JNQVRfUkdCQTMyRiIsInRleHR1cmVIYWxmRmxvYXRVcGRhdGFibGUiLCJfdGV4dHVyZUZvcm1hdCIsIlBJWEVMRk9STUFUX1JHQjMyRiIsInVuZGVmaW5lZCIsIl91c2VUZXh0dXJlTW9ycGgiLCJfaW5pdCIsIl91cGRhdGVNb3JwaEZsYWdzIiwiX2NhbGN1bGF0ZUFhYmIiLCJtb3JwaFBvc2l0aW9ucyIsIl9tb3JwaFBvc2l0aW9ucyIsIm1vcnBoTm9ybWFscyIsIl9tb3JwaE5vcm1hbHMiLCJtYXhBY3RpdmVUYXJnZXRzIiwibGVuZ3RoIiwidXNlVGV4dHVyZU1vcnBoIiwiX2luaXRUZXh0dXJlQmFzZWQiLCJpIiwiX2luaXRWZXJ0ZXhCdWZmZXJzIiwiX3Bvc3RJbml0IiwiZGVsdGFBcnJheXMiLCJkZWx0YUluZm9zIiwib3B0aW9ucyIsImRlbHRhUG9zaXRpb25zIiwicHVzaCIsIm5hbWUiLCJkZWx0YU5vcm1hbHMiLCJpZHMiLCJ1c2VkRGF0YUluZGljZXMiLCJmcmVlSW5kZXgiLCJkYXRhQ291bnQiLCJ2IiwidmVydGV4VXNlZCIsImRhdGEiLCJtYXhUZXh0dXJlU2l6ZSIsIk1hdGgiLCJtaW4iLCJtb3JwaFRleHR1cmVXaWR0aCIsImNlaWwiLCJzcXJ0IiwibW9ycGhUZXh0dXJlSGVpZ2h0IiwiaGFsZkZsb2F0IiwibnVtQ29tcG9uZW50cyIsImZsb2F0MkhhbGYiLCJGbG9hdFBhY2tpbmciLCJ0ZXh0dXJlIiwiX2NyZWF0ZVRleHR1cmUiLCJwYWNrZWREZWx0YXMiLCJsb2NrIiwiaW5kZXgiLCJ1bmxvY2siLCJfc2V0VGV4dHVyZSIsImZvcm1hdERlc2MiLCJzZW1hbnRpYyIsIlNFTUFOVElDX0FUVFIxNSIsImNvbXBvbmVudHMiLCJ0eXBlIiwiVFlQRV9GTE9BVDMyIiwidmVydGV4QnVmZmVySWRzIiwiVmVydGV4QnVmZmVyIiwiVmVydGV4Rm9ybWF0IiwiQlVGRkVSX1NUQVRJQyIsIkZsb2F0MzJBcnJheSIsImRlc3Ryb3kiLCJWZWMzIiwibWF4IiwidGFyZ2V0QWFiYiIsImFhYmIiLCJnZXRNaW4iLCJnZXRNYXgiLCJCb3VuZGluZ0JveCIsInNldE1pbk1heCIsImZvcm1hdCIsIlRleHR1cmUiLCJ3aWR0aCIsImhlaWdodCIsImN1YmVtYXAiLCJtaXBtYXBzIiwibWluRmlsdGVyIiwiRklMVEVSX05FQVJFU1QiLCJtYWdGaWx0ZXIiLCJhZGRyZXNzVSIsIkFERFJFU1NfQ0xBTVBfVE9fRURHRSIsImFkZHJlc3NWIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQSxNQUFNQSxjQUFjLEdBQUcsR0FBRyxDQUFBOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxLQUFLLFNBQVNDLGdCQUFnQixDQUFDO0FBQ2pDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lDLEVBQUFBLFdBQVcsQ0FBQ0MsT0FBTyxFQUFFQyxjQUFjLEVBQUU7QUFDakMsSUFBQSxLQUFLLEVBQUUsQ0FBQTtBQUVQQyxJQUFBQSxLQUFLLENBQUNDLGdCQUFnQixDQUFDRixjQUFjLEVBQUUsbUZBQW1GLENBQUMsQ0FBQTtJQUMzSCxJQUFJLENBQUNHLE1BQU0sR0FBR0gsY0FBYyxJQUFJSSxvQkFBb0IsQ0FBQ0MsR0FBRyxFQUFFLENBQUE7O0FBRTFEO0FBQ0FOLElBQUFBLE9BQU8sQ0FBQ08sT0FBTyxDQUFDQyxNQUFNLElBQUlOLEtBQUssQ0FBQ08sTUFBTSxDQUFDLENBQUNELE1BQU0sQ0FBQ0UsSUFBSSxFQUFFLHNGQUFzRixDQUFDLENBQUMsQ0FBQTtBQUM3SSxJQUFBLElBQUksQ0FBQ0MsUUFBUSxHQUFHWCxPQUFPLENBQUNZLEtBQUssRUFBRSxDQUFBOztBQUUvQjtBQUNBLElBQUEs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
