import { Debug } from '../core/debug.js';
import { RefCountedObject } from '../core/ref-counted-object.js';
import { Vec3 } from '../core/math/vec3.js';
import { FloatPacking } from '../core/math/float-packing.js';
import { BoundingBox } from '../core/shape/bounding-box.js';
import { Texture } from '../platform/graphics/texture.js';
import { VertexBuffer } from '../platform/graphics/vertex-buffer.js';
import { VertexFormat } from '../platform/graphics/vertex-format.js';
import { PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGB32F, BUFFER_STATIC, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, SEMANTIC_ATTR15, TYPE_UINT32, TYPE_FLOAT32 } from '../platform/graphics/constants.js';
import { GraphicsDeviceAccess } from '../platform/graphics/graphics-device-access.js';

/**
 * Contains a list of {@link MorphTarget}, a combined delta AABB and some associated data.
 */
class Morph extends RefCountedObject {
  /**
   * Create a new Morph instance.
   *
   * @param {import('./morph-target.js').MorphTarget[]} targets - A list of morph targets.
   * @param {import('../platform/graphics/graphics-device.js').GraphicsDevice} graphicsDevice -
   * The graphics device used to manage this morph target.
   * @param {object} [options] - Object for passing optional arguments.
   * @param {boolean} [options.preferHighPrecision] - True if high precision storage should be
   * prefered. This is faster to create and allows higher precision, but takes more memory and
   * might be slower to render. Defaults to false.
   */
  constructor(targets, graphicsDevice, {
    preferHighPrecision = false
  } = {}) {
    super();
    /** @type {BoundingBox} */
    this._aabb = void 0;
    /** @type {boolean} */
    this.preferHighPrecision = void 0;
    Debug.assertDeprecated(graphicsDevice, "Morph constructor takes a GraphicsDevice as a parameter, and it was not provided.");
    this.device = graphicsDevice || GraphicsDeviceAccess.get();
    this.preferHighPrecision = preferHighPrecision;

    // validation
    Debug.assert(targets.every(target => !target.used), 'A specified target has already been used to create a Morph, use its clone instead.');
    this._targets = targets.slice();

    // default to texture based morphing if available
    const device = this.device;
    if (device.supportsMorphTargetTexturesCore) {
      // renderable format
      const renderableHalf = device.extTextureHalfFloat && device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;
      const renderableFloat = device.extTextureFloat && device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;
      this._renderTextureFormat = this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;

      // texture format
      const textureHalf = device.extTextureHalfFloat && device.textureHalfFloatUpdatable ? PIXELFORMAT_RGBA16F : undefined;
      const textureFloat = device.extTextureFloat ? PIXELFORMAT_RGB32F : undefined;
      this._textureFormat = this.preferHighPrecision ? textureFloat != null ? textureFloat : textureHalf : textureHalf != null ? textureHalf : textureFloat;

      // if both available, enable texture morphing
      if (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {
        this._useTextureMorph = true;
      }
    }
    this._init();
    this._updateMorphFlags();
  }
  get aabb() {
    // lazy evaluation, which allows us to skip this completely if customAABB is used
    if (!this._aabb) {
      // calculate min and max expansion size
      // Note: This represents average case, where most morph targets expand the mesh within the same area. It does not
      // represent the stacked worst case scenario where all morphs could be enabled at the same time, as this can result
      // in a very large aabb. In cases like this, the users should specify customAabb for Model/Render component.
      const min = new Vec3();
      const max = new Vec3();
      for (let i = 0; i < this._targets.length; i++) {
        const targetAabb = this._targets[i].aabb;
        min.min(targetAabb.getMin());
        max.max(targetAabb.getMax());
      }
      this._aabb = new BoundingBox();
      this._aabb.setMinMax(min, max);
    }
    return this._aabb;
  }
  get morphPositions() {
    return this._morphPositions;
  }
  get morphNormals() {
    return this._morphNormals;
  }
  get maxActiveTargets() {
    // no limit when texture morph based
    if (this._useTextureMorph) return this._targets.length;
    return this._morphPositions && this._morphNormals ? 4 : 8;
  }
  get useTextureMorph() {
    return this._useTextureMorph;
  }
  _init() {
    // try to init texture based morphing
    if (this._useTextureMorph) {
      this._useTextureMorph = this._initTextureBased();
    }

    // if texture morphing is not set up, use attribute based morphing
    if (!this._useTextureMorph) {
      for (let i = 0; i < this._targets.length; i++) {
        this._targets[i]._initVertexBuffers(this.device);
      }
    }

    // finalize init
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i]._postInit();
    }
  }
  _findSparseSet(deltaArrays, ids, usedDataIndices, floatRounding) {
    let freeIndex = 1; // reserve slot 0 for zero delta
    const dataCount = deltaArrays[0].length;
    for (let v = 0; v < dataCount; v += 3) {
      // find if vertex is morphed by any target
      let vertexUsed = false;
      for (let i = 0; i < deltaArrays.length; i++) {
        const data = deltaArrays[i];

        // if non-zero delta
        if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
          vertexUsed = true;
          break;
        }
      }
      if (vertexUsed) {
        ids.push(freeIndex + floatRounding);
        usedDataIndices.push(v / 3);
        freeIndex++;
      } else {
        // non morphed vertices would be all mapped to pixel 0 of texture
        ids.push(0 + floatRounding);
      }
    }
    return freeIndex;
  }
  _initTextureBased() {
    // use uint32 for vertex Ids instead of float32
    const useUintIds = this.device.isWebGPU;

    // value added to floats which are used as ints on the shader side to avoid values being rounded to one less occasionally
    const floatRounding = useUintIds ? 0 : 0.2;

    // collect all source delta arrays to find sparse set of vertices
    const deltaArrays = [],
      deltaInfos = [];
    for (let i = 0; i < this._targets.length; i++) {
      const target = this._targets[i];
      if (target.options.deltaPositions) {
        deltaArrays.push(target.options.deltaPositions);
        deltaInfos.push({
          target: target,
          name: 'texturePositions'
        });
      }
      if (target.options.deltaNormals) {
        deltaArrays.push(target.options.deltaNormals);
        deltaInfos.push({
          target: target,
          name: 'textureNormals'
        });
      }
    }

    // find sparse set for all target deltas into usedDataIndices and build vertex id buffer
    const ids = [],
      usedDataIndices = [];
    const freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices, floatRounding);

    // max texture size: vertexBufferIds is stored in float32 format, giving us 2^24 range, so can address 4096 texture at maximum
    // TODO: on webgl2 we could store this in uint32 format and remove this limit
    const maxTextureSize = Math.min(this.device.maxTextureSize, 4096);

    // texture size for freeIndex pixels - roughly square
    let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
    morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
    const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);

    // if data cannot fit into max size texture, fail this set up
    if (morphTextureHeight > maxTextureSize) {
      return false;
    }
    this.morphTextureWidth = morphTextureWidth;
    this.morphTextureHeight = morphTextureHeight;

    // texture format based vars
    let halfFloat = false;
    let numComponents = 3; // RGB32 is used
    const float2Half = FloatPacking.float2Half;
    if (this._textureFormat === PIXELFORMAT_RGBA16F) {
      halfFloat = true;
      numComponents = 4; // RGBA16 is used, RGB16 does not work
    }

    // create textures
    const textures = [];
    for (let i = 0; i < deltaArrays.length; i++) {
      textures.push(this._createTexture('MorphTarget', this._textureFormat));
    }

    // build texture for each delta array, all textures are the same size
    for (let i = 0; i < deltaArrays.length; i++) {
      const data = deltaArrays[i];
      const texture = textures[i];
      const textureData = texture.lock();

      // copy full arrays into sparse arrays and convert format (skip 0th pixel - used by non-morphed vertices)
      if (halfFloat) {
        for (let v = 0; v < usedDataIndices.length; v++) {
          const index = usedDataIndices[v] * 3;
          const dstIndex = v * numComponents + numComponents;
          textureData[dstIndex] = float2Half(data[index]);
          textureData[dstIndex + 1] = float2Half(data[index + 1]);
          textureData[dstIndex + 2] = float2Half(data[index + 2]);
        }
      } else {
        for (let v = 0; v < usedDataIndices.length; v++) {
          const index = usedDataIndices[v] * 3;
          const dstIndex = v * numComponents + numComponents;
          textureData[dstIndex] = data[index];
          textureData[dstIndex + 1] = data[index + 1];
          textureData[dstIndex + 2] = data[index + 2];
        }
      }

      // assign texture to target
      texture.unlock();
      const target = deltaInfos[i].target;
      target._setTexture(deltaInfos[i].name, texture);
    }

    // create vertex stream with vertex_id used to map vertex to texture
    const formatDesc = [{
      semantic: SEMANTIC_ATTR15,
      components: 1,
      type: useUintIds ? TYPE_UINT32 : TYPE_FLOAT32
    }];
    this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids.length), ids.length, BUFFER_STATIC, useUintIds ? new Uint32Array(ids) : new Float32Array(ids));
    return true;
  }

  /**
   * Frees video memory allocated by this object.
   */
  destroy() {
    var _this$vertexBufferIds;
    (_this$vertexBufferIds = this.vertexBufferIds) == null ? void 0 : _this$vertexBufferIds.destroy();
    this.vertexBufferIds = null;
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i].destroy();
    }
    this._targets.length = 0;
  }

  /**
   * The array of morph targets.
   *
   * @type {import('./morph-target.js').MorphTarget[]}
   */
  get targets() {
    return this._targets;
  }
  _updateMorphFlags() {
    // find out if this morph needs to morph positions and normals
    this._morphPositions = false;
    this._morphNormals = false;
    for (let i = 0; i < this._targets.length; i++) {
      const target = this._targets[i];
      if (target.morphPositions) {
        this._morphPositions = true;
      }
      if (target.morphNormals) {
        this._morphNormals = true;
      }
    }
  }

  // creates texture. Used to create both source morph target data, as well as render target used to morph these into, positions and normals
  _createTexture(name, format) {
    return new Texture(this.device, {
      width: this.morphTextureWidth,
      height: this.morphTextureHeight,
      format: format,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: name
    });
  }
}

export { Morph };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ycGguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zY2VuZS9tb3JwaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZyB9IGZyb20gJy4uL2NvcmUvZGVidWcuanMnO1xuaW1wb3J0IHsgUmVmQ291bnRlZE9iamVjdCB9IGZyb20gJy4uL2NvcmUvcmVmLWNvdW50ZWQtb2JqZWN0LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9jb3JlL21hdGgvdmVjMy5qcyc7XG5pbXBvcnQgeyBGbG9hdFBhY2tpbmcgfSBmcm9tICcuLi9jb3JlL21hdGgvZmxvYXQtcGFja2luZy5qcyc7XG5pbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gJy4uL2NvcmUvc2hhcGUvYm91bmRpbmctYm94LmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi9wbGF0Zm9ybS9ncmFwaGljcy90ZXh0dXJlLmpzJztcbmltcG9ydCB7IFZlcnRleEJ1ZmZlciB9IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL3ZlcnRleC1idWZmZXIuanMnO1xuaW1wb3J0IHsgVmVydGV4Rm9ybWF0IH0gZnJvbSAnLi4vcGxhdGZvcm0vZ3JhcGhpY3MvdmVydGV4LWZvcm1hdC5qcyc7XG5cbmltcG9ydCB7XG4gICAgQlVGRkVSX1NUQVRJQywgVFlQRV9GTE9BVDMyLCBUWVBFX1VJTlQzMiwgU0VNQU5USUNfQVRUUjE1LCBBRERSRVNTX0NMQU1QX1RPX0VER0UsIEZJTFRFUl9ORUFSRVNULFxuICAgIFBJWEVMRk9STUFUX1JHQkExNkYsIFBJWEVMRk9STUFUX1JHQjMyRiwgUElYRUxGT1JNQVRfUkdCQTMyRlxufSBmcm9tICcuLi9wbGF0Zm9ybS9ncmFwaGljcy9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NEZXZpY2VBY2Nlc3MgfSBmcm9tICcuLi9wbGF0Zm9ybS9ncmFwaGljcy9ncmFwaGljcy1kZXZpY2UtYWNjZXNzLmpzJztcblxuLyoqXG4gKiBDb250YWlucyBhIGxpc3Qgb2Yge0BsaW5rIE1vcnBoVGFyZ2V0fSwgYSBjb21iaW5lZCBkZWx0YSBBQUJCIGFuZCBzb21lIGFzc29jaWF0ZWQgZGF0YS5cbiAqL1xuY2xhc3MgTW9ycGggZXh0ZW5kcyBSZWZDb3VudGVkT2JqZWN0IHtcbiAgICAvKiogQHR5cGUge0JvdW5kaW5nQm94fSAqL1xuICAgIF9hYWJiO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHByZWZlckhpZ2hQcmVjaXNpb247XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTW9ycGggaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9tb3JwaC10YXJnZXQuanMnKS5Nb3JwaFRhcmdldFtdfSB0YXJnZXRzIC0gQSBsaXN0IG9mIG1vcnBoIHRhcmdldHMuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3BsYXRmb3JtL2dyYXBoaWNzL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSBncmFwaGljc0RldmljZSAtXG4gICAgICogVGhlIGdyYXBoaWNzIGRldmljZSB1c2VkIHRvIG1hbmFnZSB0aGlzIG1vcnBoIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT2JqZWN0IGZvciBwYXNzaW5nIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZWZlckhpZ2hQcmVjaXNpb25dIC0gVHJ1ZSBpZiBoaWdoIHByZWNpc2lvbiBzdG9yYWdlIHNob3VsZCBiZVxuICAgICAqIHByZWZlcmVkLiBUaGlzIGlzIGZhc3RlciB0byBjcmVhdGUgYW5kIGFsbG93cyBoaWdoZXIgcHJlY2lzaW9uLCBidXQgdGFrZXMgbW9yZSBtZW1vcnkgYW5kXG4gICAgICogbWlnaHQgYmUgc2xvd2VyIHRvIHJlbmRlci4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0cywgZ3JhcGhpY3NEZXZpY2UsIHsgcHJlZmVySGlnaFByZWNpc2lvbiA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIERlYnVnLmFzc2VydERlcHJlY2F0ZWQoZ3JhcGhpY3NEZXZpY2UsIFwiTW9ycGggY29uc3RydWN0b3IgdGFrZXMgYSBHcmFwaGljc0RldmljZSBhcyBhIHBhcmFtZXRlciwgYW5kIGl0IHdhcyBub3QgcHJvdmlkZWQuXCIpO1xuICAgICAgICB0aGlzLmRldmljZSA9IGdyYXBoaWNzRGV2aWNlIHx8IEdyYXBoaWNzRGV2aWNlQWNjZXNzLmdldCgpO1xuXG4gICAgICAgIHRoaXMucHJlZmVySGlnaFByZWNpc2lvbiA9IHByZWZlckhpZ2hQcmVjaXNpb247XG5cbiAgICAgICAgLy8gdmFsaWRhdGlvblxuICAgICAgICBEZWJ1Zy5hc3NlcnQodGFyZ2V0cy5ldmVyeSh0YXJnZXQgPT4gIXRhcmdldC51c2VkKSwgJ0Egc3BlY2lmaWVkIHRhcmdldCBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgdG8gY3JlYXRlIGEgTW9ycGgsIHVzZSBpdHMgY2xvbmUgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMuc2xpY2UoKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHRvIHRleHR1cmUgYmFzZWQgbW9ycGhpbmcgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xuICAgICAgICBpZiAoZGV2aWNlLnN1cHBvcnRzTW9ycGhUYXJnZXRUZXh0dXJlc0NvcmUpIHtcblxuICAgICAgICAgICAgLy8gcmVuZGVyYWJsZSBmb3JtYXRcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmFibGVIYWxmID0gKGRldmljZS5leHRUZXh0dXJlSGFsZkZsb2F0ICYmIGRldmljZS50ZXh0dXJlSGFsZkZsb2F0UmVuZGVyYWJsZSkgPyBQSVhFTEZPUk1BVF9SR0JBMTZGIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyYWJsZUZsb2F0ID0gKGRldmljZS5leHRUZXh0dXJlRmxvYXQgJiYgZGV2aWNlLnRleHR1cmVGbG9hdFJlbmRlcmFibGUpID8gUElYRUxGT1JNQVRfUkdCQTMyRiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVGb3JtYXQgPSB0aGlzLnByZWZlckhpZ2hQcmVjaXNpb24gP1xuICAgICAgICAgICAgICAgIChyZW5kZXJhYmxlRmxvYXQgPz8gcmVuZGVyYWJsZUhhbGYpIDogKHJlbmRlcmFibGVIYWxmID8/IHJlbmRlcmFibGVGbG9hdCk7XG5cbiAgICAgICAgICAgIC8vIHRleHR1cmUgZm9ybWF0XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlSGFsZiA9IChkZXZpY2UuZXh0VGV4dHVyZUhhbGZGbG9hdCAmJiBkZXZpY2UudGV4dHVyZUhhbGZGbG9hdFVwZGF0YWJsZSkgPyBQSVhFTEZPUk1BVF9SR0JBMTZGIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZUZsb2F0ID0gZGV2aWNlLmV4dFRleHR1cmVGbG9hdCA/IFBJWEVMRk9STUFUX1JHQjMyRiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVGb3JtYXQgPSB0aGlzLnByZWZlckhpZ2hQcmVjaXNpb24gP1xuICAgICAgICAgICAgICAgICh0ZXh0dXJlRmxvYXQgPz8gdGV4dHVyZUhhbGYpIDogKHRleHR1cmVIYWxmID8/IHRleHR1cmVGbG9hdCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXZhaWxhYmxlLCBlbmFibGUgdGV4dHVyZSBtb3JwaGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmVGb3JtYXQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90ZXh0dXJlRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VUZXh0dXJlTW9ycGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVNb3JwaEZsYWdzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGFhYmIoKSB7XG5cbiAgICAgICAgLy8gbGF6eSBldmFsdWF0aW9uLCB3aGljaCBhbGxvd3MgdXMgdG8gc2tpcCB0aGlzIGNvbXBsZXRlbHkgaWYgY3VzdG9tQUFCQiBpcyB1c2VkXG4gICAgICAgIGlmICghdGhpcy5fYWFiYikge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1pbiBhbmQgbWF4IGV4cGFuc2lvbiBzaXplXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIHJlcHJlc2VudHMgYXZlcmFnZSBjYXNlLCB3aGVyZSBtb3N0IG1vcnBoIHRhcmdldHMgZXhwYW5kIHRoZSBtZXNoIHdpdGhpbiB0aGUgc2FtZSBhcmVhLiBJdCBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gcmVwcmVzZW50IHRoZSBzdGFja2VkIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2hlcmUgYWxsIG1vcnBocyBjb3VsZCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUsIGFzIHRoaXMgY2FuIHJlc3VsdFxuICAgICAgICAgICAgLy8gaW4gYSB2ZXJ5IGxhcmdlIGFhYmIuIEluIGNhc2VzIGxpa2UgdGhpcywgdGhlIHVzZXJzIHNob3VsZCBzcGVjaWZ5IGN1c3RvbUFhYmIgZm9yIE1vZGVsL1JlbmRlciBjb21wb25lbnQuXG4gICAgICAgICAgICBjb25zdCBtaW4gPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEFhYmIgPSB0aGlzLl90YXJnZXRzW2ldLmFhYmI7XG4gICAgICAgICAgICAgICAgbWluLm1pbih0YXJnZXRBYWJiLmdldE1pbigpKTtcbiAgICAgICAgICAgICAgICBtYXgubWF4KHRhcmdldEFhYmIuZ2V0TWF4KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hYWJiID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB0aGlzLl9hYWJiLnNldE1pbk1heChtaW4sIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYWFiYjtcbiAgICB9XG5cbiAgICBnZXQgbW9ycGhQb3NpdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3JwaFBvc2l0aW9ucztcbiAgICB9XG5cbiAgICBnZXQgbW9ycGhOb3JtYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9ycGhOb3JtYWxzO1xuICAgIH1cblxuICAgIGdldCBtYXhBY3RpdmVUYXJnZXRzKCkge1xuXG4gICAgICAgIC8vIG5vIGxpbWl0IHdoZW4gdGV4dHVyZSBtb3JwaCBiYXNlZFxuICAgICAgICBpZiAodGhpcy5fdXNlVGV4dHVyZU1vcnBoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5fbW9ycGhQb3NpdGlvbnMgJiYgdGhpcy5fbW9ycGhOb3JtYWxzKSA/IDQgOiA4O1xuICAgIH1cblxuICAgIGdldCB1c2VUZXh0dXJlTW9ycGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VUZXh0dXJlTW9ycGg7XG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGluaXQgdGV4dHVyZSBiYXNlZCBtb3JwaGluZ1xuICAgICAgICBpZiAodGhpcy5fdXNlVGV4dHVyZU1vcnBoKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VUZXh0dXJlTW9ycGggPSB0aGlzLl9pbml0VGV4dHVyZUJhc2VkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0ZXh0dXJlIG1vcnBoaW5nIGlzIG5vdCBzZXQgdXAsIHVzZSBhdHRyaWJ1dGUgYmFzZWQgbW9ycGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLl91c2VUZXh0dXJlTW9ycGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldHNbaV0uX2luaXRWZXJ0ZXhCdWZmZXJzKHRoaXMuZGV2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsaXplIGluaXRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRzW2ldLl9wb3N0SW5pdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2ZpbmRTcGFyc2VTZXQoZGVsdGFBcnJheXMsIGlkcywgdXNlZERhdGFJbmRpY2VzLCBmbG9hdFJvdW5kaW5nKSB7XG5cbiAgICAgICAgbGV0IGZyZWVJbmRleCA9IDE7ICAvLyByZXNlcnZlIHNsb3QgMCBmb3IgemVybyBkZWx0YVxuICAgICAgICBjb25zdCBkYXRhQ291bnQgPSBkZWx0YUFycmF5c1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgZGF0YUNvdW50OyB2ICs9IDMpIHtcblxuICAgICAgICAgICAgLy8gZmluZCBpZiB2ZXJ0ZXggaXMgbW9ycGhlZCBieSBhbnkgdGFyZ2V0XG4gICAgICAgICAgICBsZXQgdmVydGV4VXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YUFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkZWx0YUFycmF5c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG5vbi16ZXJvIGRlbHRhXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbdl0gIT09IDAgfHwgZGF0YVt2ICsgMV0gIT09IDAgfHwgZGF0YVt2ICsgMl0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZlcnRleFVzZWQpIHtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChmcmVlSW5kZXggKyBmbG9hdFJvdW5kaW5nKTtcbiAgICAgICAgICAgICAgICB1c2VkRGF0YUluZGljZXMucHVzaCh2IC8gMyk7XG4gICAgICAgICAgICAgICAgZnJlZUluZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vbiBtb3JwaGVkIHZlcnRpY2VzIHdvdWxkIGJlIGFsbCBtYXBwZWQgdG8gcGl4ZWwgMCBvZiB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgaWRzLnB1c2goMCArIGZsb2F0Um91bmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyZWVJbmRleDtcbiAgICB9XG5cbiAgICBfaW5pdFRleHR1cmVCYXNlZCgpIHtcblxuICAgICAgICAvLyB1c2UgdWludDMyIGZvciB2ZXJ0ZXggSWRzIGluc3RlYWQgb2YgZmxvYXQzMlxuICAgICAgICBjb25zdCB1c2VVaW50SWRzID0gdGhpcy5kZXZpY2UuaXNXZWJHUFU7XG5cbiAgICAgICAgLy8gdmFsdWUgYWRkZWQgdG8gZmxvYXRzIHdoaWNoIGFyZSB1c2VkIGFzIGludHMgb24gdGhlIHNoYWRlciBzaWRlIHRvIGF2b2lkIHZhbHVlcyBiZWluZyByb3VuZGVkIHRvIG9uZSBsZXNzIG9jY2FzaW9uYWxseVxuICAgICAgICBjb25zdCBmbG9hdFJvdW5kaW5nID0gdXNlVWludElkcyA/IDAgOiAwLjI7XG5cbiAgICAgICAgLy8gY29sbGVjdCBhbGwgc291cmNlIGRlbHRhIGFycmF5cyB0byBmaW5kIHNwYXJzZSBzZXQgb2YgdmVydGljZXNcbiAgICAgICAgY29uc3QgZGVsdGFBcnJheXMgPSBbXSwgZGVsdGFJbmZvcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldHNbaV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm9wdGlvbnMuZGVsdGFQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBkZWx0YUFycmF5cy5wdXNoKHRhcmdldC5vcHRpb25zLmRlbHRhUG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICBkZWx0YUluZm9zLnB1c2goeyB0YXJnZXQ6IHRhcmdldCwgbmFtZTogJ3RleHR1cmVQb3NpdGlvbnMnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLmRlbHRhTm9ybWFscykge1xuICAgICAgICAgICAgICAgIGRlbHRhQXJyYXlzLnB1c2godGFyZ2V0Lm9wdGlvbnMuZGVsdGFOb3JtYWxzKTtcbiAgICAgICAgICAgICAgICBkZWx0YUluZm9zLnB1c2goeyB0YXJnZXQ6IHRhcmdldCwgbmFtZTogJ3RleHR1cmVOb3JtYWxzJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgc3BhcnNlIHNldCBmb3IgYWxsIHRhcmdldCBkZWx0YXMgaW50byB1c2VkRGF0YUluZGljZXMgYW5kIGJ1aWxkIHZlcnRleCBpZCBidWZmZXJcbiAgICAgICAgY29uc3QgaWRzID0gW10sIHVzZWREYXRhSW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBmcmVlSW5kZXggPSB0aGlzLl9maW5kU3BhcnNlU2V0KGRlbHRhQXJyYXlzLCBpZHMsIHVzZWREYXRhSW5kaWNlcywgZmxvYXRSb3VuZGluZyk7XG5cbiAgICAgICAgLy8gbWF4IHRleHR1cmUgc2l6ZTogdmVydGV4QnVmZmVySWRzIGlzIHN0b3JlZCBpbiBmbG9hdDMyIGZvcm1hdCwgZ2l2aW5nIHVzIDJeMjQgcmFuZ2UsIHNvIGNhbiBhZGRyZXNzIDQwOTYgdGV4dHVyZSBhdCBtYXhpbXVtXG4gICAgICAgIC8vIFRPRE86IG9uIHdlYmdsMiB3ZSBjb3VsZCBzdG9yZSB0aGlzIGluIHVpbnQzMiBmb3JtYXQgYW5kIHJlbW92ZSB0aGlzIGxpbWl0XG4gICAgICAgIGNvbnN0IG1heFRleHR1cmVTaXplID0gTWF0aC5taW4odGhpcy5kZXZpY2UubWF4VGV4dHVyZVNpemUsIDQwOTYpO1xuXG4gICAgICAgIC8vIHRleHR1cmUgc2l6ZSBmb3IgZnJlZUluZGV4IHBpeGVscyAtIHJvdWdobHkgc3F1YXJlXG4gICAgICAgIGxldCBtb3JwaFRleHR1cmVXaWR0aCA9IE1hdGguY2VpbChNYXRoLnNxcnQoZnJlZUluZGV4KSk7XG4gICAgICAgIG1vcnBoVGV4dHVyZVdpZHRoID0gTWF0aC5taW4obW9ycGhUZXh0dXJlV2lkdGgsIG1heFRleHR1cmVTaXplKTtcbiAgICAgICAgY29uc3QgbW9ycGhUZXh0dXJlSGVpZ2h0ID0gTWF0aC5jZWlsKGZyZWVJbmRleCAvIG1vcnBoVGV4dHVyZVdpZHRoKTtcblxuICAgICAgICAvLyBpZiBkYXRhIGNhbm5vdCBmaXQgaW50byBtYXggc2l6ZSB0ZXh0dXJlLCBmYWlsIHRoaXMgc2V0IHVwXG4gICAgICAgIGlmIChtb3JwaFRleHR1cmVIZWlnaHQgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3JwaFRleHR1cmVXaWR0aCA9IG1vcnBoVGV4dHVyZVdpZHRoO1xuICAgICAgICB0aGlzLm1vcnBoVGV4dHVyZUhlaWdodCA9IG1vcnBoVGV4dHVyZUhlaWdodDtcblxuICAgICAgICAvLyB0ZXh0dXJlIGZvcm1hdCBiYXNlZCB2YXJzXG4gICAgICAgIGxldCBoYWxmRmxvYXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG51bUNvbXBvbmVudHMgPSAzOyAgLy8gUkdCMzIgaXMgdXNlZFxuICAgICAgICBjb25zdCBmbG9hdDJIYWxmID0gRmxvYXRQYWNraW5nLmZsb2F0MkhhbGY7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlRm9ybWF0ID09PSBQSVhFTEZPUk1BVF9SR0JBMTZGKSB7XG4gICAgICAgICAgICBoYWxmRmxvYXQgPSB0cnVlO1xuICAgICAgICAgICAgbnVtQ29tcG9uZW50cyA9IDQ7ICAvLyBSR0JBMTYgaXMgdXNlZCwgUkdCMTYgZG9lcyBub3Qgd29ya1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRleHR1cmVzXG4gICAgICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGFBcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRleHR1cmVzLnB1c2godGhpcy5fY3JlYXRlVGV4dHVyZSgnTW9ycGhUYXJnZXQnLCB0aGlzLl90ZXh0dXJlRm9ybWF0KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCB0ZXh0dXJlIGZvciBlYWNoIGRlbHRhIGFycmF5LCBhbGwgdGV4dHVyZXMgYXJlIHRoZSBzYW1lIHNpemVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YUFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRlbHRhQXJyYXlzW2ldO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRleHR1cmVzW2ldO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZURhdGEgPSB0ZXh0dXJlLmxvY2soKTtcblxuICAgICAgICAgICAgLy8gY29weSBmdWxsIGFycmF5cyBpbnRvIHNwYXJzZSBhcnJheXMgYW5kIGNvbnZlcnQgZm9ybWF0IChza2lwIDB0aCBwaXhlbCAtIHVzZWQgYnkgbm9uLW1vcnBoZWQgdmVydGljZXMpXG4gICAgICAgICAgICBpZiAoaGFsZkZsb2F0KSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHVzZWREYXRhSW5kaWNlcy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHVzZWREYXRhSW5kaWNlc1t2XSAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRzdEluZGV4ID0gdiAqIG51bUNvbXBvbmVudHMgKyBudW1Db21wb25lbnRzO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YVtkc3RJbmRleF0gPSBmbG9hdDJIYWxmKGRhdGFbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZURhdGFbZHN0SW5kZXggKyAxXSA9IGZsb2F0MkhhbGYoZGF0YVtpbmRleCArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZURhdGFbZHN0SW5kZXggKyAyXSA9IGZsb2F0MkhhbGYoZGF0YVtpbmRleCArIDJdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHVzZWREYXRhSW5kaWNlcy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHVzZWREYXRhSW5kaWNlc1t2XSAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRzdEluZGV4ID0gdiAqIG51bUNvbXBvbmVudHMgKyBudW1Db21wb25lbnRzO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YVtkc3RJbmRleF0gPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZURhdGFbZHN0SW5kZXggKyAxXSA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZURhdGFbZHN0SW5kZXggKyAyXSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFzc2lnbiB0ZXh0dXJlIHRvIHRhcmdldFxuICAgICAgICAgICAgdGV4dHVyZS51bmxvY2soKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGRlbHRhSW5mb3NbaV0udGFyZ2V0O1xuICAgICAgICAgICAgdGFyZ2V0Ll9zZXRUZXh0dXJlKGRlbHRhSW5mb3NbaV0ubmFtZSwgdGV4dHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgdmVydGV4IHN0cmVhbSB3aXRoIHZlcnRleF9pZCB1c2VkIHRvIG1hcCB2ZXJ0ZXggdG8gdGV4dHVyZVxuICAgICAgICBjb25zdCBmb3JtYXREZXNjID0gW3sgc2VtYW50aWM6IFNFTUFOVElDX0FUVFIxNSwgY29tcG9uZW50czogMSwgdHlwZTogdXNlVWludElkcyA/IFRZUEVfVUlOVDMyIDogVFlQRV9GTE9BVDMyIH1dO1xuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcklkcyA9IG5ldyBWZXJ0ZXhCdWZmZXIodGhpcy5kZXZpY2UsIG5ldyBWZXJ0ZXhGb3JtYXQodGhpcy5kZXZpY2UsIGZvcm1hdERlc2MsIGlkcy5sZW5ndGgpLCBpZHMubGVuZ3RoLCBCVUZGRVJfU1RBVElDLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlVWludElkcyA/IG5ldyBVaW50MzJBcnJheShpZHMpIDogbmV3IEZsb2F0MzJBcnJheShpZHMpKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcmVlcyB2aWRlbyBtZW1vcnkgYWxsb2NhdGVkIGJ5IHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVySWRzPy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVySWRzID0gbnVsbDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldHNbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhcmdldHMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgbW9ycGggdGFyZ2V0cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4vbW9ycGgtdGFyZ2V0LmpzJykuTW9ycGhUYXJnZXRbXX1cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldHM7XG4gICAgfVxuXG4gICAgX3VwZGF0ZU1vcnBoRmxhZ3MoKSB7XG5cbiAgICAgICAgLy8gZmluZCBvdXQgaWYgdGhpcyBtb3JwaCBuZWVkcyB0byBtb3JwaCBwb3NpdGlvbnMgYW5kIG5vcm1hbHNcbiAgICAgICAgdGhpcy5fbW9ycGhQb3NpdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW9ycGhOb3JtYWxzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tpXTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubW9ycGhQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3JwaFBvc2l0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm1vcnBoTm9ybWFscykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vcnBoTm9ybWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjcmVhdGVzIHRleHR1cmUuIFVzZWQgdG8gY3JlYXRlIGJvdGggc291cmNlIG1vcnBoIHRhcmdldCBkYXRhLCBhcyB3ZWxsIGFzIHJlbmRlciB0YXJnZXQgdXNlZCB0byBtb3JwaCB0aGVzZSBpbnRvLCBwb3NpdGlvbnMgYW5kIG5vcm1hbHNcbiAgICBfY3JlYXRlVGV4dHVyZShuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMuZGV2aWNlLCB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5tb3JwaFRleHR1cmVXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5tb3JwaFRleHR1cmVIZWlnaHQsXG4gICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgICAgIGN1YmVtYXA6IGZhbHNlLFxuICAgICAgICAgICAgbWlwbWFwczogZmFsc2UsXG4gICAgICAgICAgICBtaW5GaWx0ZXI6IEZJTFRFUl9ORUFSRVNULFxuICAgICAgICAgICAgbWFnRmlsdGVyOiBGSUxURVJfTkVBUkVTVCxcbiAgICAgICAgICAgIGFkZHJlc3NVOiBBRERSRVNTX0NMQU1QX1RPX0VER0UsXG4gICAgICAgICAgICBhZGRyZXNzVjogQUREUkVTU19DTEFNUF9UT19FREdFLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IE1vcnBoIH07XG4iXSwibmFtZXMiOlsiTW9ycGgiLCJSZWZDb3VudGVkT2JqZWN0IiwiY29uc3RydWN0b3IiLCJ0YXJnZXRzIiwiZ3JhcGhpY3NEZXZpY2UiLCJwcmVmZXJIaWdoUHJlY2lzaW9uIiwiX2FhYmIiLCJEZWJ1ZyIsImFzc2VydERlcHJlY2F0ZWQiLCJkZXZpY2UiLCJHcmFwaGljc0RldmljZUFjY2VzcyIsImdldCIsImFzc2VydCIsImV2ZXJ5IiwidGFyZ2V0IiwidXNlZCIsIl90YXJnZXRzIiwic2xpY2UiLCJzdXBwb3J0c01vcnBoVGFyZ2V0VGV4dHVyZXNDb3JlIiwicmVuZGVyYWJsZUhhbGYiLCJleHRUZXh0dXJlSGFsZkZsb2F0IiwidGV4dHVyZUhhbGZGbG9hdFJlbmRlcmFibGUiLCJQSVhFTEZPUk1BVF9SR0JBMTZGIiwidW5kZWZpbmVkIiwicmVuZGVyYWJsZUZsb2F0IiwiZXh0VGV4dHVyZUZsb2F0IiwidGV4dHVyZUZsb2F0UmVuZGVyYWJsZSIsIlBJWEVMRk9STUFUX1JHQkEzMkYiLCJfcmVuZGVyVGV4dHVyZUZvcm1hdCIsInRleHR1cmVIYWxmIiwidGV4dHVyZUhhbGZGbG9hdFVwZGF0YWJsZSIsInRleHR1cmVGbG9hdCIsIlBJWEVMRk9STUFUX1JHQjMyRiIsIl90ZXh0dXJlRm9ybWF0IiwiX3VzZVRleHR1cmVNb3JwaCIsIl9pbml0IiwiX3VwZGF0ZU1vcnBoRmxhZ3MiLCJhYWJiIiwibWluIiwiVmVjMyIsIm1heCIsImkiLCJsZW5ndGgiLCJ0YXJnZXRBYWJiIiwiZ2V0TWluIiwiZ2V0TWF4IiwiQm91bmRpbmdCb3giLCJzZXRNaW5NYXgiLCJtb3JwaFBvc2l0aW9ucyIsIl9tb3JwaFBvc2l0aW9ucyIsIm1vcnBoTm9ybWFscyIsIl9tb3JwaE5vcm1hbHMiLCJtYXhBY3RpdmVUYXJnZXRzIiwidXNlVGV4dHVyZU1vcnBoIiwiX2luaXRUZXh0dXJlQmFzZWQiLCJfaW5pdFZlcnRleEJ1ZmZlcnMiLCJfcG9zdEluaXQiLCJfZmluZFNwYXJzZVNldCIsImRlbHRhQXJyYXlzIiwiaWRzIiwidXNlZERhdGFJbmRpY2VzIiwiZmxvYXRSb3VuZGluZyIsImZyZWVJbmRleCIsImRhdGFDb3VudCIsInYiLCJ2ZXJ0ZXhVc2VkIiwiZGF0YSIsInB1c2giLCJ1c2VVaW50SWRzIiwiaXNXZWJHUFUiLCJkZWx0YUluZm9zIiwib3B0aW9ucyIsImRlbHRhUG9zaXRpb25zIiwibmFtZSIsImRlbHRhTm9ybWFscyIsIm1heFRleHR1cmVTaXplIiwiTWF0aCIsIm1vcnBoVGV4dHVyZVdpZHRoIiwiY2VpbCIsInNxcnQiLCJtb3JwaFRleHR1cmVIZWlnaHQiLCJoYWxmRmxvYXQiLCJudW1Db21wb25lbnRzIiwiZmxvYXQySGFsZiIsIkZsb2F0UGFja2luZyIsInRleHR1cmVzIiwiX2NyZWF0ZVRleHR1cmUiLCJ0ZXh0dXJlIiwidGV4dHVyZURhdGEiLCJsb2NrIiwiaW5kZXgiLCJkc3RJbmRleCIsInVubG9jayIsIl9zZXRUZXh0dXJlIiwiZm9ybWF0RGVzYyIsInNlbWFudGljIiwiU0VNQU5USUNfQVRUUjE1IiwiY29tcG9uZW50cyIsInR5cGUiLCJUWVBFX1VJTlQzMiIsIlRZUEVfRkxPQVQzMiIsInZlcnRleEJ1ZmZlcklkcyIsIlZlcnRleEJ1ZmZlciIsIlZlcnRleEZvcm1hdCIsIkJVRkZFUl9TVEFUSUMiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsImRlc3Ryb3kiLCJfdGhpcyR2ZXJ0ZXhCdWZmZXJJZHMiLCJmb3JtYXQiLCJUZXh0dXJlIiwid2lkdGgiLCJoZWlnaHQiLCJjdWJlbWFwIiwibWlwbWFwcyIsIm1pbkZpbHRlciIsIkZJTFRFUl9ORUFSRVNUIiwibWFnRmlsdGVyIiwiYWRkcmVzc1UiLCJBRERSRVNTX0NMQU1QX1RPX0VER0UiLCJhZGRyZXNzViJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxLQUFLLFNBQVNDLGdCQUFnQixDQUFDO0FBT2pDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsRUFBQUEsV0FBV0EsQ0FBQ0MsT0FBTyxFQUFFQyxjQUFjLEVBQUU7QUFBRUMsSUFBQUEsbUJBQW1CLEdBQUcsS0FBQTtHQUFPLEdBQUcsRUFBRSxFQUFFO0FBQ3ZFLElBQUEsS0FBSyxFQUFFLENBQUE7QUFsQlg7QUFBQSxJQUFBLElBQUEsQ0FDQUMsS0FBSyxHQUFBLEtBQUEsQ0FBQSxDQUFBO0FBRUw7QUFBQSxJQUFBLElBQUEsQ0FDQUQsbUJBQW1CLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFnQmZFLElBQUFBLEtBQUssQ0FBQ0MsZ0JBQWdCLENBQUNKLGNBQWMsRUFBRSxtRkFBbUYsQ0FBQyxDQUFBO0lBQzNILElBQUksQ0FBQ0ssTUFBTSxHQUFHTCxjQUFjLElBQUlNLG9CQUFvQixDQUFDQyxHQUFHLEVBQUUsQ0FBQTtJQUUxRCxJQUFJLENBQUNOLG1CQUFtQixHQUFHQSxtQkFBbUIsQ0FBQTs7QUFFOUM7QUFDQUUsSUFBQUEsS0FB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
