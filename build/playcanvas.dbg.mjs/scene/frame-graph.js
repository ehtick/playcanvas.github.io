/**
 * @license
 * PlayCanvas Engine v1.63.0-dev revision 9f3635a4e (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
/**
 * A frame graph represents a single rendering frame as a sequence of render passes.
 *
 * @ignore
 */
class FrameGraph {
  constructor() {
    this.renderPasses = [];
    this.renderTargetMap = new Map();
  }
  /**
   * Add a render pass to the frame.
   *
   * @param {import('../platform/graphics/render-pass.js').RenderPass} renderPass - The render
   * pass to add.
   */
  addRenderPass(renderPass) {
    this.renderPasses.push(renderPass);
  }
  reset() {
    this.renderPasses.length = 0;
  }
  compile() {
    const renderTargetMap = this.renderTargetMap;
    const renderPasses = this.renderPasses;
    for (let i = 0; i < renderPasses.length; i++) {
      const renderPass = renderPasses[i];
      const renderTarget = renderPass.renderTarget;

      // if using a target, or null which represents the default framebuffer
      if (renderTarget !== undefined) {
        // previous pass using the same render target
        const prevPass = renderTargetMap.get(renderTarget);
        if (prevPass) {
          // if we use the RT without clearing, make sure the previous pass stores data
          if (!renderPass.colorOps.clear) {
            prevPass.colorOps.store = true;
          }
          if (!renderPass.depthStencilOps.clearDepth) {
            prevPass.depthStencilOps.storeDepth = true;
          }
          if (!renderPass.depthStencilOps.clearStencil) {
            prevPass.depthStencilOps.storeStencil = true;
          }
        }

        // add the pass to the map
        renderTargetMap.set(renderTarget, renderPass);
      }
    }

    // Walk over render passes to find passes rendering to the same cubemap texture.
    // If those passes are separated only by passes not requiring cubemap (shadows ..),
    // we skip the mipmap generation till the last rendering to the cubemap, to avoid
    // mipmaps being generated after each face.
    /** @type {import('../platform/graphics/texture.js').Texture} */
    let lastCubeTexture = null;
    /** @type {import('../platform/graphics/render-pass.js').RenderPass} */
    let lastCubeRenderPass = null;
    for (let i = 0; i < renderPasses.length; i++) {
      const renderPass = renderPasses[i];
      const renderTarget = renderPass.renderTarget;
      const thisTexture = renderTarget == null ? void 0 : renderTarget.colorBuffer;
      if (thisTexture != null && thisTexture.cubemap) {
        // if previous pass used the same cubemap texture, it does not need mipmaps generated
        if (lastCubeTexture === thisTexture) {
          lastCubeRenderPass.colorOps.mipmaps = false;
        }
        lastCubeTexture = renderTarget.colorBuffer;
        lastCubeRenderPass = renderPass;
      } else if (renderPass.requiresCubemaps) {
        // if the cubemap is required, break the cubemap rendering chain
        lastCubeTexture = null;
        lastCubeRenderPass = null;
      }
    }

    // handle what's left in the map - last passes rendering to each render target
    renderTargetMap.forEach((renderPass, renderTarget) => {
      // default framebuffer
      if (renderTarget === null) {
        // store the multisampled buffer
        renderPass.colorOps.store = true;

        // no resolve, no mipmaps
        renderPass.colorOps.resolve = false;
        renderPass.colorOps.mipmaps = false;
      }
    });
    renderTargetMap.clear();
  }
  render(device) {
    this.compile();
    const renderPasses = this.renderPasses;
    for (let i = 0; i < renderPasses.length; i++) {
      renderPasses[i].render();
    }
  }
}

export { FrameGraph };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWUtZ3JhcGguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zY2VuZS9mcmFtZS1ncmFwaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgZnJhbWUgZ3JhcGggcmVwcmVzZW50cyBhIHNpbmdsZSByZW5kZXJpbmcgZnJhbWUgYXMgYSBzZXF1ZW5jZSBvZiByZW5kZXIgcGFzc2VzLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgRnJhbWVHcmFwaCB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL3BsYXRmb3JtL2dyYXBoaWNzL3JlbmRlci1wYXNzLmpzJykuUmVuZGVyUGFzc1tdfSAqL1xuICAgIHJlbmRlclBhc3NlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTWFwIHVzZWQgZHVyaW5nIGZyYW1lIGdyYXBoIGNvbXBpbGF0aW9uLiBJdCBtYXBzIGEgcmVuZGVyIHRhcmdldCB0byBpdHMgcHJldmlvdXMgb2NjdXJyZW5jZS5cbiAgICAgKlxuICAgICAqICBAdHlwZSB7TWFwPGltcG9ydCgnLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXRhcmdldC5qcycpLlJlbmRlclRhcmdldCwgaW1wb3J0KCcuLi9wbGF0Zm9ybS9ncmFwaGljcy9yZW5kZXItcGFzcy5qcycpLlJlbmRlclBhc3M+fVxuICAgICAqL1xuICAgIHJlbmRlclRhcmdldE1hcCA9IG5ldyBNYXAoKTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlbmRlciBwYXNzIHRvIHRoZSBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9wbGF0Zm9ybS9ncmFwaGljcy9yZW5kZXItcGFzcy5qcycpLlJlbmRlclBhc3N9IHJlbmRlclBhc3MgLSBUaGUgcmVuZGVyXG4gICAgICogcGFzcyB0byBhZGQuXG4gICAgICovXG4gICAgYWRkUmVuZGVyUGFzcyhyZW5kZXJQYXNzKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGFzc2VzLnB1c2gocmVuZGVyUGFzcyk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGFzc2VzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgY29tcGlsZSgpIHtcblxuICAgICAgICBjb25zdCByZW5kZXJUYXJnZXRNYXAgPSB0aGlzLnJlbmRlclRhcmdldE1hcDtcbiAgICAgICAgY29uc3QgcmVuZGVyUGFzc2VzID0gdGhpcy5yZW5kZXJQYXNzZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyUGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJQYXNzID0gcmVuZGVyUGFzc2VzW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyUGFzcy5yZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHVzaW5nIGEgdGFyZ2V0LCBvciBudWxsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRlZmF1bHQgZnJhbWVidWZmZXJcbiAgICAgICAgICAgIGlmIChyZW5kZXJUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcGFzcyB1c2luZyB0aGUgc2FtZSByZW5kZXIgdGFyZ2V0XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlBhc3MgPSByZW5kZXJUYXJnZXRNYXAuZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZQYXNzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgdXNlIHRoZSBSVCB3aXRob3V0IGNsZWFyaW5nLCBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIHBhc3Mgc3RvcmVzIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW5kZXJQYXNzLmNvbG9yT3BzLmNsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2UGFzcy5jb2xvck9wcy5zdG9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW5kZXJQYXNzLmRlcHRoU3RlbmNpbE9wcy5jbGVhckRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2UGFzcy5kZXB0aFN0ZW5jaWxPcHMuc3RvcmVEZXB0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW5kZXJQYXNzLmRlcHRoU3RlbmNpbE9wcy5jbGVhclN0ZW5jaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZQYXNzLmRlcHRoU3RlbmNpbE9wcy5zdG9yZVN0ZW5jaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBwYXNzIHRvIHRoZSBtYXBcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRNYXAuc2V0KHJlbmRlclRhcmdldCwgcmVuZGVyUGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWxrIG92ZXIgcmVuZGVyIHBhc3NlcyB0byBmaW5kIHBhc3NlcyByZW5kZXJpbmcgdG8gdGhlIHNhbWUgY3ViZW1hcCB0ZXh0dXJlLlxuICAgICAgICAvLyBJZiB0aG9zZSBwYXNzZXMgYXJlIHNlcGFyYXRlZCBvbmx5IGJ5IHBhc3NlcyBub3QgcmVxdWlyaW5nIGN1YmVtYXAgKHNoYWRvd3MgLi4pLFxuICAgICAgICAvLyB3ZSBza2lwIHRoZSBtaXBtYXAgZ2VuZXJhdGlvbiB0aWxsIHRoZSBsYXN0IHJlbmRlcmluZyB0byB0aGUgY3ViZW1hcCwgdG8gYXZvaWRcbiAgICAgICAgLy8gbWlwbWFwcyBiZWluZyBnZW5lcmF0ZWQgYWZ0ZXIgZWFjaCBmYWNlLlxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vcGxhdGZvcm0vZ3JhcGhpY3MvdGV4dHVyZS5qcycpLlRleHR1cmV9ICovXG4gICAgICAgIGxldCBsYXN0Q3ViZVRleHR1cmUgPSBudWxsO1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXBhc3MuanMnKS5SZW5kZXJQYXNzfSAqL1xuICAgICAgICBsZXQgbGFzdEN1YmVSZW5kZXJQYXNzID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJQYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlclBhc3MgPSByZW5kZXJQYXNzZXNbaV07XG4gICAgICAgICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJQYXNzLnJlbmRlclRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNUZXh0dXJlID0gcmVuZGVyVGFyZ2V0Py5jb2xvckJ1ZmZlcjtcblxuICAgICAgICAgICAgaWYgKHRoaXNUZXh0dXJlPy5jdWJlbWFwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBwcmV2aW91cyBwYXNzIHVzZWQgdGhlIHNhbWUgY3ViZW1hcCB0ZXh0dXJlLCBpdCBkb2VzIG5vdCBuZWVkIG1pcG1hcHMgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDdWJlVGV4dHVyZSA9PT0gdGhpc1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEN1YmVSZW5kZXJQYXNzLmNvbG9yT3BzLm1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0Q3ViZVRleHR1cmUgPSByZW5kZXJUYXJnZXQuY29sb3JCdWZmZXI7XG4gICAgICAgICAgICAgICAgbGFzdEN1YmVSZW5kZXJQYXNzID0gcmVuZGVyUGFzcztcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJQYXNzLnJlcXVpcmVzQ3ViZW1hcHMpIHtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdWJlbWFwIGlzIHJlcXVpcmVkLCBicmVhayB0aGUgY3ViZW1hcCByZW5kZXJpbmcgY2hhaW5cbiAgICAgICAgICAgICAgICBsYXN0Q3ViZVRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxhc3RDdWJlUmVuZGVyUGFzcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgd2hhdCdzIGxlZnQgaW4gdGhlIG1hcCAtIGxhc3QgcGFzc2VzIHJlbmRlcmluZyB0byBlYWNoIHJlbmRlciB0YXJnZXRcbiAgICAgICAgcmVuZGVyVGFyZ2V0TWFwLmZvckVhY2goKHJlbmRlclBhc3MsIHJlbmRlclRhcmdldCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGZyYW1lYnVmZmVyXG4gICAgICAgICAgICBpZiAocmVuZGVyVGFyZ2V0ID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgbXVsdGlzYW1wbGVkIGJ1ZmZlclxuICAgICAgICAgICAgICAgIHJlbmRlclBhc3MuY29sb3JPcHMuc3RvcmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gcmVzb2x2ZSwgbm8gbWlwbWFwc1xuICAgICAgICAgICAgICAgIHJlbmRlclBhc3MuY29sb3JPcHMucmVzb2x2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlbmRlclBhc3MuY29sb3JPcHMubWlwbWFwcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJUYXJnZXRNYXAuY2xlYXIoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoZGV2aWNlKSB7XG5cbiAgICAgICAgdGhpcy5jb21waWxlKCk7XG5cbiAgICAgICAgY29uc3QgcmVuZGVyUGFzc2VzID0gdGhpcy5yZW5kZXJQYXNzZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyUGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZW5kZXJQYXNzZXNbaV0ucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IEZyYW1lR3JhcGggfTtcbiJdLCJuYW1lcyI6WyJGcmFtZUdyYXBoIiwiY29uc3RydWN0b3IiLCJyZW5kZXJQYXNzZXMiLCJyZW5kZXJUYXJnZXRNYXAiLCJNYXAiLCJhZGRSZW5kZXJQYXNzIiwicmVuZGVyUGFzcyIsInB1c2giLCJyZXNldCIsImxlbmd0aCIsImNvbXBpbGUiLCJpIiwicmVuZGVyVGFyZ2V0IiwidW5kZWZpbmVkIiwicHJldlBhc3MiLCJnZXQiLCJjb2xvck9wcyIsImNsZWFyIiwic3RvcmUiLCJkZXB0aFN0ZW5jaWxPcHMiLCJjbGVhckRlcHRoIiwic3RvcmVEZXB0aCIsImNsZWFyU3RlbmNpbCIsInN0b3JlU3RlbmNpbCIsInNldCIsImxhc3RDdWJlVGV4dHVyZSIsImxhc3RDdWJlUmVuZGVyUGFzcyIsInRoaXNUZXh0dXJlIiwiY29sb3JCdWZmZXIiLCJjdWJlbWFwIiwibWlwbWFwcyIsInJlcXVpcmVzQ3ViZW1hcHMiLCJmb3JFYWNoIiwicmVzb2x2ZSIsInJlbmRlciIsImRldmljZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsVUFBVSxDQUFDO0VBQUFDLFdBQUEsR0FBQTtJQUFBLElBRWJDLENBQUFBLFlBQVksR0FBRyxFQUFFLENBQUE7QUFBQSxJQUFBLElBQUEsQ0FPakJDLGVBQWUsR0FBRyxJQUFJQyxHQUFHLEVBQUUsQ0FBQTtBQUFBLEdBQUE7QUFFM0I7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLGFBQWFBLENBQUNDLFVBQVUsRUFBRTtBQUN0QixJQUFBLElBQUksQ0FBQ0osWUFBWSxDQUFDSyxJQUFJLENBQUNELFVBQVUsQ0FBQyxDQUFBO0FBQ3RDLEdBQUE7QUFFQUUsRUFBQUEsS0FBS0EsR0FBRztBQUNKLElBQUEsSUFBSSxDQUFDTixZQUFZLENBQUNPLE1BQU0sR0FBRyxDQUFDLENBQUE7QUFDaEMsR0FBQTtBQUVBQyxFQUFBQSxPQUFPQSxHQUFHO0FBRU4sSUFBQSxNQUFN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
