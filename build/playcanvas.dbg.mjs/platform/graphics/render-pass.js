import { Debug } from '../../core/debug.js';
import { Tracing } from '../../core/tracing.js';
import { Color } from '../../core/math/color.js';
import { TRACEID_RENDER_PASS, TRACEID_RENDER_PASS_DETAIL } from '../../core/constants.js';
import { DebugGraphics } from './debug-graphics.js';

class ColorAttachmentOps {
  constructor() {
    /**
     * A color used to clear the color attachment when the clear is enabled.
     */
    this.clearValue = new Color(0, 0, 0, 1);
    /**
     * True if the attachment should be cleared before rendering, false to preserve
     * the existing content.
     */
    this.clear = false;
    /**
     * True if the attachment needs to be stored after the render pass. False
     * if it can be discarded.
     * Note: This relates to the surface that is getting rendered to, and can be either
     * single or multi-sampled. Further, if a multi-sampled surface is used, the resolve
     * flag further specifies if this gets resolved to a single-sampled surface. This
     * behavior matches the WebGPU specification.
     *
     * @type {boolean}
     */
    this.store = false;
    /**
     * True if the attachment needs to be resolved.
     *
     * @type {boolean}
     */
    this.resolve = true;
    /**
     * True if the attachment needs to have mipmaps generated.
     *
     * @type {boolean}
     */
    this.mipmaps = false;
  }
}
class DepthStencilAttachmentOps {
  constructor() {
    /**
     * A depth value used to clear the depth attachment when the clear is enabled.
     */
    this.clearDepthValue = 1;
    /**
     * A stencil value used to clear the stencil attachment when the clear is enabled.
     */
    this.clearStencilValue = 0;
    /**
     * True if the depth attachment should be cleared before rendering, false to preserve
     * the existing content.
     */
    this.clearDepth = false;
    /**
     * True if the stencil attachment should be cleared before rendering, false to preserve
     * the existing content.
     */
    this.clearStencil = false;
    /**
     * True if the depth attachment needs to be stored after the render pass. False
     * if it can be discarded.
     *
     * @type {boolean}
     */
    this.storeDepth = false;
    /**
     * True if the stencil attachment needs to be stored after the render pass. False
     * if it can be discarded.
     *
     * @type {boolean}
     */
    this.storeStencil = false;
  }
}

/**
 * A render pass represents a node in the frame graph, and encapsulates a system which
 * renders to a render target using an execution callback.
 *
 * @ignore
 */
class RenderPass {
  /**
   * Color attachment operations for the first color attachment.
   *
   * @type {ColorAttachmentOps}
   */
  get colorOps() {
    return this.colorArrayOps[0];
  }

  /** @type {DepthStencilAttachmentOps} */

  /**
   * Creates an instance of the RenderPass.
   *
   * @param {import('../graphics/graphics-device.js').GraphicsDevice} graphicsDevice - The
   * graphics device.
   * @param {Function} [execute] - Custom function that is called to render the pass.
   */
  constructor(graphicsDevice, execute) {
    /** @type {string} */
    this.name = void 0;
    /** @type {import('../graphics/render-target.js').RenderTarget} */
    this.renderTarget = void 0;
    /**
     * Number of samples. 0 if no render target, otherwise number of samples from the render target,
     * or the main framebuffer if render target is null.
     *
     * @type {number}
     */
    this.samples = 0;
    /**
     * Array of color attachment operations. The first element corresponds to the color attachment
     * 0, and so on.
     *
     * @type {Array<ColorAttachmentOps>}
     */
    this.colorArrayOps = [];
    this.depthStencilOps = void 0;
    /**
     * If true, this pass might use dynamically rendered cubemaps. Use for a case where rendering to cubemap
     * faces is interleaved with rendering to shadows, to avoid generating cubemap mipmaps. This will likely
     * be retired when render target dependency tracking gets implemented.
     *
     * @type {boolean}
     */
    this.requiresCubemaps = true;
    /**
     * True if the render pass uses the full viewport / scissor for rendering into the render target.
     *
     * @type {boolean}
     */
    this.fullSizeClearRect = true;
    /**
     * Custom function that is called to render the pass.
     *
     * @type {Function}
     */
    this.execute = void 0;
    /**
     * Custom function that is called before the pass has started.
     *
     * @type {Function}
     */
    this.before = void 0;
    /**
     * Custom function that is called after the pass has fnished.
     *
     * @type {Function}
     */
    this.after = void 0;
    this.device = graphicsDevice;

    /** @type {Function} */
    this.execute = execute;
  }

  /**
   * @param {import('../graphics/render-target.js').RenderTarget} renderTarget - The render
   * target to render into (output). This function should be called only for render passes which
   * use render target, or passes which render directly into the default framebuffer, in which
   * case a null or undefined render target is expected.
   */
  init(renderTarget) {
    var _renderTarget$_colorB;
    // null represents the default framebuffer
    this.renderTarget = renderTarget || null;

    // defaults depend on multisampling
    this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);

    // allocate ops only when render target is used
    this.depthStencilOps = new DepthStencilAttachmentOps();
    const numColorOps = renderTarget ? (_renderTarget$_colorB = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB.length : 1;
    for (let i = 0; i < numColorOps; i++) {
      var _this$renderTarget, _this$renderTarget$_c;
      const colorOps = new ColorAttachmentOps();
      this.colorArrayOps[i] = colorOps;

      // if rendering to single-sampled buffer, this buffer needs to be stored
      if (this.samples === 1) {
        colorOps.store = true;
        colorOps.resolve = false;
      }

      // if render target needs mipmaps
      if ((_this$renderTarget = this.renderTarget) != null && (_this$renderTarget$_c = _this$renderTarget._colorBuffers) != null && _this$renderTarget$_c[i].mipmaps) {
        colorOps.mipmaps = true;
      }
    }
  }

  /**
   * Mark render pass as clearing the full color buffer.
   *
   * @param {Color} color - The color to clear to.
   */
  setClearColor(color) {
    // in case of MRT, we clear all color buffers.
    // TODO: expose per color buffer clear parameters on the camera, and copy them here.
    const count = this.colorArrayOps.length;
    for (let i = 0; i < count; i++) {
      const colorOps = this.colorArrayOps[i];
      colorOps.clearValue.copy(color);
      colorOps.clear = true;
    }
  }

  /**
   * Mark render pass as clearing the full depth buffer.
   *
   * @param {number} depthValue - The depth value to clear to.
   */
  setClearDepth(depthValue) {
    this.depthStencilOps.clearDepthValue = depthValue;
    this.depthStencilOps.clearDepth = true;
  }

  /**
   * Mark render pass as clearing the full stencil buffer.
   *
   * @param {number} stencilValue - The stencil value to clear to.
   */
  setClearStencil(stencilValue) {
    this.depthStencilOps.clearStencilValue = stencilValue;
    this.depthStencilOps.clearStencil = true;
  }

  /**
   * Render the render pass
   */
  render() {
    var _this$before, _this$execute, _this$after;
    const device = this.device;
    const realPass = this.renderTarget !== undefined;
    DebugGraphics.pushGpuMarker(device, `Pass:${this.name}`);
    Debug.call(() => {
      this.log(device, device.renderPassIndex);
    });
    (_this$before = this.before) == null ? void 0 : _this$before.call(this);
    if (realPass) {
      device.startPass(this);
    }
    (_this$execute = this.execute) == null ? void 0 : _this$execute.call(this);
    if (realPass) {
      device.endPass(this);
    }
    (_this$after = this.after) == null ? void 0 : _this$after.call(this);
    device.renderPassIndex++;
    DebugGraphics.popGpuMarker(device);
  }
  log(device, index) {
    if (Tracing.get(TRACEID_RENDER_PASS) || Tracing.get(TRACEID_RENDER_PASS_DETAIL)) {
      var _rt$_colorBuffers$len, _rt, _rt$_colorBuffers, _rt2, _rt3, _rt4;
      let rt = this.renderTarget;
      if (rt === null && device.isWebGPU) {
        rt = device.frameBuffer;
      }
      const numColor = (_rt$_colorBuffers$len = (_rt = rt) == null ? void 0 : (_rt$_colorBuffers = _rt._colorBuffers) == null ? void 0 : _rt$_colorBuffers.length) != null ? _rt$_colorBuffers$len : (_rt2 = rt) != null && _rt2.impl.assignedColorTexture ? 1 : 0;
      const hasDepth = (_rt3 = rt) == null ? void 0 : _rt3.depth;
      const hasStencil = (_rt4 = rt) == null ? void 0 : _rt4.stencil;
      const rtInfo = rt === undefined ? '' : ` RT: ${rt ? rt.name : 'NULL'} ` + `${numColor > 0 ? `[Color${numColor > 1 ? ` x ${numColor}` : ''}]` : ''}` + `${hasDepth ? '[Depth]' : ''}` + `${hasStencil ? '[Stencil]' : ''}` + `${this.samples > 0 ? ' samples: ' + this.samples : ''}`;
      Debug.trace(TRACEID_RENDER_PASS, `${index.toString().padEnd(2, ' ')}: ${this.name.padEnd(20, ' ')}` + rtInfo.padEnd(30));
      for (let i = 0; i < numColor; i++) {
        const colorOps = this.colorArrayOps[i];
        Debug.trace(TRACEID_RENDER_PASS_DETAIL, `    color[${i}]: ` + `${colorOps.clear ? 'clear' : 'load'}->` + `${colorOps.store ? 'store' : 'discard'} ` + `${colorOps.resolve ? 'resolve ' : ''}` + `${colorOps.mipmaps ? 'mipmaps ' : ''}`);
      }
      if (this.depthStencilOps) {
        if (hasDepth) {
          Debug.trace(TRACEID_RENDER_PASS_DETAIL, `    depthOps: ` + `${this.depthStencilOps.clearDepth ? 'clear' : 'load'}->` + `${this.depthStencilOps.storeDepth ? 'store' : 'discard'}`);
        }
        if (hasStencil) {
          Debug.trace(TRACEID_RENDER_PASS_DETAIL, `    stencOps: ` + `${this.depthStencilOps.clearStencil ? 'clear' : 'load'}->` + `${this.depthStencilOps.storeStencil ? 'store' : 'discard'}`);
        }
      }
    }
  }
}

export { ColorAttachmentOps, DepthStencilAttachmentOps, RenderPass };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLXBhc3MuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wbGF0Zm9ybS9ncmFwaGljcy9yZW5kZXItcGFzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZyB9IGZyb20gJy4uLy4uL2NvcmUvZGVidWcuanMnO1xuaW1wb3J0IHsgVHJhY2luZyB9IGZyb20gJy4uLy4uL2NvcmUvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL2NvcmUvbWF0aC9jb2xvci5qcyc7XG5pbXBvcnQgeyBUUkFDRUlEX1JFTkRFUl9QQVNTLCBUUkFDRUlEX1JFTkRFUl9QQVNTX0RFVEFJTCB9IGZyb20gJy4uLy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IERlYnVnR3JhcGhpY3MgfSBmcm9tICcuLi9ncmFwaGljcy9kZWJ1Zy1ncmFwaGljcy5qcyc7XG5cbmNsYXNzIENvbG9yQXR0YWNobWVudE9wcyB7XG4gICAgLyoqXG4gICAgICogQSBjb2xvciB1c2VkIHRvIGNsZWFyIHRoZSBjb2xvciBhdHRhY2htZW50IHdoZW4gdGhlIGNsZWFyIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgY2xlYXJWYWx1ZSA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGF0dGFjaG1lbnQgc2hvdWxkIGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZywgZmFsc2UgdG8gcHJlc2VydmVcbiAgICAgKiB0aGUgZXhpc3RpbmcgY29udGVudC5cbiAgICAgKi9cbiAgICBjbGVhciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgYXR0YWNobWVudCBuZWVkcyB0byBiZSBzdG9yZWQgYWZ0ZXIgdGhlIHJlbmRlciBwYXNzLiBGYWxzZVxuICAgICAqIGlmIGl0IGNhbiBiZSBkaXNjYXJkZWQuXG4gICAgICogTm90ZTogVGhpcyByZWxhdGVzIHRvIHRoZSBzdXJmYWNlIHRoYXQgaXMgZ2V0dGluZyByZW5kZXJlZCB0bywgYW5kIGNhbiBiZSBlaXRoZXJcbiAgICAgKiBzaW5nbGUgb3IgbXVsdGktc2FtcGxlZC4gRnVydGhlciwgaWYgYSBtdWx0aS1zYW1wbGVkIHN1cmZhY2UgaXMgdXNlZCwgdGhlIHJlc29sdmVcbiAgICAgKiBmbGFnIGZ1cnRoZXIgc3BlY2lmaWVzIGlmIHRoaXMgZ2V0cyByZXNvbHZlZCB0byBhIHNpbmdsZS1zYW1wbGVkIHN1cmZhY2UuIFRoaXNcbiAgICAgKiBiZWhhdmlvciBtYXRjaGVzIHRoZSBXZWJHUFUgc3BlY2lmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0b3JlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBhdHRhY2htZW50IG5lZWRzIHRvIGJlIHJlc29sdmVkLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgcmVzb2x2ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBhdHRhY2htZW50IG5lZWRzIHRvIGhhdmUgbWlwbWFwcyBnZW5lcmF0ZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBtaXBtYXBzID0gZmFsc2U7XG59XG5cbmNsYXNzIERlcHRoU3RlbmNpbEF0dGFjaG1lbnRPcHMge1xuICAgIC8qKlxuICAgICAqIEEgZGVwdGggdmFsdWUgdXNlZCB0byBjbGVhciB0aGUgZGVwdGggYXR0YWNobWVudCB3aGVuIHRoZSBjbGVhciBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGNsZWFyRGVwdGhWYWx1ZSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBBIHN0ZW5jaWwgdmFsdWUgdXNlZCB0byBjbGVhciB0aGUgc3RlbmNpbCBhdHRhY2htZW50IHdoZW4gdGhlIGNsZWFyIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgY2xlYXJTdGVuY2lsVmFsdWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgZGVwdGggYXR0YWNobWVudCBzaG91bGQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nLCBmYWxzZSB0byBwcmVzZXJ2ZVxuICAgICAqIHRoZSBleGlzdGluZyBjb250ZW50LlxuICAgICAqL1xuICAgIGNsZWFyRGVwdGggPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHN0ZW5jaWwgYXR0YWNobWVudCBzaG91bGQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nLCBmYWxzZSB0byBwcmVzZXJ2ZVxuICAgICAqIHRoZSBleGlzdGluZyBjb250ZW50LlxuICAgICAqL1xuICAgIGNsZWFyU3RlbmNpbCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgZGVwdGggYXR0YWNobWVudCBuZWVkcyB0byBiZSBzdG9yZWQgYWZ0ZXIgdGhlIHJlbmRlciBwYXNzLiBGYWxzZVxuICAgICAqIGlmIGl0IGNhbiBiZSBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdG9yZURlcHRoID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBzdGVuY2lsIGF0dGFjaG1lbnQgbmVlZHMgdG8gYmUgc3RvcmVkIGFmdGVyIHRoZSByZW5kZXIgcGFzcy4gRmFsc2VcbiAgICAgKiBpZiBpdCBjYW4gYmUgZGlzY2FyZGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RvcmVTdGVuY2lsID0gZmFsc2U7XG59XG5cbi8qKlxuICogQSByZW5kZXIgcGFzcyByZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgZnJhbWUgZ3JhcGgsIGFuZCBlbmNhcHN1bGF0ZXMgYSBzeXN0ZW0gd2hpY2hcbiAqIHJlbmRlcnMgdG8gYSByZW5kZXIgdGFyZ2V0IHVzaW5nIGFuIGV4ZWN1dGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIFJlbmRlclBhc3Mge1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIG5hbWU7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vZ3JhcGhpY3MvcmVuZGVyLXRhcmdldC5qcycpLlJlbmRlclRhcmdldH0gKi9cbiAgICByZW5kZXJUYXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2Ygc2FtcGxlcy4gMCBpZiBubyByZW5kZXIgdGFyZ2V0LCBvdGhlcndpc2UgbnVtYmVyIG9mIHNhbXBsZXMgZnJvbSB0aGUgcmVuZGVyIHRhcmdldCxcbiAgICAgKiBvciB0aGUgbWFpbiBmcmFtZWJ1ZmZlciBpZiByZW5kZXIgdGFyZ2V0IGlzIG51bGwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNhbXBsZXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgY29sb3IgYXR0YWNobWVudCBvcGVyYXRpb25zLiBUaGUgZmlyc3QgZWxlbWVudCBjb3JyZXNwb25kcyB0byB0aGUgY29sb3IgYXR0YWNobWVudFxuICAgICAqIDAsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxDb2xvckF0dGFjaG1lbnRPcHM+fVxuICAgICAqL1xuICAgIGNvbG9yQXJyYXlPcHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENvbG9yIGF0dGFjaG1lbnQgb3BlcmF0aW9ucyBmb3IgdGhlIGZpcnN0IGNvbG9yIGF0dGFjaG1lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Q29sb3JBdHRhY2htZW50T3BzfVxuICAgICAqL1xuICAgIGdldCBjb2xvck9wcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JBcnJheU9wc1swXTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlcHRoU3RlbmNpbEF0dGFjaG1lbnRPcHN9ICovXG4gICAgZGVwdGhTdGVuY2lsT3BzO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyBwYXNzIG1pZ2h0IHVzZSBkeW5hbWljYWxseSByZW5kZXJlZCBjdWJlbWFwcy4gVXNlIGZvciBhIGNhc2Ugd2hlcmUgcmVuZGVyaW5nIHRvIGN1YmVtYXBcbiAgICAgKiBmYWNlcyBpcyBpbnRlcmxlYXZlZCB3aXRoIHJlbmRlcmluZyB0byBzaGFkb3dzLCB0byBhdm9pZCBnZW5lcmF0aW5nIGN1YmVtYXAgbWlwbWFwcy4gVGhpcyB3aWxsIGxpa2VseVxuICAgICAqIGJlIHJldGlyZWQgd2hlbiByZW5kZXIgdGFyZ2V0IGRlcGVuZGVuY3kgdHJhY2tpbmcgZ2V0cyBpbXBsZW1lbnRlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHJlcXVpcmVzQ3ViZW1hcHMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgcmVuZGVyIHBhc3MgdXNlcyB0aGUgZnVsbCB2aWV3cG9ydCAvIHNjaXNzb3IgZm9yIHJlbmRlcmluZyBpbnRvIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVsbFNpemVDbGVhclJlY3QgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIHJlbmRlciB0aGUgcGFzcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBleGVjdXRlO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGJlZm9yZSB0aGUgcGFzcyBoYXMgc3RhcnRlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBiZWZvcmU7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBhc3MgaGFzIGZuaXNoZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgYWZ0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBSZW5kZXJQYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uL2dyYXBoaWNzL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSBncmFwaGljc0RldmljZSAtIFRoZVxuICAgICAqIGdyYXBoaWNzIGRldmljZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXhlY3V0ZV0gLSBDdXN0b20gZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gcmVuZGVyIHRoZSBwYXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdyYXBoaWNzRGV2aWNlLCBleGVjdXRlKSB7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gZ3JhcGhpY3NEZXZpY2U7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbiAgICAgICAgdGhpcy5leGVjdXRlID0gZXhlY3V0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vZ3JhcGhpY3MvcmVuZGVyLXRhcmdldC5qcycpLlJlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0IC0gVGhlIHJlbmRlclxuICAgICAqIHRhcmdldCB0byByZW5kZXIgaW50byAob3V0cHV0KS4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgZm9yIHJlbmRlciBwYXNzZXMgd2hpY2hcbiAgICAgKiB1c2UgcmVuZGVyIHRhcmdldCwgb3IgcGFzc2VzIHdoaWNoIHJlbmRlciBkaXJlY3RseSBpbnRvIHRoZSBkZWZhdWx0IGZyYW1lYnVmZmVyLCBpbiB3aGljaFxuICAgICAqIGNhc2UgYSBudWxsIG9yIHVuZGVmaW5lZCByZW5kZXIgdGFyZ2V0IGlzIGV4cGVjdGVkLlxuICAgICAqL1xuICAgIGluaXQocmVuZGVyVGFyZ2V0KSB7XG5cbiAgICAgICAgLy8gbnVsbCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IGZyYW1lYnVmZmVyXG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IHx8IG51bGw7XG5cbiAgICAgICAgLy8gZGVmYXVsdHMgZGVwZW5kIG9uIG11bHRpc2FtcGxpbmdcbiAgICAgICAgdGhpcy5zYW1wbGVzID0gTWF0aC5tYXgodGhpcy5yZW5kZXJUYXJnZXQgPyB0aGlzLnJlbmRlclRhcmdldC5zYW1wbGVzIDogdGhpcy5kZXZpY2Uuc2FtcGxlcywgMSk7XG5cbiAgICAgICAgLy8gYWxsb2NhdGUgb3BzIG9ubHkgd2hlbiByZW5kZXIgdGFyZ2V0IGlzIHVzZWRcbiAgICAgICAgdGhpcy5kZXB0aFN0ZW5jaWxPcHMgPSBuZXcgRGVwdGhTdGVuY2lsQXR0YWNobWVudE9wcygpO1xuXG4gICAgICAgIGNvbnN0IG51bUNvbG9yT3BzID0gcmVuZGVyVGFyZ2V0ID8gcmVuZGVyVGFyZ2V0Ll9jb2xvckJ1ZmZlcnM/Lmxlbmd0aCA6IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29sb3JPcHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29sb3JPcHMgPSBuZXcgQ29sb3JBdHRhY2htZW50T3BzKCk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQXJyYXlPcHNbaV0gPSBjb2xvck9wcztcblxuICAgICAgICAgICAgLy8gaWYgcmVuZGVyaW5nIHRvIHNpbmdsZS1zYW1wbGVkIGJ1ZmZlciwgdGhpcyBidWZmZXIgbmVlZHMgdG8gYmUgc3RvcmVkXG4gICAgICAgICAgICBpZiAodGhpcy5zYW1wbGVzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29sb3JPcHMuc3RvcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbG9yT3BzLnJlc29sdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgcmVuZGVyIHRhcmdldCBuZWVkcyBtaXBtYXBzXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQ/Ll9jb2xvckJ1ZmZlcnM/LltpXS5taXBtYXBzKSB7XG4gICAgICAgICAgICAgICAgY29sb3JPcHMubWlwbWFwcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXJrIHJlbmRlciBwYXNzIGFzIGNsZWFyaW5nIHRoZSBmdWxsIGNvbG9yIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIC0gVGhlIGNvbG9yIHRvIGNsZWFyIHRvLlxuICAgICAqL1xuICAgIHNldENsZWFyQ29sb3IoY29sb3IpIHtcblxuICAgICAgICAvLyBpbiBjYXNlIG9mIE1SVCwgd2UgY2xlYXIgYWxsIGNvbG9yIGJ1ZmZlcnMuXG4gICAgICAgIC8vIFRPRE86IGV4cG9zZSBwZXIgY29sb3IgYnVmZmVyIGNsZWFyIHBhcmFtZXRlcnMgb24gdGhlIGNhbWVyYSwgYW5kIGNvcHkgdGhlbSBoZXJlLlxuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY29sb3JBcnJheU9wcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29sb3JPcHMgPSB0aGlzLmNvbG9yQXJyYXlPcHNbaV07XG4gICAgICAgICAgICBjb2xvck9wcy5jbGVhclZhbHVlLmNvcHkoY29sb3IpO1xuICAgICAgICAgICAgY29sb3JPcHMuY2xlYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFyayByZW5kZXIgcGFzcyBhcyBjbGVhcmluZyB0aGUgZnVsbCBkZXB0aCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGhWYWx1ZSAtIFRoZSBkZXB0aCB2YWx1ZSB0byBjbGVhciB0by5cbiAgICAgKi9cbiAgICBzZXRDbGVhckRlcHRoKGRlcHRoVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXB0aFN0ZW5jaWxPcHMuY2xlYXJEZXB0aFZhbHVlID0gZGVwdGhWYWx1ZTtcbiAgICAgICAgdGhpcy5kZXB0aFN0ZW5jaWxPcHMuY2xlYXJEZXB0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFyayByZW5kZXIgcGFzcyBhcyBjbGVhcmluZyB0aGUgZnVsbCBzdGVuY2lsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVuY2lsVmFsdWUgLSBUaGUgc3RlbmNpbCB2YWx1ZSB0byBjbGVhciB0by5cbiAgICAgKi9cbiAgICBzZXRDbGVhclN0ZW5jaWwoc3RlbmNpbFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwdGhTdGVuY2lsT3BzLmNsZWFyU3RlbmNpbFZhbHVlID0gc3RlbmNpbFZhbHVlO1xuICAgICAgICB0aGlzLmRlcHRoU3RlbmNpbE9wcy5jbGVhclN0ZW5jaWwgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgcmVuZGVyIHBhc3NcbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5kZXZpY2U7XG4gICAgICAgIGNvbnN0IHJlYWxQYXNzID0gdGhpcy5yZW5kZXJUYXJnZXQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgRGVidWdHcmFwaGljcy5wdXNoR3B1TWFya2VyKGRldmljZSwgYFBhc3M6JHt0aGlzLm5hbWV9YCk7XG5cbiAgICAgICAgRGVidWcuY2FsbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZyhkZXZpY2UsIGRldmljZS5yZW5kZXJQYXNzSW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmJlZm9yZT8uKCk7XG5cbiAgICAgICAgaWYgKHJlYWxQYXNzKSB7XG4gICAgICAgICAgICBkZXZpY2Uuc3RhcnRQYXNzKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5leGVjdXRlPy4oKTtcblxuICAgICAgICBpZiAocmVhbFBhc3MpIHtcbiAgICAgICAgICAgIGRldmljZS5lbmRQYXNzKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZnRlcj8uKCk7XG5cbiAgICAgICAgZGV2aWNlLnJlbmRlclBhc3NJbmRleCsrO1xuXG4gICAgICAgIERlYnVnR3JhcGhpY3MucG9wR3B1TWFya2VyKGRldmljZSk7XG5cbiAgICB9XG5cbiAgICAvLyAjaWYgX0RFQlVHXG4gICAgbG9nKGRldmljZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKFRyYWNpbmcuZ2V0KFRSQUNFSURfUkVOREVSX1BBU1MpIHx8IFRyYWNpbmcuZ2V0KFRSQUNFSURfUkVOREVSX1BBU1NfREVUQUlMKSkge1xuXG4gICAgICAgICAgICBsZXQgcnQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICAgICAgICAgIGlmIChydCA9PT0gbnVsbCAmJiBkZXZpY2UuaXNXZWJHUFUpIHtcbiAgICAgICAgICAgICAgICBydCA9IGRldmljZS5mcmFtZUJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG51bUNvbG9yID0gcnQ/Ll9jb2xvckJ1ZmZlcnM/Lmxlbmd0aCA/PyAocnQ/LmltcGwuYXNzaWduZWRDb2xvclRleHR1cmUgPyAxIDogMCk7XG4gICAgICAgICAgICBjb25zdCBoYXNEZXB0aCA9IHJ0Py5kZXB0aDtcbiAgICAgICAgICAgIGNvbnN0IGhhc1N0ZW5jaWwgPSBydD8uc3RlbmNpbDtcbiAgICAgICAgICAgIGNvbnN0IHJ0SW5mbyA9IHJ0ID09PSB1bmRlZmluZWQgPyAnJyA6IGAgUlQ6ICR7KHJ0ID8gcnQubmFtZSA6ICdOVUxMJyl9IGAgK1xuICAgICAgICAgICAgICAgIGAke251bUNvbG9yID4gMCA/IGBbQ29sb3Ike251bUNvbG9yID4gMSA/IGAgeCAke251bUNvbG9yfWAgOiAnJ31dYCA6ICcnfWAgK1xuICAgICAgICAgICAgICAgIGAke2hhc0RlcHRoID8gJ1tEZXB0aF0nIDogJyd9YCArXG4gICAgICAgICAgICAgICAgYCR7aGFzU3RlbmNpbCA/ICdbU3RlbmNpbF0nIDogJyd9YCArXG4gICAgICAgICAgICAgICAgYCR7KHRoaXMuc2FtcGxlcyA+IDAgPyAnIHNhbXBsZXM6ICcgKyB0aGlzLnNhbXBsZXMgOiAnJyl9YDtcblxuICAgICAgICAgICAgRGVidWcudHJhY2UoVFJBQ0VJRF9SRU5ERVJfUEFTUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2luZGV4LnRvU3RyaW5nKCkucGFkRW5kKDIsICcgJyl9OiAke3RoaXMubmFtZS5wYWRFbmQoMjAsICcgJyl9YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBydEluZm8ucGFkRW5kKDMwKSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29sb3I7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yT3BzID0gdGhpcy5jb2xvckFycmF5T3BzW2ldO1xuICAgICAgICAgICAgICAgIERlYnVnLnRyYWNlKFRSQUNFSURfUkVOREVSX1BBU1NfREVUQUlMLCBgICAgIGNvbG9yWyR7aX1dOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtjb2xvck9wcy5jbGVhciA/ICdjbGVhcicgOiAnbG9hZCd9LT5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtjb2xvck9wcy5zdG9yZSA/ICdzdG9yZScgOiAnZGlzY2FyZCd9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2NvbG9yT3BzLnJlc29sdmUgPyAncmVzb2x2ZSAnIDogJyd9YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7Y29sb3JPcHMubWlwbWFwcyA/ICdtaXBtYXBzICcgOiAnJ31gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGhTdGVuY2lsT3BzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgRGVidWcudHJhY2UoVFJBQ0VJRF9SRU5ERVJfUEFTU19ERVRBSUwsIGAgICAgZGVwdGhPcHM6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLmRlcHRoU3RlbmNpbE9wcy5jbGVhckRlcHRoID8gJ2NsZWFyJyA6ICdsb2FkJ30tPmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLmRlcHRoU3RlbmNpbE9wcy5zdG9yZURlcHRoID8gJ3N0b3JlJyA6ICdkaXNjYXJkJ31gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzU3RlbmNpbCkge1xuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy50cmFjZShUUkFDRUlEX1JFTkRFUl9QQVNTX0RFVEFJTCwgYCAgICBzdGVuY09wczogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMuZGVwdGhTdGVuY2lsT3BzLmNsZWFyU3RlbmNpbCA/ICdjbGVhcicgOiAnbG9hZCd9LT5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5kZXB0aFN0ZW5jaWxPcHMuc3RvcmVTdGVuY2lsID8gJ3N0b3JlJyA6ICdkaXNjYXJkJ31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI2VuZGlmXG59XG5cbmV4cG9ydCB7IFJlbmRlclBhc3MsIENvbG9yQXR0YWNobWVudE9wcywgRGVwdGhTdGVuY2lsQXR0YWNobWVudE9wcyB9O1xuIl0sIm5hbWVzIjpbIkNvbG9yQXR0YWNobWVudE9wcyIsImNvbnN0cnVjdG9yIiwiY2xlYXJWYWx1ZSIsIkNvbG9yIiwiY2xlYXIiLCJzdG9yZSIsInJlc29sdmUiLCJtaXBtYXBzIiwiRGVwdGhTdGVuY2lsQXR0YWNobWVudE9wcyIsImNsZWFyRGVwdGhWYWx1ZSIsImNsZWFyU3RlbmNpbFZhbHVlIiwiY2xlYXJEZXB0aCIsImNsZWFyU3RlbmNpbCIsInN0b3JlRGVwdGgiLCJzdG9yZVN0ZW5jaWwiLCJSZW5kZXJQYXNzIiwiY29sb3JPcHMiLCJjb2xvckFycmF5T3BzIiwiZ3JhcGhpY3NEZXZpY2UiLCJleGVjdXRlIiwibmFtZSIsInJlbmRlclRhcmdldCIsInNhbXBsZXMiLCJkZXB0aFN0ZW5jaWxPcHMiLCJyZXF1aXJlc0N1YmVtYXBzIiwiZnVsbFNpemVDbGVhclJlY3QiLCJiZWZvcmUiLCJhZnRlciIsImRldmljZSIsImluaXQiLCJfcmVuZGVyVGFyZ2V0JF9jb2xvckIiLCJNYXRoIiwibWF4IiwibnVtQ29sb3JPcHMiLCJfY29sb3JCdWZmZXJzIiwibGVuZ3RoIiwiaSIsIl90aGlzJHJlbmRlclRhcmdldCIsIl90aGlzJHJlbmRlclRhcmdldCRfYyIsInNldENsZWFyQ29sb3IiLCJjb2xvciIsImNvdW50IiwiY29weSIsInNldENsZWFyRGVwdGgiLCJkZXB0aFZhbHVlIiwic2V0Q2xlYXJTdGVuY2lsIiwic3RlbmNpbFZhbHVlIiwicmVuZGVyIiwiX3RoaXMkYmVmb3JlIiwiX3RoaXMkZXhlY3V0ZSIsIl90aGlzJGFmdGVyIiwicmVhbFBhc3MiLCJ1bmRlZmluZWQiLCJEZWJ1Z0dyYXBoaWNzIiwicHVzaEdwdU1hcmtlciIsIkRlYnVnIiwiY2FsbCIsImxvZyIsInJlbmRlclBhc3NJbmRleCIsInN0YXJ0UGFzcyIsImVuZFBhc3MiLCJwb3BHcHVNYXJrZXIiLCJpbmRleCIsIlRyYWNpbmciLCJnZXQiLCJUUkFDRUlEX1JFTkRFUl9QQVNTIiwiVFJBQ0VJRF9SRU5ERVJfUEFTU19ERVRBSUwiLCJfcnQkX2NvbG9yQnVmZmVycyRsZW4iLCJfcnQiLCJfcnQkX2NvbG9yQnVmZmVycyIsIl9ydDIiLCJfcnQzIiwiX3J0NCIsInJ0IiwiaXNXZWJHUFUiLCJmcmFtZUJ1ZmZlciIsIm51bUNvbG9yIiwiaW1wbCIsImFzc2lnbmVkQ29sb3JUZXh0dXJlIiwiaGFzRGVwdGgiLCJkZXB0aCIsImhhc1N0ZW5jaWwiLCJzdGVuY2lsIiwicnRJbmZvIiwidHJhY2UiLCJ0b1N0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
