/**
 * @license
 * PlayCanvas Engine v1.63.0-dev revision 9f3635a4e (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { Debug } from '../../core/debug.js';
import { TRACEID_RENDER_TARGET_ALLOC } from '../../core/constants.js';
import { PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL } from './constants.js';
import { DebugGraphics } from './debug-graphics.js';
import { GraphicsDevice } from './graphics-device.js';

const defaultOptions = {
  depth: true,
  face: 0
};
let id = 0;

/**
 * A render target is a rectangular rendering surface.
 */
class RenderTarget {
  /**
   * Creates a new RenderTarget instance. A color buffer or a depth buffer must be set.
   *
   * @param {object} options - Object for passing optional arguments.
   * @param {boolean} [options.autoResolve] - If samples > 1, enables or disables automatic MSAA
   * resolve after rendering to this RT (see {@link RenderTarget#resolve}). Defaults to true.
   * @param {import('./texture.js').Texture} [options.colorBuffer] - The texture that this render
   * target will treat as a rendering surface.
   * @param {boolean} [options.depth] - If set to true, depth buffer will be created. Defaults to
   * true. Ignored if depthBuffer is defined.
   * @param {import('./texture.js').Texture} [options.depthBuffer] - The texture that this render
   * target will treat as a depth/stencil surface (WebGL2 only). If set, the 'depth' and
   * 'stencil' properties are ignored. Texture must have {@link PIXELFORMAT_DEPTH} or
   * {@link PIXELFORMAT_DEPTHSTENCIL} format.
   * @param {number} [options.face] - If the colorBuffer parameter is a cubemap, use this option
   * to specify the face of the cubemap to render to. Can be:
   *
   * - {@link CUBEFACE_POSX}
   * - {@link CUBEFACE_NEGX}
   * - {@link CUBEFACE_POSY}
   * - {@link CUBEFACE_NEGY}
   * - {@link CUBEFACE_POSZ}
   * - {@link CUBEFACE_NEGZ}
   *
   * Defaults to {@link CUBEFACE_POSX}.
   * @param {boolean} [options.flipY] - When set to true the image will be flipped in Y. Default
   * is false.
   * @param {string} [options.name] - The name of the render target.
   * @param {number} [options.samples] - Number of hardware anti-aliasing samples (WebGL2 only).
   * Default is 1.
   * @param {boolean} [options.stencil] - If set to true, depth buffer will include stencil.
   * Defaults to false. Ignored if depthBuffer is defined or depth is false.
   * @example
   * // Create a 512x512x24-bit render target with a depth buffer
   * var colorBuffer = new pc.Texture(graphicsDevice, {
   *     width: 512,
   *     height: 512,
   *     format: pc.PIXELFORMAT_RGB8
   * });
   * var renderTarget = new pc.RenderTarget({
   *     colorBuffer: colorBuffer,
   *     depth: true
   * });
   *
   * // Set the render target on a camera component
   * camera.renderTarget = renderTarget;
   *
   * // Destroy render target at a later stage. Note that the color buffer needs
   * // to be destroyed separately.
   * renderTarget.colorBuffer.destroy();
   * renderTarget.destroy();
   * camera.renderTarget = null;
   */
  constructor(options) {
    var _this$_colorBuffer, _this$_depthBuffer;
    this.id = id++;
    const _arg2 = arguments[1];
    const _arg3 = arguments[2];
    if (options instanceof GraphicsDevice) {
      // old constructor
      this._colorBuffer = _arg2;
      options = _arg3;
      Debug.deprecated('pc.RenderTarget constructor no longer accepts GraphicsDevice parameter.');
    } else {
      // new constructor
      this._colorBuffer = options.colorBuffer;
    }

    // mark color buffer texture as render target
    if (this._colorBuffer) {
      this._colorBuffer._isRenderTarget = true;
    }

    // Process optional arguments
    options = options !== undefined ? options : defaultOptions;
    this._depthBuffer = options.depthBuffer;
    this._face = options.face !== undefined ? options.face : 0;
    if (this._depthBuffer) {
      const format = this._depthBuffer._format;
      if (format === PIXELFORMAT_DEPTH) {
        this._depth = true;
        this._stencil = false;
      } else if (format === PIXELFORMAT_DEPTHSTENCIL) {
        this._depth = true;
        this._stencil = true;
      } else {
        Debug.warn('Incorrect depthBuffer format. Must be pc.PIXELFORMAT_DEPTH or pc.PIXELFORMAT_DEPTHSTENCIL');
        this._depth = false;
        this._stencil = false;
      }
    } else {
      this._depth = options.depth !== undefined ? options.depth : true;
      this._stencil = options.stencil !== undefined ? options.stencil : false;
    }

    // device, from one of the buffers
    const device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device) || options.graphicsDevice;
    Debug.assert(device, "Failed to obtain the device, colorBuffer nor depthBuffer store it.");
    this._device = device;
    this._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;
    this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;

    // use specified name, otherwise get one from color or depth buffer
    this.name = options.name;
    if (!this.name) {
      var _this$_colorBuffer2;
      this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;
    }
    if (!this.name) {
      var _this$_depthBuffer2;
      this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;
    }
    if (!this.name) {
      this.name = "Untitled";
    }

    // render image flipped in Y
    this.flipY = !!options.flipY;

    // device specific implementation
    this.impl = device.createRenderTargetImpl(this);
    Debug.trace(TRACEID_RENDER_TARGET_ALLOC, `Alloc: Id ${this.id} ${this.name}: ${this.width}x${this.height} samples: ${this.samples} ` + `${this.colorBuffer ? '[Color]' : ''}` + `${this.depth ? '[Depth]' : ''}` + `${this.stencil ? '[Stencil]' : ''}` + `[Face:${this.face}]`);
  }

  /**
   * Frees resources associated with this render target.
   */
  destroy() {
    Debug.trace(TRACEID_RENDER_TARGET_ALLOC, `DeAlloc: Id ${this.id} ${this.name}`);
    const device = this._device;
    if (device) {
      const idx = device.targets.indexOf(this);
      if (idx !== -1) {
        device.targets.splice(idx, 1);
      }
      if (device.renderTarget === this) {
        device.setRenderTarget(null);
      }
      this.destroyFrameBuffers();
    }
  }

  /**
   * Free device resources associated with this render target.
   *
   * @ignore
   */
  destroyFrameBuffers() {
    const device = this._device;
    if (device) {
      this.impl.destroy(device);
    }
  }

  /**
   * Free textures associated with this render target.
   *
   * @ignore
   */
  destroyTextureBuffers() {
    if (this._depthBuffer) {
      this._depthBuffer.destroy();
      this._depthBuffer = null;
    }
    if (this._colorBuffer) {
      this._colorBuffer.destroy();
      this._colorBuffer = null;
    }
  }

  /**
   * Initialises the resources associated with this render target.
   *
   * @ignore
   */
  init() {
    this.impl.init(this._device, this);
  }
  get initialized() {
    return this.impl.initialized;
  }

  /**
   * Called when the device context was lost. It releases all context related resources.
   *
   * @ignore
   */
  loseContext() {
    this.impl.loseContext();
  }

  /**
   * If samples > 1, resolves the anti-aliased render target (WebGL2 only). When you're rendering
   * to an anti-aliased render target, pixels aren't written directly to the readable texture.
   * Instead, they're first written to a MSAA buffer, where each sample for each pixel is stored
   * independently. In order to read the results, you first need to 'resolve' the buffer - to
   * average all samples and create a simple texture with one color per pixel. This function
   * performs this averaging and updates the colorBuffer and the depthBuffer. If autoResolve is
   * set to true, the resolve will happen after every rendering to this render target, otherwise
   * you can do it manually, during the app update or inside a {@link Command}.
   *
   * @param {boolean} [color] - Resolve color buffer. Defaults to true.
   * @param {boolean} [depth] - Resolve depth buffer. Defaults to true if the render target has a
   * depth buffer.
   */
  resolve(color = true, depth = !!this._depthBuffer) {
    if (this._device && this._samples > 1) {
      DebugGraphics.pushGpuMarker(this._device, `RESOLVE-RT:${this.name}`);
      this.impl.resolve(this._device, this, color, depth);
      DebugGraphics.popGpuMarker(this._device);
    }
  }

  /**
   * Copies color and/or depth contents of source render target to this one. Formats, sizes and
   * anti-aliasing samples must match. Depth buffer can only be copied on WebGL 2.0.
   *
   * @param {RenderTarget} source - Source render target to copy from.
   * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.
   * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.
   * @returns {boolean} True if the copy was successful, false otherwise.
   */
  copy(source, color, depth) {
    if (!this._device) {
      if (source._device) {
        this._device = source._device;
      } else {
        Debug.error("Render targets are not initialized");
        return false;
      }
    }
    DebugGraphics.pushGpuMarker(this._device, `COPY-RT:${source.name}->${this.name}`);
    const success = this._device.copyRenderTarget(source, this, color, depth);
    DebugGraphics.popGpuMarker(this._device);
    return success;
  }

  /**
   * Number of antialiasing samples the render target uses.
   *
   * @type {number}
   */
  get samples() {
    return this._samples;
  }

  /**
   * True if the render target contains the depth attachment.
   *
   * @type {boolean}
   */
  get depth() {
    return this._depth;
  }

  /**
   * True if the render target contains the stencil attachment.
   *
   * @type {boolean}
   */
  get stencil() {
    return this._stencil;
  }

  /**
   * Color buffer set up on the render target.
   *
   * @type {import('./texture.js').Texture}
   */
  get colorBuffer() {
    return this._colorBuffer;
  }

  /**
   * Depth buffer set up on the render target. Only available, if depthBuffer was set in
   * constructor. Not available if depth property was used instead.
   *
   * @type {import('./texture.js').Texture}
   */
  get depthBuffer() {
    return this._depthBuffer;
  }

  /**
   * If the render target is bound to a cubemap, this property specifies which face of the
   * cubemap is rendered to. Can be:
   *
   * - {@link CUBEFACE_POSX}
   * - {@link CUBEFACE_NEGX}
   * - {@link CUBEFACE_POSY}
   * - {@link CUBEFACE_NEGY}
   * - {@link CUBEFACE_POSZ}
   * - {@link CUBEFACE_NEGZ}
   *
   * @type {number}
   */
  get face() {
    return this._face;
  }

  /**
   * Width of the render target in pixels.
   *
   * @type {number}
   */
  get width() {
    var _this$_colorBuffer3, _this$_depthBuffer3;
    return ((_this$_colorBuffer3 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer3.width) || ((_this$_depthBuffer3 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer3.width) || this._device.width;
  }

  /**
   * Height of the render target in pixels.
   *
   * @type {number}
   */
  get height() {
    var _this$_colorBuffer4, _this$_depthBuffer4;
    return ((_this$_colorBuffer4 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer4.height) || ((_this$_depthBuffer4 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer4.height) || this._device.height;
  }
}

export { RenderTarget };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLXRhcmdldC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3BsYXRmb3JtL2dyYXBoaWNzL3JlbmRlci10YXJnZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IFRSQUNFSURfUkVOREVSX1RBUkdFVF9BTExPQyB9IGZyb20gJy4uLy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IFBJWEVMRk9STUFUX0RFUFRILCBQSVhFTEZPUk1BVF9ERVBUSFNURU5DSUwgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBEZWJ1Z0dyYXBoaWNzIH0gZnJvbSAnLi9kZWJ1Zy1ncmFwaGljcy5qcyc7XG5pbXBvcnQgeyBHcmFwaGljc0RldmljZSB9IGZyb20gJy4vZ3JhcGhpY3MtZGV2aWNlLmpzJztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZGVwdGg6IHRydWUsXG4gICAgZmFjZTogMFxufTtcblxubGV0IGlkID0gMDtcblxuLyoqXG4gKiBBIHJlbmRlciB0YXJnZXQgaXMgYSByZWN0YW5ndWxhciByZW5kZXJpbmcgc3VyZmFjZS5cbiAqL1xuY2xhc3MgUmVuZGVyVGFyZ2V0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFJlbmRlclRhcmdldCBpbnN0YW5jZS4gQSBjb2xvciBidWZmZXIgb3IgYSBkZXB0aCBidWZmZXIgbXVzdCBiZSBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIE9iamVjdCBmb3IgcGFzc2luZyBvcHRpb25hbCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvUmVzb2x2ZV0gLSBJZiBzYW1wbGVzID4gMSwgZW5hYmxlcyBvciBkaXNhYmxlcyBhdXRvbWF0aWMgTVNBQVxuICAgICAqIHJlc29sdmUgYWZ0ZXIgcmVuZGVyaW5nIHRvIHRoaXMgUlQgKHNlZSB7QGxpbmsgUmVuZGVyVGFyZ2V0I3Jlc29sdmV9KS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi90ZXh0dXJlLmpzJykuVGV4dHVyZX0gW29wdGlvbnMuY29sb3JCdWZmZXJdIC0gVGhlIHRleHR1cmUgdGhhdCB0aGlzIHJlbmRlclxuICAgICAqIHRhcmdldCB3aWxsIHRyZWF0IGFzIGEgcmVuZGVyaW5nIHN1cmZhY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZXB0aF0gLSBJZiBzZXQgdG8gdHJ1ZSwgZGVwdGggYnVmZmVyIHdpbGwgYmUgY3JlYXRlZC4gRGVmYXVsdHMgdG9cbiAgICAgKiB0cnVlLiBJZ25vcmVkIGlmIGRlcHRoQnVmZmVyIGlzIGRlZmluZWQuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vdGV4dHVyZS5qcycpLlRleHR1cmV9IFtvcHRpb25zLmRlcHRoQnVmZmVyXSAtIFRoZSB0ZXh0dXJlIHRoYXQgdGhpcyByZW5kZXJcbiAgICAgKiB0YXJnZXQgd2lsbCB0cmVhdCBhcyBhIGRlcHRoL3N0ZW5jaWwgc3VyZmFjZSAoV2ViR0wyIG9ubHkpLiBJZiBzZXQsIHRoZSAnZGVwdGgnIGFuZFxuICAgICAqICdzdGVuY2lsJyBwcm9wZXJ0aWVzIGFyZSBpZ25vcmVkLiBUZXh0dXJlIG11c3QgaGF2ZSB7QGxpbmsgUElYRUxGT1JNQVRfREVQVEh9IG9yXG4gICAgICoge0BsaW5rIFBJWEVMRk9STUFUX0RFUFRIU1RFTkNJTH0gZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mYWNlXSAtIElmIHRoZSBjb2xvckJ1ZmZlciBwYXJhbWV0ZXIgaXMgYSBjdWJlbWFwLCB1c2UgdGhpcyBvcHRpb25cbiAgICAgKiB0byBzcGVjaWZ5IHRoZSBmYWNlIG9mIHRoZSBjdWJlbWFwIHRvIHJlbmRlciB0by4gQ2FuIGJlOlxuICAgICAqXG4gICAgICogLSB7QGxpbmsgQ1VCRUZBQ0VfUE9TWH1cbiAgICAgKiAtIHtAbGluayBDVUJFRkFDRV9ORUdYfVxuICAgICAqIC0ge0BsaW5rIENVQkVGQUNFX1BPU1l9XG4gICAgICogLSB7QGxpbmsgQ1VCRUZBQ0VfTkVHWX1cbiAgICAgKiAtIHtAbGluayBDVUJFRkFDRV9QT1NafVxuICAgICAqIC0ge0BsaW5rIENVQkVGQUNFX05FR1p9XG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byB7QGxpbmsgQ1VCRUZBQ0VfUE9TWH0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mbGlwWV0gLSBXaGVuIHNldCB0byB0cnVlIHRoZSBpbWFnZSB3aWxsIGJlIGZsaXBwZWQgaW4gWS4gRGVmYXVsdFxuICAgICAqIGlzIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXSAtIFRoZSBuYW1lIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzXSAtIE51bWJlciBvZiBoYXJkd2FyZSBhbnRpLWFsaWFzaW5nIHNhbXBsZXMgKFdlYkdMMiBvbmx5KS5cbiAgICAgKiBEZWZhdWx0IGlzIDEuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zdGVuY2lsXSAtIElmIHNldCB0byB0cnVlLCBkZXB0aCBidWZmZXIgd2lsbCBpbmNsdWRlIHN0ZW5jaWwuXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UuIElnbm9yZWQgaWYgZGVwdGhCdWZmZXIgaXMgZGVmaW5lZCBvciBkZXB0aCBpcyBmYWxzZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIDUxMng1MTJ4MjQtYml0IHJlbmRlciB0YXJnZXQgd2l0aCBhIGRlcHRoIGJ1ZmZlclxuICAgICAqIHZhciBjb2xvckJ1ZmZlciA9IG5ldyBwYy5UZXh0dXJlKGdyYXBoaWNzRGV2aWNlLCB7XG4gICAgICogICAgIHdpZHRoOiA1MTIsXG4gICAgICogICAgIGhlaWdodDogNTEyLFxuICAgICAqICAgICBmb3JtYXQ6IHBjLlBJWEVMRk9STUFUX1JHQjhcbiAgICAgKiB9KTtcbiAgICAgKiB2YXIgcmVuZGVyVGFyZ2V0ID0gbmV3IHBjLlJlbmRlclRhcmdldCh7XG4gICAgICogICAgIGNvbG9yQnVmZmVyOiBjb2xvckJ1ZmZlcixcbiAgICAgKiAgICAgZGVwdGg6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFNldCB0aGUgcmVuZGVyIHRhcmdldCBvbiBhIGNhbWVyYSBjb21wb25lbnRcbiAgICAgKiBjYW1lcmEucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgICAqXG4gICAgICogLy8gRGVzdHJveSByZW5kZXIgdGFyZ2V0IGF0IGEgbGF0ZXIgc3RhZ2UuIE5vdGUgdGhhdCB0aGUgY29sb3IgYnVmZmVyIG5lZWRzXG4gICAgICogLy8gdG8gYmUgZGVzdHJveWVkIHNlcGFyYXRlbHkuXG4gICAgICogcmVuZGVyVGFyZ2V0LmNvbG9yQnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgKiByZW5kZXJUYXJnZXQuZGVzdHJveSgpO1xuICAgICAqIGNhbWVyYS5yZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkKys7XG5cbiAgICAgICAgY29uc3QgX2FyZzIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGNvbnN0IF9hcmczID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgR3JhcGhpY3NEZXZpY2UpIHtcbiAgICAgICAgICAgIC8vIG9sZCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgdGhpcy5fY29sb3JCdWZmZXIgPSBfYXJnMjtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnMztcblxuICAgICAgICAgICAgRGVidWcuZGVwcmVjYXRlZCgncGMuUmVuZGVyVGFyZ2V0IGNvbnN0cnVjdG9yIG5vIGxvbmdlciBhY2NlcHRzIEdyYXBoaWNzRGV2aWNlIHBhcmFtZXRlci4nKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IGNvbnN0cnVjdG9yXG4gICAgICAgICAgICB0aGlzLl9jb2xvckJ1ZmZlciA9IG9wdGlvbnMuY29sb3JCdWZmZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXJrIGNvbG9yIGJ1ZmZlciB0ZXh0dXJlIGFzIHJlbmRlciB0YXJnZXRcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvckJ1ZmZlci5faXNSZW5kZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvY2VzcyBvcHRpb25hbCBhcmd1bWVudHNcbiAgICAgICAgb3B0aW9ucyA9IChvcHRpb25zICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucyA6IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB0aGlzLl9kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXI7XG4gICAgICAgIHRoaXMuX2ZhY2UgPSAob3B0aW9ucy5mYWNlICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5mYWNlIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGVwdGhCdWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX2RlcHRoQnVmZmVyLl9mb3JtYXQ7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBQSVhFTEZPUk1BVF9ERVBUSCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGVuY2lsID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gUElYRUxGT1JNQVRfREVQVEhTVEVOQ0lMKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0ZW5jaWwgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBEZWJ1Zy53YXJuKCdJbmNvcnJlY3QgZGVwdGhCdWZmZXIgZm9ybWF0LiBNdXN0IGJlIHBjLlBJWEVMRk9STUFUX0RFUFRIIG9yIHBjLlBJWEVMRk9STUFUX0RFUFRIU1RFTkNJTCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcHRoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RlbmNpbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGVwdGggPSAob3B0aW9ucy5kZXB0aCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuZGVwdGggOiB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3RlbmNpbCA9IChvcHRpb25zLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLnN0ZW5jaWwgOiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldmljZSwgZnJvbSBvbmUgb2YgdGhlIGJ1ZmZlcnNcbiAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5fY29sb3JCdWZmZXI/LmRldmljZSB8fCB0aGlzLl9kZXB0aEJ1ZmZlcj8uZGV2aWNlIHx8IG9wdGlvbnMuZ3JhcGhpY3NEZXZpY2U7XG4gICAgICAgIERlYnVnLmFzc2VydChkZXZpY2UsIFwiRmFpbGVkIHRvIG9idGFpbiB0aGUgZGV2aWNlLCBjb2xvckJ1ZmZlciBub3IgZGVwdGhCdWZmZXIgc3RvcmUgaXQuXCIpO1xuICAgICAgICB0aGlzLl9kZXZpY2UgPSBkZXZpY2U7XG5cbiAgICAgICAgdGhpcy5fc2FtcGxlcyA9IChvcHRpb25zLnNhbXBsZXMgIT09IHVuZGVmaW5lZCkgPyBNYXRoLm1pbihvcHRpb25zLnNhbXBsZXMsIHRoaXMuX2RldmljZS5tYXhTYW1wbGVzKSA6IDE7XG4gICAgICAgIHRoaXMuYXV0b1Jlc29sdmUgPSAob3B0aW9ucy5hdXRvUmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYXV0b1Jlc29sdmUgOiB0cnVlO1xuXG4gICAgICAgIC8vIHVzZSBzcGVjaWZpZWQgbmFtZSwgb3RoZXJ3aXNlIGdldCBvbmUgZnJvbSBjb2xvciBvciBkZXB0aCBidWZmZXJcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgICAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5fY29sb3JCdWZmZXI/Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuX2RlcHRoQnVmZmVyPy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBcIlVudGl0bGVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW5kZXIgaW1hZ2UgZmxpcHBlZCBpbiBZXG4gICAgICAgIHRoaXMuZmxpcFkgPSAhIW9wdGlvbnMuZmxpcFk7XG5cbiAgICAgICAgLy8gZGV2aWNlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHRoaXMuaW1wbCA9IGRldmljZS5jcmVhdGVSZW5kZXJUYXJnZXRJbXBsKHRoaXMpO1xuXG4gICAgICAgIERlYnVnLnRyYWNlKFRSQUNFSURfUkVOREVSX1RBUkdFVF9BTExPQywgYEFsbG9jOiBJZCAke3RoaXMuaWR9ICR7dGhpcy5uYW1lfTogJHt0aGlzLndpZHRofXgke3RoaXMuaGVpZ2h0fSBzYW1wbGVzOiAke3RoaXMuc2FtcGxlc30gYCArXG4gICAgICAgICAgICBgJHt0aGlzLmNvbG9yQnVmZmVyID8gJ1tDb2xvcl0nIDogJyd9YCArXG4gICAgICAgICAgICBgJHt0aGlzLmRlcHRoID8gJ1tEZXB0aF0nIDogJyd9YCArXG4gICAgICAgICAgICBgJHt0aGlzLnN0ZW5jaWwgPyAnW1N0ZW5jaWxdJyA6ICcnfWAgK1xuICAgICAgICAgICAgYFtGYWNlOiR7dGhpcy5mYWNlfV1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcmVlcyByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVuZGVyIHRhcmdldC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuXG4gICAgICAgIERlYnVnLnRyYWNlKFRSQUNFSURfUkVOREVSX1RBUkdFVF9BTExPQywgYERlQWxsb2M6IElkICR7dGhpcy5pZH0gJHt0aGlzLm5hbWV9YCk7XG5cbiAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5fZGV2aWNlO1xuICAgICAgICBpZiAoZGV2aWNlKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBkZXZpY2UudGFyZ2V0cy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2UudGFyZ2V0cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRldmljZS5yZW5kZXJUYXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2Uuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lGcmFtZUJ1ZmZlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZyZWUgZGV2aWNlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyByZW5kZXIgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGRlc3Ryb3lGcmFtZUJ1ZmZlcnMoKSB7XG5cbiAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5fZGV2aWNlO1xuICAgICAgICBpZiAoZGV2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLmltcGwuZGVzdHJveShkZXZpY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnJlZSB0ZXh0dXJlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyByZW5kZXIgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGRlc3Ryb3lUZXh0dXJlQnVmZmVycygpIHtcblxuICAgICAgICBpZiAodGhpcy5fZGVwdGhCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoQnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoQnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb2xvckJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fY29sb3JCdWZmZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JCdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZXMgdGhlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyByZW5kZXIgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuaW1wbC5pbml0KHRoaXMuX2RldmljZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0IGluaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBsLmluaXRpYWxpemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBkZXZpY2UgY29udGV4dCB3YXMgbG9zdC4gSXQgcmVsZWFzZXMgYWxsIGNvbnRleHQgcmVsYXRlZCByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgbG9zZUNvbnRleHQoKSB7XG4gICAgICAgIHRoaXMuaW1wbC5sb3NlQ29udGV4dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHNhbXBsZXMgPiAxLCByZXNvbHZlcyB0aGUgYW50aS1hbGlhc2VkIHJlbmRlciB0YXJnZXQgKFdlYkdMMiBvbmx5KS4gV2hlbiB5b3UncmUgcmVuZGVyaW5nXG4gICAgICogdG8gYW4gYW50aS1hbGlhc2VkIHJlbmRlciB0YXJnZXQsIHBpeGVscyBhcmVuJ3Qgd3JpdHRlbiBkaXJlY3RseSB0byB0aGUgcmVhZGFibGUgdGV4dHVyZS5cbiAgICAgKiBJbnN0ZWFkLCB0aGV5J3JlIGZpcnN0IHdyaXR0ZW4gdG8gYSBNU0FBIGJ1ZmZlciwgd2hlcmUgZWFjaCBzYW1wbGUgZm9yIGVhY2ggcGl4ZWwgaXMgc3RvcmVkXG4gICAgICogaW5kZXBlbmRlbnRseS4gSW4gb3JkZXIgdG8gcmVhZCB0aGUgcmVzdWx0cywgeW91IGZpcnN0IG5lZWQgdG8gJ3Jlc29sdmUnIHRoZSBidWZmZXIgLSB0b1xuICAgICAqIGF2ZXJhZ2UgYWxsIHNhbXBsZXMgYW5kIGNyZWF0ZSBhIHNpbXBsZSB0ZXh0dXJlIHdpdGggb25lIGNvbG9yIHBlciBwaXhlbC4gVGhpcyBmdW5jdGlvblxuICAgICAqIHBlcmZvcm1zIHRoaXMgYXZlcmFnaW5nIGFuZCB1cGRhdGVzIHRoZSBjb2xvckJ1ZmZlciBhbmQgdGhlIGRlcHRoQnVmZmVyLiBJZiBhdXRvUmVzb2x2ZSBpc1xuICAgICAqIHNldCB0byB0cnVlLCB0aGUgcmVzb2x2ZSB3aWxsIGhhcHBlbiBhZnRlciBldmVyeSByZW5kZXJpbmcgdG8gdGhpcyByZW5kZXIgdGFyZ2V0LCBvdGhlcndpc2VcbiAgICAgKiB5b3UgY2FuIGRvIGl0IG1hbnVhbGx5LCBkdXJpbmcgdGhlIGFwcCB1cGRhdGUgb3IgaW5zaWRlIGEge0BsaW5rIENvbW1hbmR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29sb3JdIC0gUmVzb2x2ZSBjb2xvciBidWZmZXIuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVwdGhdIC0gUmVzb2x2ZSBkZXB0aCBidWZmZXIuIERlZmF1bHRzIHRvIHRydWUgaWYgdGhlIHJlbmRlciB0YXJnZXQgaGFzIGFcbiAgICAgKiBkZXB0aCBidWZmZXIuXG4gICAgICovXG4gICAgcmVzb2x2ZShjb2xvciA9IHRydWUsIGRlcHRoID0gISF0aGlzLl9kZXB0aEJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5fZGV2aWNlICYmIHRoaXMuX3NhbXBsZXMgPiAxKSB7XG4gICAgICAgICAgICBEZWJ1Z0dyYXBoaWNzLnB1c2hHcHVNYXJrZXIodGhpcy5fZGV2aWNlLCBgUkVTT0xWRS1SVDoke3RoaXMubmFtZX1gKTtcbiAgICAgICAgICAgIHRoaXMuaW1wbC5yZXNvbHZlKHRoaXMuX2RldmljZSwgdGhpcywgY29sb3IsIGRlcHRoKTtcbiAgICAgICAgICAgIERlYnVnR3JhcGhpY3MucG9wR3B1TWFya2VyKHRoaXMuX2RldmljZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgY29sb3IgYW5kL29yIGRlcHRoIGNvbnRlbnRzIG9mIHNvdXJjZSByZW5kZXIgdGFyZ2V0IHRvIHRoaXMgb25lLiBGb3JtYXRzLCBzaXplcyBhbmRcbiAgICAgKiBhbnRpLWFsaWFzaW5nIHNhbXBsZXMgbXVzdCBtYXRjaC4gRGVwdGggYnVmZmVyIGNhbiBvbmx5IGJlIGNvcGllZCBvbiBXZWJHTCAyLjAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlbmRlclRhcmdldH0gc291cmNlIC0gU291cmNlIHJlbmRlciB0YXJnZXQgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbG9yXSAtIElmIHRydWUgd2lsbCBjb3B5IHRoZSBjb2xvciBidWZmZXIuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlcHRoXSAtIElmIHRydWUgd2lsbCBjb3B5IHRoZSBkZXB0aCBidWZmZXIuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb3B5IHdhcyBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgY29weShzb3VyY2UsIGNvbG9yLCBkZXB0aCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RldmljZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5fZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlID0gc291cmNlLl9kZXZpY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIERlYnVnLmVycm9yKFwiUmVuZGVyIHRhcmdldHMgYXJlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBEZWJ1Z0dyYXBoaWNzLnB1c2hHcHVNYXJrZXIodGhpcy5fZGV2aWNlLCBgQ09QWS1SVDoke3NvdXJjZS5uYW1lfS0+JHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLl9kZXZpY2UuY29weVJlbmRlclRhcmdldChzb3VyY2UsIHRoaXMsIGNvbG9yLCBkZXB0aCk7XG4gICAgICAgIERlYnVnR3JhcGhpY3MucG9wR3B1TWFya2VyKHRoaXMuX2RldmljZSk7XG5cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGFudGlhbGlhc2luZyBzYW1wbGVzIHRoZSByZW5kZXIgdGFyZ2V0IHVzZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzYW1wbGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2FtcGxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSByZW5kZXIgdGFyZ2V0IGNvbnRhaW5zIHRoZSBkZXB0aCBhdHRhY2htZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgcmVuZGVyIHRhcmdldCBjb250YWlucyB0aGUgc3RlbmNpbCBhdHRhY2htZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHN0ZW5jaWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVuY2lsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbG9yIGJ1ZmZlciBzZXQgdXAgb24gdGhlIHJlbmRlciB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuL3RleHR1cmUuanMnKS5UZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCBjb2xvckJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQnVmZmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcHRoIGJ1ZmZlciBzZXQgdXAgb24gdGhlIHJlbmRlciB0YXJnZXQuIE9ubHkgYXZhaWxhYmxlLCBpZiBkZXB0aEJ1ZmZlciB3YXMgc2V0IGluXG4gICAgICogY29uc3RydWN0b3IuIE5vdCBhdmFpbGFibGUgaWYgZGVwdGggcHJvcGVydHkgd2FzIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4vdGV4dHVyZS5qcycpLlRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IGRlcHRoQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGhCdWZmZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlbmRlciB0YXJnZXQgaXMgYm91bmQgdG8gYSBjdWJlbWFwLCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyB3aGljaCBmYWNlIG9mIHRoZVxuICAgICAqIGN1YmVtYXAgaXMgcmVuZGVyZWQgdG8uIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0ge0BsaW5rIENVQkVGQUNFX1BPU1h9XG4gICAgICogLSB7QGxpbmsgQ1VCRUZBQ0VfTkVHWH1cbiAgICAgKiAtIHtAbGluayBDVUJFRkFDRV9QT1NZfVxuICAgICAqIC0ge0BsaW5rIENVQkVGQUNFX05FR1l9XG4gICAgICogLSB7QGxpbmsgQ1VCRUZBQ0VfUE9TWn1cbiAgICAgKiAtIHtAbGluayBDVUJFRkFDRV9ORUdafVxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZmFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIHJlbmRlciB0YXJnZXQgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvckJ1ZmZlcj8ud2lkdGggfHwgdGhpcy5fZGVwdGhCdWZmZXI/LndpZHRoIHx8IHRoaXMuX2RldmljZS53aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWlnaHQgb2YgdGhlIHJlbmRlciB0YXJnZXQgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JCdWZmZXI/LmhlaWdodCB8fCB0aGlzLl9kZXB0aEJ1ZmZlcj8uaGVpZ2h0IHx8IHRoaXMuX2RldmljZS5oZWlnaHQ7XG4gICAgfVxufVxuXG5leHBvcnQgeyBSZW5kZXJUYXJnZXQgfTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0T3B0aW9ucyIsImRlcHRoIiwiZmFjZSIsImlkIiwiUmVuZGVyVGFyZ2V0IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX3RoaXMkX2NvbG9yQnVmZmVyIiwiX3RoaXMkX2RlcHRoQnVmZmVyIiwiX2FyZzIiLCJhcmd1bWVudHMiLCJfYXJnMyIsIkdyYXBoaWNzRGV2aWNlIiwiX2NvbG9yQnVmZmVyIiwiRGVidWciLCJkZXByZWNhdGVkIiwiY29sb3JCdWZmZXIiLCJfaXNSZW5kZXJUYXJnZXQiLCJ1bmRlZmluZWQiLCJfZGVwdGhCdWZmZXIiLCJkZXB0aEJ1ZmZlciIsIl9mYWNlIiwiZm9ybWF0IiwiX2Zvcm1hdCIsIlBJWEVMRk9STUFUX0RFUFRIIiwiX2RlcHRoIiwiX3N0ZW5jaWwiLCJQSVhFTEZPUk1BVF9ERVBUSFNURU5DSUwiLCJ3YXJuIiwic3RlbmNpbCIsImRldmljZSIsImdyYXBoaWNzRGV2aWNlIiwiYXNzZXJ0IiwiX2RldmljZSIsIl9zYW1wbGVzIiwic2FtcGxlcyIsIk1hdGgiLCJtaW4iLCJtYXhTYW1wbGVzIiwiYXV0b1Jlc29sdmUiLCJuYW1lIiwiX3RoaXMkX2NvbG9yQnVmZmVyMiIsIl90aGlzJF9kZXB0aEJ1ZmZlcjIiLCJmbGlwWSIsImltcGwiLCJjcmVhdGVSZW5kZXJUYXJnZXRJbXBsIiwidHJhY2UiLCJUUkFDRUlEX1JFTkRFUl9UQVJHRVRfQUxMT0MiLCJ3aWR0aCIsImhlaWdodCIsImRlc3Ryb3kiLCJpZHgiLCJ0YXJnZXRzIiwiaW5kZXhPZiIsInNwbGljZSIsInJlbmRlclRhcmdldCIsInNldFJlbmRlclRhcmdldCIsImRlc3Ryb3lGcmFtZUJ1ZmZlcnMiLCJkZXN0cm95VGV4dHVyZUJ1ZmZlcnMiLCJpbml0IiwiaW5pdGlhbGl6ZWQiLCJsb3NlQ29udGV4dCIsInJlc29sdmUiLCJjb2xvciIsIkRlYnVnR3JhcGhpY3MiLCJwdXNoR3B1TWFya2VyIiwicG9wR3B1TWFya2VyIiwiY29weSIsInNvdXJjZSIsImVycm9yIiwic3VjY2VzcyIsImNvcHlSZW5kZXJUYXJnZXQiLCJfdGhpcyRfY29sb3JCdWZmZXIzIiwiX3RoaXMkX2RlcHRoQnVmZmVyMyIsIl90aGlzJF9jb2xvckJ1ZmZlcjQiLCJfdGhpcyRfZGVwdGhCdWZmZXI0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQU1BLE1BQU1BLGNBQWMsR0FBRztBQUNuQkMsRUFBQUEsS0FBSyxFQUFFLElBQUk7QUFDWEMsRUFBQUEsSUFBSSxFQUFFLENBQUE7QUFDVixDQUFDLENBQUE7QUFFRCxJQUFJQyxFQUFFLEdBQUcsQ0FBQyxDQUFBOztBQUVWO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLFlBQVksQ0FBQztBQUNmO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsV0FBV0EsQ0FBQ0MsT0FBTyxFQUFFO0lBQUEsSUFBQUMsa0JBQUEsRUFBQUMsa0JBQUEsQ0FBQTtBQUNqQixJQUFBLElBQUksQ0FBQ0wsRUFBRSxHQUFHQSxFQUFFLEVBQUUsQ0FBQTtBQUVkLElBQUEsTUFBTU0sS0FBSyxHQUFHQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDMUIsSUFBQSxNQUFNQyxLQUFLLEdBQUdELFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUUxQixJQUFJSixPQUFPLFlBQVlNLGNBQWMsRUFBRTtBQUNuQztNQUNBLElBQUksQ0FBQ0MsWUFBWSxHQUFHSixLQUFLLENBQUE7QUFDekJILE1BQUFBLE9BQU8sR0FBR0ssS0FBSyxDQUFBO0FBRWZHLE1BQUFBLEtBQUssQ0FBQ0MsVUFBVSxDQUFDLHlFQUF5RSxDQUFDLENBQUE7QUFFL0YsS0FBQyxNQUFNO0FBQ0g7QUFDQSxNQUFBLElBQUksQ0FBQ0YsWUFBWSxHQUFHUCxPQUFPLENBQUNVLFdBQVcsQ0FBQTtBQUMzQyxLQUFBOztBQUVBO0lBQ0EsSUFBSSxJQUFJLENBQUNILFlBQVksRUFBRTtBQUNuQixNQUFBLElBQUksQ0FBQ0EsWUFBWSxDQUFDSSxlQUFlLEdBQUcsSUFBSSxDQUFBO0FBQzVDLEtBQUE7O0FBRUE7QUFDQVgsSUFBQUEsT0FBTyxHQUFJQSxPQUFPLEtBQUtZLFNBQVMsR0FBSVosT0FBTyxHQUFHTixjQUFjLENBQUE7QUFDNUQsSUFBQSxJQUFJLENBQUNtQixZQUFZLEdBQUdiLE9BQU8sQ0FBQ2MsV0FBVyxDQUFBO0FBQ3ZDLElBQUEsSUFBSSxDQUFDQyxLQUFLLEdBQUlmLE9BQU8sQ0FBQ0osSUFBSSxLQUFLZ0IsU0FBUyxHQUFJWixPQUFPLENBQUNKLElBQUksR0FBRyxDQUFDLENBQUE7SUFFNUQsSUFBSSxJQUFJLENBQUNpQixZQUFZLEVBQUU7QUFDbkIsTUFBQSxNQUFNRyxNQUFNLEdBQUcsSUFBSSxDQUFDSCxZQUFZLENBQUNJLE9BQU8sQ0FBQTtNQUN4QyxJQUFJRCxNQUFNLEtBQUtFLGlCQUFpQixFQUFFO1FBQzlCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQTtRQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBRyxLQUFLLENBQUE7QUFDekIsT0FBQyxNQUFNLElBQUlKLE1BQU0sS0FBS0ssd0JBQXdCLEVBQUU7UUFDNUMsSUFBSSxDQUFDRixNQUFNLEdBQUcsSUFBSSxDQUFBO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUksQ0FBQTtBQUN4QixPQUFDLE1BQU07QUFDSFosUUFBQUEsS0FBSyxDQUFDYyxJQUFJLENBQUMsMkZBQTJGLENBQUMsQ0FBQTtRQUN2RyxJQUFJLENBQUNILE1BQU0sR0FBRyxLQUFLLENBQUE7UUFDbkIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsS0FBSyxDQUFBO0FBQ3pCLE9BQUE7QUFDSixLQUFDLE1BQU07QUFDSCxNQUFBLElBQUksQ0FBQ0QsTUFBTSxHQUFJbkIsT0FBTyxDQUFDTCxLQUFLLEtBQUtpQixTQUFTLEdBQUlaLE9BQU8sQ0FBQ0wsS0FBSyxHQUFHLElBQUksQ0FBQTtBQUNsRSxNQUFBLElBQUksQ0FBQ3lCLFFBQVEsR0FBSXBCLE9BQU8sQ0FBQ3VCLE9BQU8sS0FBS1gsU0FBUyxHQUFJWixPQUFPLENBQUN1QixPQUFPLEdBQUcsS0FBSyxDQUFBO0FBQzdFLEtBQUE7O0FBRUE7SUFDQSxNQUFNQyxNQUFNLEdBQUcsQ0FBQSxDQUFBdkIsa0JBQUEsR0FBQSxJQUFJLENBQUNNLFlBQVksS0FBQSxJQUFBLEdBQUEsS0FBQSxDQUFBLEdBQWpCTixrQkFBQSxDQUFtQnVCLE1BQU0sTUFBQSxDQUFBdEIsa0JBQUEsR0FBSSxJQUFJLENBQUNXLFlBQVksS0FBakJYLElBQUFBLEdBQUFBLEtBQUFBLENBQUFBLEdBQUFBLGtCQUFBLENBQW1Cc0IsTUFBTSxDQUFBLElBQUl4QixPQUFPLENBQUN5QixjQUFjLENBQUE7QUFDL0ZqQixJQUFBQSxLQUFLLENBQUNrQixNQUFNLENBQUNGLE1BQU0sRUFBRSxvRUFBb0UsQ0FBQyxDQUFBO0lBQzFGLElBQUksQ0FBQ0csT0FBTyxHQUFHSCxNQUFNLENBQUE7SUFFckIsSUFBSSxDQUFDSSxRQUFRLEdBQUk1QixPQUFPLENBQUM2QixPQUFPLEtBQUtqQixTQUFTLEdBQUlrQixJQUFJLENBQUNDLEdBQUcsQ0FBQy9CLE9BQU8sQ0FBQzZCLE9BQU8sRUFBRSxJQUFJLENBQUNGLE9BQU8sQ0FBQ0ssVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQ3hHLElBQUEsSUFBSSxDQUFDQyxXQUFXLEdBQUlqQyxPQUFPLENBQUNpQyxXQUFXLEtBQUtyQixTQUFTLEdBQUlaLE9BQU8sQ0FBQ2lDLFdBQVcsR0FBRyxJQUFJLENBQUE7O0FBRW5GO0FBQ0EsSUFBQSxJQUFJLENBQUNDLElBQUksR0FBR2xDLE9BQU8sQ0FBQ2tDLElBQUksQ0FBQTtBQUN4QixJQUFBLElBQUksQ0FBQyxJQUFJLENBQUNBLElBQUksRUFBRTtBQUFBLE1BQUEsSUFBQUMsbUJBQUEsQ0FBQTtNQUNaLElBQUksQ0FBQ0QsSUFBSSxHQUFBLENBQUFDLG1CQUFBLEdBQUcsSUFBSSxDQUFDNUIsWUFBWSxLQUFBLElBQUEsR0FBQSxLQUFBLENBQUEsR0FBakI0QixtQkFBQSxDQUFtQkQsSUFBSSxDQUFBO0FBQ3ZDLEtBQUE7QUFDQSxJQUFBLElBQUksQ0FBQyxJQUFJLENBQUNBLElBQUksRUFBRTtBQUFBLE1BQUEsSUFBQUUsbUJBQUEsQ0FBQTtNQUNaLElBQUksQ0FBQ0YsSUFBSSxHQUFBLENBQUFFLG1CQUFBLEdBQUcsSUFBSSxDQUFDdkIsWUFBWSxLQUFBLElBQUEsR0FBQSxLQUFBLENBQUEsR0FBakJ1QixtQkFBQSxDQUFtQkYsSUFBSSxDQUFBO0FBQ3ZDLEtBQUE7QUFDQSxJQUFBLElBQUksQ0FBQyxJQUFJLENBQUNBLElBQUksRUFBRTtNQUNaLElBQUksQ0FBQ0EsSUFBSSxHQUFHLFVBQVUsQ0FBQTtBQUMxQixLQUFBOztBQUVBO0FBQ0EsSUFBQSxJQUFJLENBQUNHLEtBQUssR0FBRyxDQUFDLENBQUNyQyxPQUFPLENBQUNxQyxLQUFLLENBQUE7O0FBRTVCO0lBQ0EsSUFBSSxDQUFDQyxJQUFJLEdBQUdkLE1BQU0sQ0FBQ2Usc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUE7QUFFL0MvQixJQUFBQSxLQUFLLENBQUNnQyxLQUFLLENBQUNDLDJCQUEyQixFQUFHLENBQUEsVUFBQSxFQUFZLElBQUksQ0FBQzVDLEVBQUcsQ0FBQSxDQUFBLEVBQUcsSUFBSSxDQUFDcUMsSUFBSyxDQUFBLEVBQUEsRUFBSSxJQUFJLENBQUNRLEtBQU0sQ0FBQSxDQUFBLEVBQUcsSUFBSSxDQUFDQyxNQUFPLENBQUEsVUFBQSxFQUFZLElBQUksQ0FBQ2QsT0FBUSxDQUFBLENBQUEsQ0FBRSxHQUMvSCxDQUFBLEVBQUUsSUFBSSxDQUFDbkIsV0FBVyxHQUFHLFNBQVMsR0FBRyxFQUFHLENBQUMsQ0FBQSxHQUNyQyxDQUFFLEVBQUEsSUFBSSxDQUFDZixLQUFLLEdBQUcsU0FBUyxHQUFHLEVBQUcsQ0FBQyxDQUFBLEdBQy9CLENBQUUsRUFBQSxJQUFJLENBQUM0QixPQUFPLEdBQUcsV0FBVyxHQUFHLEVBQUcsQ0FBQyxDQUFBLEdBQ25DLENBQVEsTUFBQSxFQUFBLElBQUksQ0FBQzNCLElBQUssR0FBRSxDQUFDLENBQUE7QUFDOUIsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDSWdELEVBQUFBLE9BQU9BLEdBQUc7QUFFTnBDLElBQUFBLEtBQUssQ0FBQ2dDLEtBQUssQ0FBQ0MsMkJBQTJCLEVBQUcsQ0FBYyxZQUFBLEVBQUEsSUFBSSxDQUFDNUMsRUFBRyxDQUFHLENBQUEsRUFBQSxJQUFJLENBQUNxQyxJQUFLLEVBQUMsQ0FBQyxDQUFBO0FBRS9FLElBQUEsTUFBTVYsTUFBTSxHQUFHLElBQUksQ0FBQ0csT0FBTyxDQUFBO0FBQzNCLElBQUEsSUFBSUgsTUFBTSxFQUFFO01BQ1IsTUFBTXFCLEdBQUcsR0FBR3JCLE1BQU0sQ0FBQ3NCLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQ3hDLE1BQUEsSUFBSUYsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQ1pyQixNQUFNLENBQUNzQixPQUFPLENBQUNFLE1BQU0sQ0FBQ0gsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFBO0FBQ2pDLE9BQUE7QUFFQSxNQUFBLElBQUlyQixNQUFNLENBQUN5QixZQUFZLEtBQUssSUFBSSxFQUFFO0FBQzlCekIsUUFBQUEsTUFBTSxDQUFDMEIsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQ2hDLE9BQUE7TUFFQSxJQUFJLENBQUNDLG1CQUFtQixFQUFFLENBQUE7QUFDOUIsS0FBQTtBQUNKLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNJQSxFQUFBQSxtQkFBbUJBLEdBQUc7QUFFbEIsSUFBQSxNQUFNM0IsTUFBTSxHQUFHLElBQUksQ0FBQ0csT0FBTyxDQUFBO0FBQzNCLElBQUEsSUFBSUgsTUFBTSxFQUFFO0FBQ1IsTUFBQSxJQUFJLENBQUNjLElBQUksQ0FBQ00sT0FBTyxDQUFDcEIsTUFBTSxDQUFDLENBQUE7QUFDN0IsS0FBQTtBQUNKLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNJNEIsRUFBQUEscUJBQXFCQSxHQUFHO0lBRXBCLElBQUksSUFBSSxDQUFDdkMsWUFBWSxFQUFFO0FBQ25CLE1BQUEsSUFBSSxDQUFDQSxZQUFZLENBQUMrQixPQUFPLEVBQUUsQ0FBQTtNQUMzQixJQUFJLENBQUMvQixZQUFZLEdBQUcsSUFBSSxDQUFBO0FBQzVCLEtBQUE7SUFFQSxJQUFJLElBQUksQ0FBQ04sWUFBWSxFQUFFO0FBQ25CLE1BQUEsSUFBSSxDQUFDQSxZQUFZLENBQUNxQyxPQUFPLEVBQUUsQ0FBQTtNQUMzQixJQUFJLENBQUNyQyxZQUFZLEdBQUcsSUFBSSxDQUFBO0FBQzVCLEtBQUE7QUFDSixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDSThDLEVBQUFBLElBQUlBLEdBQUc7SUFDSCxJQUFJLENBQUNmLElBQUksQ0FBQ2UsSUFBSSxDQUFDLElBQUksQ0FBQzFCLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUN0QyxHQUFBO0VBRUEsSUFBSTJCLFdBQVdBLEdBQUc7QUFDZCxJQUFBLE9BQU8sSUFBSSxDQUFDaEIsSUFBSSxDQUFDZ0IsV0FBVyxDQUFBO0FBQ2hDLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxFQUFBQSxXQUFXQSxHQUFHO0FBQ1YsSUFBQSxJQUFJLENBQUNqQixJQUFJLENBQUNpQixXQUFXLEVBQUUsQ0FBQTtBQUMzQixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsRUFBQUEsT0FBT0EsQ0FBQ0MsS0FBSyxHQUFHLElBQUksRUFBRTlELEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDa0IsWUFBWSxFQUFFO0lBQy9DLElBQUksSUFBSSxDQUFDYyxPQUFPLElBQUksSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQyxFQUFFO0FBQ25DOEIsTUFBQUEsYUFBYSxDQUFDQyxhQUFhLENBQUMsSUFBSSxDQUFDaEMsT0FBTyxFQUFHLENBQUEsV0FBQSxFQUFhLElBQUksQ0FBQ08sSUFBSyxDQUFBLENBQUMsQ0FBQyxDQUFBO0FBQ3BFLE1BQUEsSUFBSSxDQUFDSSxJQUFJLENBQUNrQixPQUFPLENBQUMsSUFBSSxDQUFDN0IsT0FBTyxFQUFFLElBQUksRUFBRThCLEtBQUssRUFBRTlELEtBQUssQ0FBQyxDQUFBO0FBQ25EK0QsTUFBQUEsYUFBYSxDQUFDRSxZQUFZLENBQUMsSUFBSSxDQUFDakMsT0FBTyxDQUFDLENBQUE7QUFDNUMsS0FBQTtBQUNKLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lrQyxFQUFBQSxJQUFJQSxDQUFDQyxNQUFNLEVBQUVMLEtBQUssRUFBRTlELEtBQUssRUFBRTtBQUN2QixJQUFBLElBQUksQ0FBQyxJQUFJLENBQUNnQyxPQUFPLEVBQUU7TUFDZixJQUFJbUMsTUFBTSxDQUFDbkMsT0FBTyxFQUFFO0FBQ2hCLFFBQUEsSUFBSSxDQUFDQSxPQUFPLEdBQUdtQyxNQUFNLENBQUNuQyxPQUFPLENBQUE7QUFDakMsT0FBQyxNQUFNO0FBQ0huQixRQUFBQSxLQUFLLENBQUN1RCxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQTtBQUNqRCxRQUFBLE9BQU8sS0FBSyxDQUFBO0FBQ2hCLE9BQUE7QUFDSixLQUFBO0FBRUFMLElBQUFBLGFBQWEsQ0FBQ0MsYUFBYSxDQUFDLElBQUksQ0FBQ2hDLE9BQU8sRUFBRyxDQUFBLFFBQUEsRUFBVW1DLE1BQU0sQ0FBQzVCLElBQUssQ0FBSSxFQUFBLEVBQUEsSUFBSSxDQUFDQSxJQUFLLEVBQUMsQ0FBQyxDQUFBO0FBQ2pGLElBQUEsTUFBTThCLE9BQU8sR0FBRyxJQUFJLENBQUNyQyxPQUFPLENBQUNzQyxnQkFBZ0IsQ0FBQ0gsTUFBTSxFQUFFLElBQUksRUFBRUwsS0FBSyxFQUFFOUQsS0FBSyxDQUFDLENBQUE7QUFDekUrRCxJQUFBQSxhQUFhLENBQUNFLFlBQVksQ0FBQyxJQUFJLENBQUNqQyxPQUFPLENBQUMsQ0FBQTtBQUV4QyxJQUFBLE9BQU9xQyxPQUFPLENBQUE7QUFDbEIsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSW5DLE9BQU9BLEdBQUc7SUFDVixPQUFPLElBQUksQ0FBQ0QsUUFBUSxDQUFBO0FBQ3hCLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUlqQyxLQUFLQSxHQUFHO0lBQ1IsT0FBTyxJQUFJLENBQUN3QixNQUFNLENBQUE7QUFDdEIsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSUksT0FBT0EsR0FBRztJQUNWLE9BQU8sSUFBSSxDQUFDSCxRQUFRLENBQUE7QUFDeEIsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSVYsV0FBV0EsR0FBRztJQUNkLE9BQU8sSUFBSSxDQUFDSCxZQUFZLENBQUE7QUFDNUIsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJTyxXQUFXQSxHQUFHO0lBQ2QsT0FBTyxJQUFJLENBQUNELFlBQVksQ0FBQTtBQUM1QixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSWpCLElBQUlBLEdBQUc7SUFDUCxPQUFPLElBQUksQ0FBQ21CLEtBQUssQ0FBQTtBQUNyQixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJMkIsS0FBS0EsR0FBRztJQUFBLElBQUF3QixtQkFBQSxFQUFBQyxtQkFBQSxDQUFBO0lBQ1IsT0FBTyxDQUFBLENBQUFELG1CQUFBLEdBQUEsSUFBSSxDQUFDM0QsWUFBWSxxQkFBakIyRCxtQkFBQSxDQUFtQnhCLEtBQUssTUFBQSxDQUFBeUIsbUJBQUEsR0FBSSxJQUFJLENBQUN0RCxZQUFZLEtBQWpCc0QsSUFBQUEsR0FBQUEsS0FBQUEsQ0FBQUEsR0FBQUEsbUJBQUEsQ0FBbUJ6QixLQUFLLEtBQUksSUFBSSxDQUFDZixPQUFPLENBQUNlLEtBQUssQ0FBQTtBQUNyRixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJQyxNQUFNQSxHQUFHO0lBQUEsSUFBQXlCLG1CQUFBLEVBQUFDLG1CQUFBLENBQUE7SUFDVCxPQUFPLENBQUEsQ0FBQUQsbUJBQUEsR0FBQSxJQUFJLENBQUM3RCxZQUFZLHFCQUFqQjZELG1CQUFBLENBQW1CekIsTUFBTSxNQUFBLENBQUEwQixtQkFBQSxHQUFJLElBQUksQ0FBQ3hELFlBQVksS0FBakJ3RCxJQUFBQSxHQUFBQSxLQUFBQSxDQUFBQSxHQUFBQSxtQkFBQSxDQUFtQjFCLE1BQU0sS0FBSSxJQUFJLENBQUNoQixPQUFPLENBQUNnQixNQUFNLENBQUE7QUFDeEYsR0FBQTtBQUNKOzs7OyJ9
