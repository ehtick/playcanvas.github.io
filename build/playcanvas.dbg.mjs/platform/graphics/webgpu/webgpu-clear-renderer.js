import { DebugHelper, Debug } from '../../../core/debug.js';
import { BindGroupFormat, BindBufferFormat } from '../bind-group-format.js';
import { UniformBufferFormat, UniformFormat } from '../uniform-buffer-format.js';
import { BlendState } from '../blend-state.js';
import { SHADERLANGUAGE_WGSL, UNIFORMTYPE_VEC4, UNIFORMTYPE_FLOAT, UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX, SHADERSTAGE_FRAGMENT, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, CULLFACE_NONE, BINDGROUP_MESH, PRIMITIVE_TRISTRIP } from '../constants.js';
import { Shader } from '../shader.js';
import { BindGroup } from '../bind-group.js';
import { UniformBuffer } from '../uniform-buffer.js';
import { DebugGraphics } from '../debug-graphics.js';
import { DepthState } from '../depth-state.js';

const primitive = {
  type: PRIMITIVE_TRISTRIP,
  base: 0,
  count: 4,
  indexed: false
};

/**
 * A WebGPU helper class implementing a viewport clear operation. When rendering to a texture,
 * the whole surface can be cleared using loadOp, but if only a viewport needs to be cleared, or if
 * it needs to be cleared later during the rendering, this need to be archieved by rendering a quad.
 * This class renders a full-screen quad, and expects the viewport / scissor to be set up to clip
 * it to only required area.
 *
 * @ignore
 */
class WebgpuClearRenderer {
  constructor(device) {
    // shader that can write out color and depth values
    const code = `

            struct ub_mesh {
                color : vec4f,
                depth: f32
            }

            @group(0) @binding(0) var<uniform> ubMesh : ub_mesh;

            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
                vec2(-1.0, 1.0), vec2(1.0, 1.0),
                vec2(-1.0, -1.0), vec2(1.0, -1.0)
            );

            struct VertexOutput {
                @builtin(position) position : vec4f
            }

            @vertex
            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                var output : VertexOutput;
                output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);
                return output;
            }

            @fragment
            fn fragmentMain() -> @location(0) vec4f {
                return ubMesh.color;
            }
        `;
    this.shader = new Shader(device, {
      name: 'WebGPUClearRendererShader',
      shaderLanguage: SHADERLANGUAGE_WGSL,
      vshader: code,
      fshader: code
    });

    // uniforms
    this.uniformBuffer = new UniformBuffer(device, new UniformBufferFormat(device, [new UniformFormat('color', UNIFORMTYPE_VEC4), new UniformFormat('depth', UNIFORMTYPE_FLOAT)]), false);

    // format of the bind group
    const bindGroupFormat = new BindGroupFormat(device, [new BindBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)]);

    // bind group
    this.bindGroup = new BindGroup(device, bindGroupFormat, this.uniformBuffer);
    DebugHelper.setName(this.bindGroup, `ClearRenderer-BindGroup_${this.bindGroup.id}`);

    // uniform data
    this.colorData = new Float32Array(4);
    this.colorId = device.scope.resolve('color');
    this.depthId = device.scope.resolve('depth');
  }
  clear(device, renderTarget, options, defaultOptions) {
    var _options$flags;
    options = options || defaultOptions;
    const flags = (_options$flags = options.flags) != null ? _options$flags : defaultOptions.flags;
    if (flags !== 0) {
      DebugGraphics.pushGpuMarker(device, 'CLEAR-RENDERER');

      // setup clear color
      if (flags & CLEARFLAG_COLOR && renderTarget.colorBuffer) {
        var _options$color;
        const color = (_options$color = options.color) != null ? _options$color : defaultOptions.color;
        this.colorData.set(color);
        device.setBlendState(BlendState.NOBLEND);
      } else {
        device.setBlendState(BlendState.NOWRITE);
      }
      this.colorId.setValue(this.colorData);

      // setup depth clear
      if (flags & CLEARFLAG_DEPTH && renderTarget.depth) {
        var _options$depth;
        const depth = (_options$depth = options.depth) != null ? _options$depth : defaultOptions.depth;
        this.depthId.setValue(depth);
        device.setDepthState(DepthState.WRITEDEPTH);
      } else {
        this.depthId.setValue(1);
        device.setDepthState(DepthState.NODEPTH);
      }

      // setup stencil clear
      if (flags & CLEARFLAG_STENCIL && renderTarget.stencil) {
        Debug.warnOnce("ClearRenderer does not support stencil clear at the moment");
      }
      device.setCullMode(CULLFACE_NONE);

      // render 4 vertices without vertex buffer
      device.setShader(this.shader);
      const bindGroup = this.bindGroup;
      bindGroup.defaultUniformBuffer.update();
      bindGroup.update();
      device.setBindGroup(BINDGROUP_MESH, bindGroup);
      device.draw(primitive);
      DebugGraphics.popGpuMarker(device);
    }
  }
}

export { WebgpuClearRenderer };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1LWNsZWFyLXJlbmRlcmVyLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvcGxhdGZvcm0vZ3JhcGhpY3Mvd2ViZ3B1L3dlYmdwdS1jbGVhci1yZW5kZXJlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZywgRGVidWdIZWxwZXIgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9kZWJ1Zy5qc1wiO1xuaW1wb3J0IHsgQmluZEJ1ZmZlckZvcm1hdCwgQmluZEdyb3VwRm9ybWF0IH0gZnJvbSBcIi4uL2JpbmQtZ3JvdXAtZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBVbmlmb3JtQnVmZmVyRm9ybWF0LCBVbmlmb3JtRm9ybWF0IH0gZnJvbSBcIi4uL3VuaWZvcm0tYnVmZmVyLWZvcm1hdC5qc1wiO1xuaW1wb3J0IHsgQmxlbmRTdGF0ZSB9IGZyb20gXCIuLi9ibGVuZC1zdGF0ZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBDVUxMRkFDRV9OT05FLFxuICAgIFBSSU1JVElWRV9UUklTVFJJUCwgU0hBREVSTEFOR1VBR0VfV0dTTCwgU0hBREVSU1RBR0VfRlJBR01FTlQsIFNIQURFUlNUQUdFX1ZFUlRFWCxcbiAgICBVTklGT1JNVFlQRV9GTE9BVCwgVU5JRk9STVRZUEVfVkVDNCwgVU5JRk9STV9CVUZGRVJfREVGQVVMVF9TTE9UX05BTUUsIEJJTkRHUk9VUF9NRVNILCBDTEVBUkZMQUdfQ09MT1IsIENMRUFSRkxBR19ERVBUSCwgQ0xFQVJGTEFHX1NURU5DSUxcbn0gZnJvbSBcIi4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSBcIi4uL3NoYWRlci5qc1wiO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSBcIi4uL2JpbmQtZ3JvdXAuanNcIjtcbmltcG9ydCB7IFVuaWZvcm1CdWZmZXIgfSBmcm9tIFwiLi4vdW5pZm9ybS1idWZmZXIuanNcIjtcbmltcG9ydCB7IERlYnVnR3JhcGhpY3MgfSBmcm9tIFwiLi4vZGVidWctZ3JhcGhpY3MuanNcIjtcbmltcG9ydCB7IERlcHRoU3RhdGUgfSBmcm9tIFwiLi4vZGVwdGgtc3RhdGUuanNcIjtcblxuY29uc3QgcHJpbWl0aXZlID0ge1xuICAgIHR5cGU6IFBSSU1JVElWRV9UUklTVFJJUCxcbiAgICBiYXNlOiAwLFxuICAgIGNvdW50OiA0LFxuICAgIGluZGV4ZWQ6IGZhbHNlXG59O1xuXG4vKipcbiAqIEEgV2ViR1BVIGhlbHBlciBjbGFzcyBpbXBsZW1lbnRpbmcgYSB2aWV3cG9ydCBjbGVhciBvcGVyYXRpb24uIFdoZW4gcmVuZGVyaW5nIHRvIGEgdGV4dHVyZSxcbiAqIHRoZSB3aG9sZSBzdXJmYWNlIGNhbiBiZSBjbGVhcmVkIHVzaW5nIGxvYWRPcCwgYnV0IGlmIG9ubHkgYSB2aWV3cG9ydCBuZWVkcyB0byBiZSBjbGVhcmVkLCBvciBpZlxuICogaXQgbmVlZHMgdG8gYmUgY2xlYXJlZCBsYXRlciBkdXJpbmcgdGhlIHJlbmRlcmluZywgdGhpcyBuZWVkIHRvIGJlIGFyY2hpZXZlZCBieSByZW5kZXJpbmcgYSBxdWFkLlxuICogVGhpcyBjbGFzcyByZW5kZXJzIGEgZnVsbC1zY3JlZW4gcXVhZCwgYW5kIGV4cGVjdHMgdGhlIHZpZXdwb3J0IC8gc2Npc3NvciB0byBiZSBzZXQgdXAgdG8gY2xpcFxuICogaXQgdG8gb25seSByZXF1aXJlZCBhcmVhLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgV2ViZ3B1Q2xlYXJSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoZGV2aWNlKSB7XG5cbiAgICAgICAgLy8gc2hhZGVyIHRoYXQgY2FuIHdyaXRlIG91dCBjb2xvciBhbmQgZGVwdGggdmFsdWVzXG4gICAgICAgIGNvbnN0IGNvZGUgPSBgXG5cbiAgICAgICAgICAgIHN0cnVjdCB1Yl9tZXNoIHtcbiAgICAgICAgICAgICAgICBjb2xvciA6IHZlYzRmLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBmMzJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiB1Yk1lc2ggOiB1Yl9tZXNoO1xuXG4gICAgICAgICAgICB2YXI8cHJpdmF0ZT4gcG9zIDogYXJyYXk8dmVjMmYsIDQ+ID0gYXJyYXk8dmVjMmYsIDQ+KFxuICAgICAgICAgICAgICAgIHZlYzIoLTEuMCwgMS4wKSwgdmVjMigxLjAsIDEuMCksXG4gICAgICAgICAgICAgICAgdmVjMigtMS4wLCAtMS4wKSwgdmVjMigxLjAsIC0xLjApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzdHJ1Y3QgVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICAgICAgICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb24gOiB2ZWM0ZlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAdmVydGV4XG4gICAgICAgICAgICBmbiB2ZXJ0ZXhNYWluKEBidWlsdGluKHZlcnRleF9pbmRleCkgdmVydGV4SW5kZXggOiB1MzIpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA6IFZlcnRleE91dHB1dDtcbiAgICAgICAgICAgICAgICBvdXRwdXQucG9zaXRpb24gPSB2ZWM0KHBvc1t2ZXJ0ZXhJbmRleF0sIHViTWVzaC5kZXB0aCwgMS4wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAZnJhZ21lbnRcbiAgICAgICAgICAgIGZuIGZyYWdtZW50TWFpbigpIC0+IEBsb2NhdGlvbigwKSB2ZWM0ZiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHViTWVzaC5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgICAgICB0aGlzLnNoYWRlciA9IG5ldyBTaGFkZXIoZGV2aWNlLCB7XG4gICAgICAgICAgICBuYW1lOiAnV2ViR1BVQ2xlYXJSZW5kZXJlclNoYWRlcicsXG4gICAgICAgICAgICBzaGFkZXJMYW5ndWFnZTogU0hBREVSTEFOR1VBR0VfV0dTTCxcbiAgICAgICAgICAgIHZzaGFkZXI6IGNvZGUsXG4gICAgICAgICAgICBmc2hhZGVyOiBjb2RlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHVuaWZvcm1zXG4gICAgICAgIHRoaXMudW5pZm9ybUJ1ZmZlciA9IG5ldyBVbmlmb3JtQnVmZmVyKGRldmljZSwgbmV3IFVuaWZvcm1CdWZmZXJGb3JtYXQoZGV2aWNlLCBbXG4gICAgICAgICAgICBuZXcgVW5pZm9ybUZvcm1hdCgnY29sb3InLCBVTklGT1JNVFlQRV9WRUM0KSxcbiAgICAgICAgICAgIG5ldyBVbmlmb3JtRm9ybWF0KCdkZXB0aCcsIFVOSUZPUk1UWVBFX0ZMT0FUKVxuICAgICAgICBdKSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIGZvcm1hdCBvZiB0aGUgYmluZCBncm91cFxuICAgICAgICBjb25zdCBiaW5kR3JvdXBGb3JtYXQgPSBuZXcgQmluZEdyb3VwRm9ybWF0KGRldmljZSwgW1xuICAgICAgICAgICAgbmV3IEJpbmRCdWZmZXJGb3JtYXQoVU5JRk9STV9CVUZGRVJfREVGQVVMVF9TTE9UX05BTUUsIFNIQURFUlNUQUdFX1ZFUlRFWCB8IFNIQURFUlNUQUdFX0ZSQUdNRU5UKVxuICAgICAgICBdKTtcblxuICAgICAgICAvLyBiaW5kIGdyb3VwXG4gICAgICAgIHRoaXMuYmluZEdyb3VwID0gbmV3IEJpbmRHcm91cChkZXZpY2UsIGJpbmRHcm91cEZvcm1hdCwgdGhpcy51bmlmb3JtQnVmZmVyKTtcbiAgICAgICAgRGVidWdIZWxwZXIuc2V0TmFtZSh0aGlzLmJpbmRHcm91cCwgYENsZWFyUmVuZGVyZXItQmluZEdyb3VwXyR7dGhpcy5iaW5kR3JvdXAuaWR9YCk7XG5cbiAgICAgICAgLy8gdW5pZm9ybSBkYXRhXG4gICAgICAgIHRoaXMuY29sb3JEYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgdGhpcy5jb2xvcklkID0gZGV2aWNlLnNjb3BlLnJlc29sdmUoJ2NvbG9yJyk7XG4gICAgICAgIHRoaXMuZGVwdGhJZCA9IGRldmljZS5zY29wZS5yZXNvbHZlKCdkZXB0aCcpO1xuICAgIH1cblxuICAgIGNsZWFyKGRldmljZSwgcmVuZGVyVGFyZ2V0LCBvcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucztcblxuICAgICAgICBjb25zdCBmbGFncyA9IG9wdGlvbnMuZmxhZ3MgPz8gZGVmYXVsdE9wdGlvbnMuZmxhZ3M7XG4gICAgICAgIGlmIChmbGFncyAhPT0gMCkge1xuXG4gICAgICAgICAgICBEZWJ1Z0dyYXBoaWNzLnB1c2hHcHVNYXJrZXIoZGV2aWNlLCAnQ0xFQVItUkVOREVSRVInKTtcblxuICAgICAgICAgICAgLy8gc2V0dXAgY2xlYXIgY29sb3JcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBDTEVBUkZMQUdfQ09MT1IpICYmIHJlbmRlclRhcmdldC5jb2xvckJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5jb2xvciA/PyBkZWZhdWx0T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yRGF0YS5zZXQoY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgZGV2aWNlLnNldEJsZW5kU3RhdGUoQmxlbmRTdGF0ZS5OT0JMRU5EKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlLnNldEJsZW5kU3RhdGUoQmxlbmRTdGF0ZS5OT1dSSVRFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29sb3JJZC5zZXRWYWx1ZSh0aGlzLmNvbG9yRGF0YSk7XG5cbiAgICAgICAgICAgIC8vIHNldHVwIGRlcHRoIGNsZWFyXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgQ0xFQVJGTEFHX0RFUFRIKSAmJiByZW5kZXJUYXJnZXQuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXB0aCA9IG9wdGlvbnMuZGVwdGggPz8gZGVmYXVsdE9wdGlvbnMuZGVwdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aElkLnNldFZhbHVlKGRlcHRoKTtcbiAgICAgICAgICAgICAgICBkZXZpY2Uuc2V0RGVwdGhTdGF0ZShEZXB0aFN0YXRlLldSSVRFREVQVEgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhJZC5zZXRWYWx1ZSgxKTtcbiAgICAgICAgICAgICAgICBkZXZpY2Uuc2V0RGVwdGhTdGF0ZShEZXB0aFN0YXRlLk5PREVQVEgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXR1cCBzdGVuY2lsIGNsZWFyXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgQ0xFQVJGTEFHX1NURU5DSUwpICYmIHJlbmRlclRhcmdldC5zdGVuY2lsKSB7XG4gICAgICAgICAgICAgICAgRGVidWcud2Fybk9uY2UoXCJDbGVhclJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RlbmNpbCBjbGVhciBhdCB0aGUgbW9tZW50XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXZpY2Uuc2V0Q3VsbE1vZGUoQ1VMTEZBQ0VfTk9ORSk7XG5cbiAgICAgICAgICAgIC8vIHJlbmRlciA0IHZlcnRpY2VzIHdpdGhvdXQgdmVydGV4IGJ1ZmZlclxuICAgICAgICAgICAgZGV2aWNlLnNldFNoYWRlcih0aGlzLnNoYWRlcik7XG5cbiAgICAgICAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuYmluZEdyb3VwO1xuICAgICAgICAgICAgYmluZEdyb3VwLmRlZmF1bHRVbmlmb3JtQnVmZmVyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgYmluZEdyb3VwLnVwZGF0ZSgpO1xuICAgICAgICAgICAgZGV2aWNlLnNldEJpbmRHcm91cChCSU5ER1JPVVBfTUVTSCwgYmluZEdyb3VwKTtcblxuICAgICAgICAgICAgZGV2aWNlLmRyYXcocHJpbWl0aXZlKTtcblxuICAgICAgICAgICAgRGVidWdHcmFwaGljcy5wb3BHcHVNYXJrZXIoZGV2aWNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgV2ViZ3B1Q2xlYXJSZW5kZXJlciB9O1xuIl0sIm5hbWVzIjpbInByaW1pdGl2ZSIsInR5cGUiLCJQUklNSVRJVkVfVFJJU1RSSVAiLCJiYXNlIiwiY291bnQiLCJpbmRleGVkIiwiV2ViZ3B1Q2xlYXJSZW5kZXJlciIsImNvbnN0cnVjdG9yIiwiZGV2aWNlIiwiY29kZSIsInNoYWRlciIsIlNoYWRlciIsIm5hbWUiLCJzaGFkZXJMYW5ndWFnZSIsIlNIQURFUkxBTkdVQUdFX1dHU0wiLCJ2c2hhZGVyIiwiZnNoYWRlciIsInVuaWZvcm1CdWZmZXIiLCJVbmlmb3JtQnVmZmVyIiwiVW5pZm9ybUJ1ZmZlckZvcm1hdCIsIlVuaWZvcm1Gb3JtYXQiLCJVTklGT1JNVFlQRV9WRUM0IiwiVU5JRk9STVRZUEVfRkxPQVQiLCJiaW5kR3JvdXBGb3JtYXQiLCJCaW5kR3JvdXBGb3JtYXQiLCJCaW5kQnVmZmVyRm9ybWF0IiwiVU5JRk9STV9CVUZGRVJfREVGQVVMVF9TTE9UX05BTUUiLCJTSEFERVJTVEFHRV9WRVJURVgiLCJTSEFERVJTVEFHRV9GUkFHTUVOVCIsImJpbmRHcm91cCIsIkJpbmRHcm91cCIsIkRlYnVnSGVscGVyIiwic2V0TmFtZSIsImlkIiwiY29sb3JEYXRhIiwiRmxvYXQzMkFycmF5IiwiY29sb3JJZCIsInNjb3BlIiwicmVzb2x2ZSIsImRlcHRoSWQiLCJjbGVhciIsInJlbmRlclRhcmdldCIsIm9wdGlvbnMiLCJkZWZhdWx0T3B0aW9ucyIsIl9vcHRpb25zJGZsYWdzIiwiZmxhZ3MiLCJEZWJ1Z0dyYXBoaWNzIiwicHVzaEdwdU1hcmtlciIsIkNMRUFSRkxBR19DT0xPUiIsImNvbG9yQnVmZmVyIiwiX29wdGlvbnMkY29sb3IiLCJjb2xvciIsInNldCIsInNldEJsZW5kU3RhdGUiLCJCbGVuZFN0YXRlIiwiTk9CTEVORCIsIk5PV1JJVEUiLCJzZXRWYWx1ZSIsIkNMRUFSRkxBR19ERVBUSCIsImRlcHRoIiwiX29wdGlvbnMkZGVwdGgiLCJzZXREZXB0aFN0YXRlIiwiRGVwdGhTdGF0ZSIsIldSSVRFREVQVEgiLCJOT0RFUFRIIiwiQ0xFQVJGTEFHX1NURU5DSUwiLCJzdGVuY2lsIiwiRGVidWciLCJ3YXJuT25jZSIsInNldEN1bGxNb2RlIiwiQ1VMTEZBQ0VfTk9ORSIsInNldFNoYWRlciIsImRlZmF1bHRVbmlmb3JtQnVmZmVyIiwidXBkYXRlIiwic2V0QmluZEdyb3VwIiwiQklOREdST1VQX01FU0giLCJkcmF3IiwicG9wR3B1TWFya2VyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWVBLE1BQU1BLFNBQVMsR0FBRztBQUNkQyxFQUFBQSxJQUFJLEVBQUVDLGtCQUFrQjtBQUN4QkMsRUFBQUEsSUFBSSxFQUFFLENBQUM7QUFDUEMsRUFBQUEsS0FBSyxFQUFFLENBQUM7QUFDUkMsRUFBQUEsT0FBTyxFQUFFLEtBQUE7QUFDYixDQUFDLENBQUE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsbUJBQW1CLENBQUM7RUFDdEJDLFdBQVdBLENBQUNDLE1BQU0sRUFBRTtBQUVoQjtBQUNBLElBQUEsTUFBTUMsSUFBSSxHQUFJLENBQUE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFTLENBQUEsQ0FBQTtBQUVELElBQUEsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUMsTUFBTSxDQUFDSCxNQUFNLEVBQUU7QUFDN0JJLE1BQUFBLElBQUksRUFBRSwyQkFBMkI7QUFDakNDLE1BQUFBLGNBQWMsRUFBRUMsbUJBQW1CO0FBQ25DQyxNQUFBQSxPQUFPLEVBQUVOLElBQUk7QUFDYk8s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
