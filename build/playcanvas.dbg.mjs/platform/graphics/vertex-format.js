/**
 * @license
 * PlayCanvas Engine v1.62.0-dev revision 7d088032c (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { Debug } from '../../core/debug.js';
import { hashCode } from '../../core/hash.js';
import { math } from '../../core/math/math.js';
import { typedArrayTypesByteSize, DEVICETYPE_WEBGPU, vertexTypesNames, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_COLOR, SEMANTIC_TANGENT, SEMANTIC_ATTR12, TYPE_FLOAT32, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, DEVICETYPE_WEBGL } from './constants.js';

/**
 * A vertex format is a descriptor that defines the layout of vertex data inside a
 * {@link VertexBuffer}.
 *
 * @property {object[]} elements The vertex attribute elements.
 * @property {string} elements[].name The meaning of the vertex element. This is used to link the
 * vertex data to a shader input. Can be:
 *
 * - {@link SEMANTIC_POSITION}
 * - {@link SEMANTIC_NORMAL}
 * - {@link SEMANTIC_TANGENT}
 * - {@link SEMANTIC_BLENDWEIGHT}
 * - {@link SEMANTIC_BLENDINDICES}
 * - {@link SEMANTIC_COLOR}
 * - {@link SEMANTIC_TEXCOORD0}
 * - {@link SEMANTIC_TEXCOORD1}
 * - {@link SEMANTIC_TEXCOORD2}
 * - {@link SEMANTIC_TEXCOORD3}
 * - {@link SEMANTIC_TEXCOORD4}
 * - {@link SEMANTIC_TEXCOORD5}
 * - {@link SEMANTIC_TEXCOORD6}
 * - {@link SEMANTIC_TEXCOORD7}
 *
 * If vertex data has a meaning other that one of those listed above, use the user-defined
 * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
 * @property {number} elements[].numComponents The number of components of the vertex attribute.
 * Can be 1, 2, 3 or 4.
 * @property {number} elements[].dataType The data type of the attribute. Can be:
 *
 * - {@link TYPE_INT8}
 * - {@link TYPE_UINT8}
 * - {@link TYPE_INT16}
 * - {@link TYPE_UINT16}
 * - {@link TYPE_INT32}
 * - {@link TYPE_UINT32}
 * - {@link TYPE_FLOAT32}
 * @property {boolean} elements[].normalize If true, vertex attribute data will be mapped from a 0
 * to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
 * unchanged. If this property is unspecified, false is assumed.
 * @property {number} elements[].offset The number of initial bytes at the start of a vertex that
 * are not relevant to this attribute.
 * @property {number} elements[].stride The number of total bytes that are between the start of one
 * vertex, and the start of the next.
 * @property {number} elements[].size The size of the attribute in bytes.
 */
class VertexFormat {
  /**
   * Create a new VertexFormat instance.
   *
   * @param {import('./graphics-device.js').GraphicsDevice} graphicsDevice - The graphics device
   * used to manage this vertex format.
   * @param {object[]} description - An array of vertex attribute descriptions.
   * @param {string} description[].semantic - The meaning of the vertex element. This is used to
   * link the vertex data to a shader input. Can be:
   *
   * - {@link SEMANTIC_POSITION}
   * - {@link SEMANTIC_NORMAL}
   * - {@link SEMANTIC_TANGENT}
   * - {@link SEMANTIC_BLENDWEIGHT}
   * - {@link SEMANTIC_BLENDINDICES}
   * - {@link SEMANTIC_COLOR}
   * - {@link SEMANTIC_TEXCOORD0}
   * - {@link SEMANTIC_TEXCOORD1}
   * - {@link SEMANTIC_TEXCOORD2}
   * - {@link SEMANTIC_TEXCOORD3}
   * - {@link SEMANTIC_TEXCOORD4}
   * - {@link SEMANTIC_TEXCOORD5}
   * - {@link SEMANTIC_TEXCOORD6}
   * - {@link SEMANTIC_TEXCOORD7}
   *
   * If vertex data has a meaning other that one of those listed above, use the user-defined
   * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
   * @param {number} description[].components - The number of components of the vertex attribute.
   * Can be 1, 2, 3 or 4.
   * @param {number} description[].type - The data type of the attribute. Can be:
   *
   * - {@link TYPE_INT8}
   * - {@link TYPE_UINT8}
   * - {@link TYPE_INT16}
   * - {@link TYPE_UINT16}
   * - {@link TYPE_INT32}
   * - {@link TYPE_UINT32}
   * - {@link TYPE_FLOAT32}
   *
   * @param {boolean} [description[].normalize] - If true, vertex attribute data will be mapped
   * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data
   * is left unchanged. If this property is unspecified, false is assumed.
   * @param {number} [vertexCount] - When specified, vertex format will be set up for
   * non-interleaved format with a specified number of vertices. (example: PPPPNNNNCCCC), where
   * arrays of individual attributes will be stored one right after the other (subject to
   * alignment requirements). Note that in this case, the format depends on the number of
   * vertices, and needs to change when the number of vertices changes. When not specified,
   * vertex format will be interleaved. (example: PNCPNCPNCPNC).
   * @example
   * // Specify 3-component positions (x, y, z)
   * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
   *     { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
   * ]);
   * @example
   * // Specify 2-component positions (x, y), a texture coordinate (u, v) and a vertex color (r, g, b, a)
   * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
   *     { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },
   *     { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },
   *     { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }
   * ]);
   */
  constructor(graphicsDevice, description, vertexCount) {
    this.device = graphicsDevice;
    this._elements = [];
    this.hasUv0 = false;
    this.hasUv1 = false;
    this.hasColor = false;
    this.hasTangents = false;
    this.verticesByteSize = 0;
    this.vertexCount = vertexCount;
    this.interleaved = vertexCount === undefined;

    // true if the vertex format represents an instancing vertex buffer
    this.instancing = false;

    // calculate total size of the vertex
    this.size = description.reduce((total, desc) => {
      return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
    }, 0);
    let offset = 0,
      elementSize;
    for (let i = 0, len = description.length; i < len; i++) {
      const elementDesc = description[i];
      elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];

      // WebGPU has limited element size support (for example uint16x3 is not supported)
      Debug.assert(graphicsDevice.deviceType !== DEVICETYPE_WEBGPU || [2, 4, 8, 12, 16].includes(elementSize), `WebGPU does not support the format of vertex element ${elementDesc.semantic} : ${vertexTypesNames[elementDesc.type]} x ${elementDesc.components}`);

      // align up the offset to elementSize (when vertexCount is specified only - case of non-interleaved format)
      if (vertexCount) {
        offset = math.roundUp(offset, elementSize);

        // non-interleaved format with elementSize not multiple of 4 might be slower on some platforms - padding is recommended to align its size
        // example: use 4 x TYPE_UINT8 instead of 3 x TYPE_UINT8
        Debug.assert(elementSize % 4 === 0, `Non-interleaved vertex format with element size not multiple of 4 can have performance impact on some platforms. Element size: ${elementSize}`);
      }
      const element = {
        name: elementDesc.semantic,
        offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
        stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
        dataType: elementDesc.type,
        numComponents: elementDesc.components,
        normalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,
        size: elementSize
      };
      this._elements.push(element);
      if (vertexCount) {
        offset += elementSize * vertexCount;
      } else {
        offset += Math.ceil(elementSize / 4) * 4;
      }
      if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
        this.hasUv0 = true;
      } else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
        this.hasUv1 = true;
      } else if (elementDesc.semantic === SEMANTIC_COLOR) {
        this.hasColor = true;
      } else if (elementDesc.semantic === SEMANTIC_TANGENT) {
        this.hasTangents = true;
      }
    }
    if (vertexCount) {
      this.verticesByteSize = offset;
    }
    this._evaluateHash();
  }
  get elements() {
    return this._elements;
  }

  /**
   * @type {VertexFormat}
   * @private
   */

  /**
   * The {@link VertexFormat} used to store matrices of type {@link Mat4} for hardware instancing.
   *
   * @param {import('./graphics-device.js').GraphicsDevice} graphicsDevice - The graphics device
   * used to create this vertex format.
   *
   * @returns {VertexFormat} The default instancing vertex format.
   */
  static getDefaultInstancingFormat(graphicsDevice) {
    if (!VertexFormat._defaultInstancingFormat) {
      VertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, [{
        semantic: SEMANTIC_ATTR12,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR13,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR14,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR15,
        components: 4,
        type: TYPE_FLOAT32
      }]);
    }
    return VertexFormat._defaultInstancingFormat;
  }

  /**
   * Applies any changes made to the VertexFormat's properties.
   *
   * @private
   */
  update() {
    // Note that this is used only by vertex attribute morphing on the WebGL.
    Debug.assert(this.device.deviceType === DEVICETYPE_WEBGL, `VertexFormat#update is not supported on WebGPU and VertexFormat cannot be modified.`);
    this._evaluateHash();
  }

  /**
   * Evaluates hash values for the format allowing fast compare of batching / rendering compatibility.
   *
   * @private
   */
  _evaluateHash() {
    let stringElementBatch;
    const stringElementsBatch = [];
    let stringElementRender;
    const stringElementsRender = [];
    const len = this._elements.length;
    for (let i = 0; i < len; i++) {
      const element = this._elements[i];

      // create string description of each element that is relevant for batching
      stringElementBatch = element.name;
      stringElementBatch += element.dataType;
      stringElementBatch += element.numComponents;
      stringElementBatch += element.normalize;
      stringElementsBatch.push(stringElementBatch);

      // create string description of each element that is relevant for rendering
      stringElementRender = stringElementBatch;
      stringElementRender += element.offset;
      stringElementRender += element.stride;
      stringElementRender += element.size;
      stringElementsRender.push(stringElementRender);
    }

    // sort batching ones alphabetically to make the hash order independent
    stringElementsBatch.sort();
    this.batchingHash = hashCode(stringElementsBatch.join());

    // rendering hash
    this.renderingingHashString = stringElementsRender.join('_');
    this.renderingingHash = hashCode(this.renderingingHashString);
  }
}
VertexFormat._defaultInstancingFormat = null;

export { VertexFormat };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVydGV4LWZvcm1hdC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3BsYXRmb3JtL2dyYXBoaWNzL3ZlcnRleC1mb3JtYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IGhhc2hDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9oYXNoLmpzJztcblxuaW1wb3J0IHsgbWF0aCB9IGZyb20gJy4uLy4uL2NvcmUvbWF0aC9tYXRoLmpzJztcblxuaW1wb3J0IHtcbiAgICBTRU1BTlRJQ19URVhDT09SRDAsIFNFTUFOVElDX1RFWENPT1JEMSwgU0VNQU5USUNfQVRUUjEyLCBTRU1BTlRJQ19BVFRSMTMsIFNFTUFOVElDX0FUVFIxNCwgU0VNQU5USUNfQVRUUjE1LFxuICAgIFNFTUFOVElDX0NPTE9SLCBTRU1BTlRJQ19UQU5HRU5ULCBUWVBFX0ZMT0FUMzIsIHR5cGVkQXJyYXlUeXBlc0J5dGVTaXplLCB2ZXJ0ZXhUeXBlc05hbWVzLCBERVZJQ0VUWVBFX1dFQkdQVSwgREVWSUNFVFlQRV9XRUJHTFxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQSB2ZXJ0ZXggZm9ybWF0IGlzIGEgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgdGhlIGxheW91dCBvZiB2ZXJ0ZXggZGF0YSBpbnNpZGUgYVxuICoge0BsaW5rIFZlcnRleEJ1ZmZlcn0uXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3RbXX0gZWxlbWVudHMgVGhlIHZlcnRleCBhdHRyaWJ1dGUgZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZWxlbWVudHNbXS5uYW1lIFRoZSBtZWFuaW5nIG9mIHRoZSB2ZXJ0ZXggZWxlbWVudC4gVGhpcyBpcyB1c2VkIHRvIGxpbmsgdGhlXG4gKiB2ZXJ0ZXggZGF0YSB0byBhIHNoYWRlciBpbnB1dC4gQ2FuIGJlOlxuICpcbiAqIC0ge0BsaW5rIFNFTUFOVElDX1BPU0lUSU9OfVxuICogLSB7QGxpbmsgU0VNQU5USUNfTk9STUFMfVxuICogLSB7QGxpbmsgU0VNQU5USUNfVEFOR0VOVH1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX0JMRU5EV0VJR0hUfVxuICogLSB7QGxpbmsgU0VNQU5USUNfQkxFTkRJTkRJQ0VTfVxuICogLSB7QGxpbmsgU0VNQU5USUNfQ09MT1J9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDB9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDF9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDJ9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDN9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDR9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDV9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDZ9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDd9XG4gKlxuICogSWYgdmVydGV4IGRhdGEgaGFzIGEgbWVhbmluZyBvdGhlciB0aGF0IG9uZSBvZiB0aG9zZSBsaXN0ZWQgYWJvdmUsIHVzZSB0aGUgdXNlci1kZWZpbmVkXG4gKiBzZW1hbnRpY3M6IHtAbGluayBTRU1BTlRJQ19BVFRSMH0gdG8ge0BsaW5rIFNFTUFOVElDX0FUVFIxNX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudHNbXS5udW1Db21wb25lbnRzIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS5cbiAqIENhbiBiZSAxLCAyLCAzIG9yIDQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudHNbXS5kYXRhVHlwZSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUuIENhbiBiZTpcbiAqXG4gKiAtIHtAbGluayBUWVBFX0lOVDh9XG4gKiAtIHtAbGluayBUWVBFX1VJTlQ4fVxuICogLSB7QGxpbmsgVFlQRV9JTlQxNn1cbiAqIC0ge0BsaW5rIFRZUEVfVUlOVDE2fVxuICogLSB7QGxpbmsgVFlQRV9JTlQzMn1cbiAqIC0ge0BsaW5rIFRZUEVfVUlOVDMyfVxuICogLSB7QGxpbmsgVFlQRV9GTE9BVDMyfVxuICogQHByb3BlcnR5IHtib29sZWFufSBlbGVtZW50c1tdLm5vcm1hbGl6ZSBJZiB0cnVlLCB2ZXJ0ZXggYXR0cmlidXRlIGRhdGEgd2lsbCBiZSBtYXBwZWQgZnJvbSBhIDBcbiAqIHRvIDI1NSByYW5nZSBkb3duIHRvIDAgdG8gMSB3aGVuIGZlZCB0byBhIHNoYWRlci4gSWYgZmFsc2UsIHZlcnRleCBhdHRyaWJ1dGUgZGF0YSBpcyBsZWZ0XG4gKiB1bmNoYW5nZWQuIElmIHRoaXMgcHJvcGVydHkgaXMgdW5zcGVjaWZpZWQsIGZhbHNlIGlzIGFzc3VtZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudHNbXS5vZmZzZXQgVGhlIG51bWJlciBvZiBpbml0aWFsIGJ5dGVzIGF0IHRoZSBzdGFydCBvZiBhIHZlcnRleCB0aGF0XG4gKiBhcmUgbm90IHJlbGV2YW50IHRvIHRoaXMgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVsZW1lbnRzW10uc3RyaWRlIFRoZSBudW1iZXIgb2YgdG90YWwgYnl0ZXMgdGhhdCBhcmUgYmV0d2VlbiB0aGUgc3RhcnQgb2Ygb25lXG4gKiB2ZXJ0ZXgsIGFuZCB0aGUgc3RhcnQgb2YgdGhlIG5leHQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudHNbXS5zaXplIFRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUgaW4gYnl0ZXMuXG4gKi9cbmNsYXNzIFZlcnRleEZvcm1hdCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFZlcnRleEZvcm1hdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSBncmFwaGljc0RldmljZSAtIFRoZSBncmFwaGljcyBkZXZpY2VcbiAgICAgKiB1c2VkIHRvIG1hbmFnZSB0aGlzIHZlcnRleCBmb3JtYXQuXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gZGVzY3JpcHRpb24gLSBBbiBhcnJheSBvZiB2ZXJ0ZXggYXR0cmlidXRlIGRlc2NyaXB0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVzY3JpcHRpb25bXS5zZW1hbnRpYyAtIFRoZSBtZWFuaW5nIG9mIHRoZSB2ZXJ0ZXggZWxlbWVudC4gVGhpcyBpcyB1c2VkIHRvXG4gICAgICogbGluayB0aGUgdmVydGV4IGRhdGEgdG8gYSBzaGFkZXIgaW5wdXQuIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1BPU0lUSU9OfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX05PUk1BTH1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19UQU5HRU5UfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX0JMRU5EV0VJR0hUfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX0JMRU5ESU5ESUNFU31cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19DT0xPUn1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDB9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQxfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMn1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDN9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQ0fVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENX1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDZ9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQ3fVxuICAgICAqXG4gICAgICogSWYgdmVydGV4IGRhdGEgaGFzIGEgbWVhbmluZyBvdGhlciB0aGF0IG9uZSBvZiB0aG9zZSBsaXN0ZWQgYWJvdmUsIHVzZSB0aGUgdXNlci1kZWZpbmVkXG4gICAgICogc2VtYW50aWNzOiB7QGxpbmsgU0VNQU5USUNfQVRUUjB9IHRvIHtAbGluayBTRU1BTlRJQ19BVFRSMTV9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXNjcmlwdGlvbltdLmNvbXBvbmVudHMgLSBUaGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGUuXG4gICAgICogQ2FuIGJlIDEsIDIsIDMgb3IgNC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVzY3JpcHRpb25bXS50eXBlIC0gVGhlIGRhdGEgdHlwZSBvZiB0aGUgYXR0cmlidXRlLiBDYW4gYmU6XG4gICAgICpcbiAgICAgKiAtIHtAbGluayBUWVBFX0lOVDh9XG4gICAgICogLSB7QGxpbmsgVFlQRV9VSU5UOH1cbiAgICAgKiAtIHtAbGluayBUWVBFX0lOVDE2fVxuICAgICAqIC0ge0BsaW5rIFRZUEVfVUlOVDE2fVxuICAgICAqIC0ge0BsaW5rIFRZUEVfSU5UMzJ9XG4gICAgICogLSB7QGxpbmsgVFlQRV9VSU5UMzJ9XG4gICAgICogLSB7QGxpbmsgVFlQRV9GTE9BVDMyfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVzY3JpcHRpb25bXS5ub3JtYWxpemVdIC0gSWYgdHJ1ZSwgdmVydGV4IGF0dHJpYnV0ZSBkYXRhIHdpbGwgYmUgbWFwcGVkXG4gICAgICogZnJvbSBhIDAgdG8gMjU1IHJhbmdlIGRvd24gdG8gMCB0byAxIHdoZW4gZmVkIHRvIGEgc2hhZGVyLiBJZiBmYWxzZSwgdmVydGV4IGF0dHJpYnV0ZSBkYXRhXG4gICAgICogaXMgbGVmdCB1bmNoYW5nZWQuIElmIHRoaXMgcHJvcGVydHkgaXMgdW5zcGVjaWZpZWQsIGZhbHNlIGlzIGFzc3VtZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt2ZXJ0ZXhDb3VudF0gLSBXaGVuIHNwZWNpZmllZCwgdmVydGV4IGZvcm1hdCB3aWxsIGJlIHNldCB1cCBmb3JcbiAgICAgKiBub24taW50ZXJsZWF2ZWQgZm9ybWF0IHdpdGggYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHZlcnRpY2VzLiAoZXhhbXBsZTogUFBQUE5OTk5DQ0NDKSwgd2hlcmVcbiAgICAgKiBhcnJheXMgb2YgaW5kaXZpZHVhbCBhdHRyaWJ1dGVzIHdpbGwgYmUgc3RvcmVkIG9uZSByaWdodCBhZnRlciB0aGUgb3RoZXIgKHN1YmplY3QgdG9cbiAgICAgKiBhbGlnbm1lbnQgcmVxdWlyZW1lbnRzKS4gTm90ZSB0aGF0IGluIHRoaXMgY2FzZSwgdGhlIGZvcm1hdCBkZXBlbmRzIG9uIHRoZSBudW1iZXIgb2ZcbiAgICAgKiB2ZXJ0aWNlcywgYW5kIG5lZWRzIHRvIGNoYW5nZSB3aGVuIHRoZSBudW1iZXIgb2YgdmVydGljZXMgY2hhbmdlcy4gV2hlbiBub3Qgc3BlY2lmaWVkLFxuICAgICAqIHZlcnRleCBmb3JtYXQgd2lsbCBiZSBpbnRlcmxlYXZlZC4gKGV4YW1wbGU6IFBOQ1BOQ1BOQ1BOQykuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTcGVjaWZ5IDMtY29tcG9uZW50IHBvc2l0aW9ucyAoeCwgeSwgeilcbiAgICAgKiB2YXIgdmVydGV4Rm9ybWF0ID0gbmV3IHBjLlZlcnRleEZvcm1hdChncmFwaGljc0RldmljZSwgW1xuICAgICAqICAgICB7IHNlbWFudGljOiBwYy5TRU1BTlRJQ19QT1NJVElPTiwgY29tcG9uZW50czogMywgdHlwZTogcGMuVFlQRV9GTE9BVDMyIH1cbiAgICAgKiBdKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNwZWNpZnkgMi1jb21wb25lbnQgcG9zaXRpb25zICh4LCB5KSwgYSB0ZXh0dXJlIGNvb3JkaW5hdGUgKHUsIHYpIGFuZCBhIHZlcnRleCBjb2xvciAociwgZywgYiwgYSlcbiAgICAgKiB2YXIgdmVydGV4Rm9ybWF0ID0gbmV3IHBjLlZlcnRleEZvcm1hdChncmFwaGljc0RldmljZSwgW1xuICAgICAqICAgICB7IHNlbWFudGljOiBwYy5TRU1BTlRJQ19QT1NJVElPTiwgY29tcG9uZW50czogMiwgdHlwZTogcGMuVFlQRV9GTE9BVDMyIH0sXG4gICAgICogICAgIHsgc2VtYW50aWM6IHBjLlNFTUFOVElDX1RFWENPT1JEMCwgY29tcG9uZW50czogMiwgdHlwZTogcGMuVFlQRV9GTE9BVDMyIH0sXG4gICAgICogICAgIHsgc2VtYW50aWM6IHBjLlNFTUFOVElDX0NPTE9SLCBjb21wb25lbnRzOiA0LCB0eXBlOiBwYy5UWVBFX1VJTlQ4LCBub3JtYWxpemU6IHRydWUgfVxuICAgICAqIF0pO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdyYXBoaWNzRGV2aWNlLCBkZXNjcmlwdGlvbiwgdmVydGV4Q291bnQpIHtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSBncmFwaGljc0RldmljZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5oYXNVdjAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNVdjEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb2xvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1RhbmdlbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmVydGljZXNCeXRlU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudDtcbiAgICAgICAgdGhpcy5pbnRlcmxlYXZlZCA9IHZlcnRleENvdW50ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gdHJ1ZSBpZiB0aGUgdmVydGV4IGZvcm1hdCByZXByZXNlbnRzIGFuIGluc3RhbmNpbmcgdmVydGV4IGJ1ZmZlclxuICAgICAgICB0aGlzLmluc3RhbmNpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdG90YWwgc2l6ZSBvZiB0aGUgdmVydGV4XG4gICAgICAgIHRoaXMuc2l6ZSA9IGRlc2NyaXB0aW9uLnJlZHVjZSgodG90YWwsIGRlc2MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCArIE1hdGguY2VpbChkZXNjLmNvbXBvbmVudHMgKiB0eXBlZEFycmF5VHlwZXNCeXRlU2l6ZVtkZXNjLnR5cGVdIC8gNCkgKiA0O1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMCwgZWxlbWVudFNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkZXNjcmlwdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudERlc2MgPSBkZXNjcmlwdGlvbltpXTtcblxuICAgICAgICAgICAgZWxlbWVudFNpemUgPSBlbGVtZW50RGVzYy5jb21wb25lbnRzICogdHlwZWRBcnJheVR5cGVzQnl0ZVNpemVbZWxlbWVudERlc2MudHlwZV07XG5cbiAgICAgICAgICAgIC8vIFdlYkdQVSBoYXMgbGltaXRlZCBlbGVtZW50IHNpemUgc3VwcG9ydCAoZm9yIGV4YW1wbGUgdWludDE2eDMgaXMgbm90IHN1cHBvcnRlZClcbiAgICAgICAgICAgIERlYnVnLmFzc2VydChncmFwaGljc0RldmljZS5kZXZpY2VUeXBlICE9PSBERVZJQ0VUWVBFX1dFQkdQVSB8fCBbMiwgNCwgOCwgMTIsIDE2XS5pbmNsdWRlcyhlbGVtZW50U2l6ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgYFdlYkdQVSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmb3JtYXQgb2YgdmVydGV4IGVsZW1lbnQgJHtlbGVtZW50RGVzYy5zZW1hbnRpY30gOiAke3ZlcnRleFR5cGVzTmFtZXNbZWxlbWVudERlc2MudHlwZV19IHggJHtlbGVtZW50RGVzYy5jb21wb25lbnRzfWApO1xuXG4gICAgICAgICAgICAvLyBhbGlnbiB1cCB0aGUgb2Zmc2V0IHRvIGVsZW1lbnRTaXplICh3aGVuIHZlcnRleENvdW50IGlzIHNwZWNpZmllZCBvbmx5IC0gY2FzZSBvZiBub24taW50ZXJsZWF2ZWQgZm9ybWF0KVxuICAgICAgICAgICAgaWYgKHZlcnRleENvdW50KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF0aC5yb3VuZFVwKG9mZnNldCwgZWxlbWVudFNpemUpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm9uLWludGVybGVhdmVkIGZvcm1hdCB3aXRoIGVsZW1lbnRTaXplIG5vdCBtdWx0aXBsZSBvZiA0IG1pZ2h0IGJlIHNsb3dlciBvbiBzb21lIHBsYXRmb3JtcyAtIHBhZGRpbmcgaXMgcmVjb21tZW5kZWQgdG8gYWxpZ24gaXRzIHNpemVcbiAgICAgICAgICAgICAgICAvLyBleGFtcGxlOiB1c2UgNCB4IFRZUEVfVUlOVDggaW5zdGVhZCBvZiAzIHggVFlQRV9VSU5UOFxuICAgICAgICAgICAgICAgIERlYnVnLmFzc2VydCgoZWxlbWVudFNpemUgJSA0KSA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE5vbi1pbnRlcmxlYXZlZCB2ZXJ0ZXggZm9ybWF0IHdpdGggZWxlbWVudCBzaXplIG5vdCBtdWx0aXBsZSBvZiA0IGNhbiBoYXZlIHBlcmZvcm1hbmNlIGltcGFjdCBvbiBzb21lIHBsYXRmb3Jtcy4gRWxlbWVudCBzaXplOiAke2VsZW1lbnRTaXplfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnREZXNjLnNlbWFudGljLFxuICAgICAgICAgICAgICAgIG9mZnNldDogKHZlcnRleENvdW50ID8gb2Zmc2V0IDogKGVsZW1lbnREZXNjLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSA/IGVsZW1lbnREZXNjLm9mZnNldCA6IG9mZnNldCkpLFxuICAgICAgICAgICAgICAgIHN0cmlkZTogKHZlcnRleENvdW50ID8gZWxlbWVudFNpemUgOiAoZWxlbWVudERlc2MuaGFzT3duUHJvcGVydHkoJ3N0cmlkZScpID8gZWxlbWVudERlc2Muc3RyaWRlIDogdGhpcy5zaXplKSksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IGVsZW1lbnREZXNjLnR5cGUsXG4gICAgICAgICAgICAgICAgbnVtQ29tcG9uZW50czogZWxlbWVudERlc2MuY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBub3JtYWxpemU6IChlbGVtZW50RGVzYy5ub3JtYWxpemUgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVsZW1lbnREZXNjLm5vcm1hbGl6ZSxcbiAgICAgICAgICAgICAgICBzaXplOiBlbGVtZW50U2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhDb3VudCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBlbGVtZW50U2l6ZSAqIHZlcnRleENvdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gTWF0aC5jZWlsKGVsZW1lbnRTaXplIC8gNCkgKiA0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudERlc2Muc2VtYW50aWMgPT09IFNFTUFOVElDX1RFWENPT1JEMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzVXYwID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudERlc2Muc2VtYW50aWMgPT09IFNFTUFOVElDX1RFWENPT1JEMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzVXYxID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudERlc2Muc2VtYW50aWMgPT09IFNFTUFOVElDX0NPTE9SKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNDb2xvciA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnREZXNjLnNlbWFudGljID09PSBTRU1BTlRJQ19UQU5HRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNUYW5nZW50cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmVydGV4Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNCeXRlU2l6ZSA9IG9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2YWx1YXRlSGFzaCgpO1xuICAgIH1cblxuICAgIGdldCBlbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtWZXJ0ZXhGb3JtYXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2RlZmF1bHRJbnN0YW5jaW5nRm9ybWF0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgVmVydGV4Rm9ybWF0fSB1c2VkIHRvIHN0b3JlIG1hdHJpY2VzIG9mIHR5cGUge0BsaW5rIE1hdDR9IGZvciBoYXJkd2FyZSBpbnN0YW5jaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGdyYXBoaWNzRGV2aWNlIC0gVGhlIGdyYXBoaWNzIGRldmljZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIHRoaXMgdmVydGV4IGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJ0ZXhGb3JtYXR9IFRoZSBkZWZhdWx0IGluc3RhbmNpbmcgdmVydGV4IGZvcm1hdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEluc3RhbmNpbmdGb3JtYXQoZ3JhcGhpY3NEZXZpY2UpIHtcblxuICAgICAgICBpZiAoIVZlcnRleEZvcm1hdC5fZGVmYXVsdEluc3RhbmNpbmdGb3JtYXQpIHtcbiAgICAgICAgICAgIFZlcnRleEZvcm1hdC5fZGVmYXVsdEluc3RhbmNpbmdGb3JtYXQgPSBuZXcgVmVydGV4Rm9ybWF0KGdyYXBoaWNzRGV2aWNlLCBbXG4gICAgICAgICAgICAgICAgeyBzZW1hbnRpYzogU0VNQU5USUNfQVRUUjEyLCBjb21wb25lbnRzOiA0LCB0eXBlOiBUWVBFX0ZMT0FUMzIgfSxcbiAgICAgICAgICAgICAgICB7IHNlbWFudGljOiBTRU1BTlRJQ19BVFRSMTMsIGNvbXBvbmVudHM6IDQsIHR5cGU6IFRZUEVfRkxPQVQzMiB9LFxuICAgICAgICAgICAgICAgIHsgc2VtYW50aWM6IFNFTUFOVElDX0FUVFIxNCwgY29tcG9uZW50czogNCwgdHlwZTogVFlQRV9GTE9BVDMyIH0sXG4gICAgICAgICAgICAgICAgeyBzZW1hbnRpYzogU0VNQU5USUNfQVRUUjE1LCBjb21wb25lbnRzOiA0LCB0eXBlOiBUWVBFX0ZMT0FUMzIgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVmVydGV4Rm9ybWF0Ll9kZWZhdWx0SW5zdGFuY2luZ0Zvcm1hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIFZlcnRleEZvcm1hdCdzIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgdXNlZCBvbmx5IGJ5IHZlcnRleCBhdHRyaWJ1dGUgbW9ycGhpbmcgb24gdGhlIFdlYkdMLlxuICAgICAgICBEZWJ1Zy5hc3NlcnQodGhpcy5kZXZpY2UuZGV2aWNlVHlwZSA9PT0gREVWSUNFVFlQRV9XRUJHTCwgYFZlcnRleEZvcm1hdCN1cGRhdGUgaXMgbm90IHN1cHBvcnRlZCBvbiBXZWJHUFUgYW5kIFZlcnRleEZvcm1hdCBjYW5ub3QgYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRlSGFzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBoYXNoIHZhbHVlcyBmb3IgdGhlIGZvcm1hdCBhbGxvd2luZyBmYXN0IGNvbXBhcmUgb2YgYmF0Y2hpbmcgLyByZW5kZXJpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V2YWx1YXRlSGFzaCgpIHtcbiAgICAgICAgbGV0IHN0cmluZ0VsZW1lbnRCYXRjaDtcbiAgICAgICAgY29uc3Qgc3RyaW5nRWxlbWVudHNCYXRjaCA9IFtdO1xuICAgICAgICBsZXQgc3RyaW5nRWxlbWVudFJlbmRlcjtcbiAgICAgICAgY29uc3Qgc3RyaW5nRWxlbWVudHNSZW5kZXIgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudHNbaV07XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzdHJpbmcgZGVzY3JpcHRpb24gb2YgZWFjaCBlbGVtZW50IHRoYXQgaXMgcmVsZXZhbnQgZm9yIGJhdGNoaW5nXG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50QmF0Y2ggPSBlbGVtZW50Lm5hbWU7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50QmF0Y2ggKz0gZWxlbWVudC5kYXRhVHlwZTtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRCYXRjaCArPSBlbGVtZW50Lm51bUNvbXBvbmVudHM7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50QmF0Y2ggKz0gZWxlbWVudC5ub3JtYWxpemU7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50c0JhdGNoLnB1c2goc3RyaW5nRWxlbWVudEJhdGNoKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHN0cmluZyBkZXNjcmlwdGlvbiBvZiBlYWNoIGVsZW1lbnQgdGhhdCBpcyByZWxldmFudCBmb3IgcmVuZGVyaW5nXG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50UmVuZGVyID0gc3RyaW5nRWxlbWVudEJhdGNoO1xuICAgICAgICAgICAgc3RyaW5nRWxlbWVudFJlbmRlciArPSBlbGVtZW50Lm9mZnNldDtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRSZW5kZXIgKz0gZWxlbWVudC5zdHJpZGU7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50UmVuZGVyICs9IGVsZW1lbnQuc2l6ZTtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRzUmVuZGVyLnB1c2goc3RyaW5nRWxlbWVudFJlbmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3J0IGJhdGNoaW5nIG9uZXMgYWxwaGFiZXRpY2FsbHkgdG8gbWFrZSB0aGUgaGFzaCBvcmRlciBpbmRlcGVuZGVudFxuICAgICAgICBzdHJpbmdFbGVtZW50c0JhdGNoLnNvcnQoKTtcbiAgICAgICAgdGhpcy5iYXRjaGluZ0hhc2ggPSBoYXNoQ29kZShzdHJpbmdFbGVtZW50c0JhdGNoLmpvaW4oKSk7XG5cbiAgICAgICAgLy8gcmVuZGVyaW5nIGhhc2hcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdpbmdIYXNoU3RyaW5nID0gc3RyaW5nRWxlbWVudHNSZW5kZXIuam9pbignXycpO1xuICAgICAgICB0aGlzLnJlbmRlcmluZ2luZ0hhc2ggPSBoYXNoQ29kZSh0aGlzLnJlbmRlcmluZ2luZ0hhc2hTdHJpbmcpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVmVydGV4Rm9ybWF0IH07XG4iXSwibmFtZXMiOlsiVmVydGV4Rm9ybWF0IiwiY29uc3RydWN0b3IiLCJncmFwaGljc0RldmljZSIsImRlc2NyaXB0aW9uIiwidmVydGV4Q291bnQiLCJkZXZpY2UiLCJfZWxlbWVudHMiLCJoYXNVdjAiLCJoYXNVdjEiLCJoYXNDb2xvciIsImhhc1RhbmdlbnRzIiwidmVydGljZXNCeXRlU2l6ZSIsImludGVybGVhdmVkIiwidW5kZWZpbmVkIiwiaW5zdGFuY2luZyIsInNpemUiLCJyZWR1Y2UiLCJ0b3RhbCIsImRlc2MiLCJNYXRoIiwiY2VpbCIsImNvbXBvbmVudHMiLCJ0eXBlZEFycmF5VHlwZXNCeXRlU2l6ZSIsInR5cGUiLCJvZmZzZXQiLCJlbGVtZW50U2l6ZSIsImkiLCJsZW4iLCJsZW5ndGgiLCJlbGVtZW50RGVzYyIsIkRlYnVnIiwiYXNzZXJ0IiwiZGV2aWNlVHlwZSIsIkRFVklDRVRZUEVfV0VCR1BVIiwiaW5jbHVkZXMiLCJzZW1hbnRpYyIsInZlcnRleFR5cGVzTmFtZXMiLCJtYXRoIiwicm91bmRVcCIsImVsZW1lbnQiLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJzdHJpZGUiLCJkYXRhVHlwZSIsIm51bUNvbXBvbmVudHMiLCJub3JtYWxpemUiLCJwdXNoIiwiU0VNQU5USUNfVEVYQ09PUkQwIiwiU0VNQU5USUNfVEVYQ09PUkQxIiwiU0VNQU5USUNfQ09MT1IiLCJTRU1BTlRJQ19UQU5HRU5UIiwiX2V2YWx1YXRlSGFzaCIsImVsZW1lbnRzIiwiZ2V0RGVmYXVsdEluc3RhbmNpbmdGb3JtYXQiLCJfZGVmYXVsdEluc3RhbmNpbmdGb3JtYXQiLCJTRU1BTlRJQ19BVFRSMTIiLCJUWVBFX0ZMT0FUMzIiLCJTRU1BTlRJQ19BVFRSMTMiLCJTRU1BTlRJQ19BVFRSMTQiLCJTRU1BTlRJQ19BVFRSMTUiLCJ1cGRhdGUiLCJERVZJQ0VUWVBFX1dFQkdMIiwic3RyaW5nRWxlbWVudEJhdGNoIiwic3RyaW5nRWxlbWVudHNCYXRjaCIsInN0cmluZ0VsZW1lbnRSZW5kZXIiLCJzdHJpbmdFbGVtZW50c1JlbmRlciIsInNvcnQiLCJiYXRjaGluZ0hhc2giLCJoYXNoQ29kZSIsImpvaW4iLCJyZW5kZXJpbmdpbmdIYXNoU3RyaW5nIiwicmVuZGVyaW5naW5nSGFzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLFlBQVksQ0FBQztBQUNmO0FBQ0o7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
