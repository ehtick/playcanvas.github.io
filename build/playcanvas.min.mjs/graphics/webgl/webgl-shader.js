import"../../core/tracing.js";import"../../core/time.js";import{ShaderInput as e}from"../shader-input.js";import{semanticToLocation as r}from"../constants.js";class t{constructor(e){this.init(),this.compileAndLink(e.device,e),e.device.shaders.push(e)}destroy(e){const r=e.device,t=r.shaders.indexOf(e);-1!==t&&r.shaders.splice(t,1),this.glProgram&&(r.gl.deleteProgram(this.glProgram),this.glProgram=null,r.removeShaderFromCache(e))}init(){this.uniforms=[],this.samplers=[],this.attributes=[],this.glProgram=null,this.glVertexShader=null,this.glFragmentShader=null}loseContext(){this.init()}restoreContext(e,r){this.compileAndLink(e,r)}compileAndLink(e,t){const i=t.definition,s=this._compileShaderSource(e,i.vshader,!0),o=this._compileShaderSource(e,i.fshader,!1),a=e.gl,n=a.createProgram();a.attachShader(n,s),a.attachShader(n,o);const h=i.attributes;if(e.webgl2&&i.useTransformFeedback){const e=[];for(const r in h)h.hasOwnProperty(r)&&e.push("out_"+r);a.transformFeedbackVaryings(n,e,a.INTERLEAVED_ATTRIBS)}for(const e in h)if(h.hasOwnProperty(e)){const t=h[e],i=r[t];a.bindAttribLocation(n,i,e)}a.linkProgram(n),this.glVertexShader=s,this.glFragmentShader=o,this.glProgram=n}_compileShaderSource(e,r,t){const i=e.gl,s=t?e.vertexShaderCache:e.fragmentShaderCache;let o=s[r];return o||(o=i.createShader(t?i.VERTEX_SHADER:i.FRAGMENT_SHADER),i.shaderSource(o,r),i.compileShader(o),s[r]=o),o}postLink(r,t){const i=r.gl,s=this.glProgram,o=t.definition;if(!this._isCompiled(r,t,this.glVertexShader,o.vshader,"vertex"))return!1;if(!this._isCompiled(r,t,this.glFragmentShader,o.fshader,"fragment"))return!1;if(!i.getProgramParameter(s,i.LINK_STATUS)){const e="Failed to link shader program. Error: "+i.getProgramInfoLog(s);return console.error(e),!1}let a,n,h,m;a=0;const c=i.getProgramParameter(s,i.ACTIVE_ATTRIBUTES);for(;a<c;)n=i.getActiveAttrib(s,a++),h=i.getAttribLocation(s,n.name),void 0===o.attributes[n.name]&&console.error(`Vertex shader attribute "${n.name}" is not mapped to a semantic in shader definition.`),m=new e(r,o.attributes[n.name],r.pcUniformType[n.type],h),this.attributes.push(m);a=0;const l=i.getProgramParameter(s,i.ACTIVE_UNIFORMS);for(;a<l;)n=i.getActiveUniform(s,a++),h=i.getUniformLocation(s,n.name),m=new e(r,n.name,r.pcUniformType[n.type],h),n.type===i.SAMPLER_2D||n.type===i.SAMPLER_CUBE||r.webgl2&&(n.type===i.SAMPLER_2D_SHADOW||n.type===i.SAMPLER_CUBE_SHADOW||n.type===i.SAMPLER_3D)?this.samplers.push(m):this.uniforms.push(m);return t.ready=!0,!0}_isCompiled(e,r,t,i,s){const o=e.gl;if(!o.getShaderParameter(t,o.COMPILE_STATUS)){const e=o.getShaderInfoLog(t),[r,a]=this._processError(i,e),n=`Failed to compile ${s} shader:\n\n${e}\n${r}`;return console.error(n),!1}return!0}_processError(e,r){const t={};let i="";if(e){const s=e.split("\n");let o=0,a=s.length;if(r&&r.startsWith("ERROR:")){const e=r.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);e&&(t.message=e[3],t.line=parseInt(e[2],10),o=Math.max(0,t.line-6),a=Math.min(s.length,t.line+5))}for(let e=o;e<a;e++)i+=e+1+":\t"+s[e]+"\n";t.source=e}return[i,t]}}export{t as WebglShader};
