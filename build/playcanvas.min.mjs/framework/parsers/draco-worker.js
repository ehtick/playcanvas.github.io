function e(e,t){let r;const n=(e,t)=>{switch(t){case r.DT_INT8:return new Int8Array(e.buffer,e.byteOffset,e.byteLength);case r.DT_INT16:return new Int16Array(e.buffer,e.byteOffset,e.byteLength/2);case r.DT_INT32:return new Int32Array(e.buffer,e.byteOffset,e.byteLength/4);case r.DT_UINT8:return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);case r.DT_UINT16:return new Uint16Array(e.buffer,e.byteOffset,e.byteLength/2);case r.DT_UINT32:return new Uint32Array(e.buffer,e.byteOffset,e.byteLength/4);case r.DT_FLOAT32:return new Float32Array(e.buffer,e.byteOffset,e.byteLength/4)}return null},s=e=>e.num_components()*(e=>{switch(e){case r.DT_INT8:return 1;case r.DT_INT16:return 2;case r.DT_INT32:return 4;case r.DT_UINT8:return 1;case r.DT_UINT16:return 2;case r.DT_UINT32:case r.DT_FLOAT32:return 4}return 1})(e.data_type()),a={0:0,1:1,5:2,2:3,7:4,8:5,4:6,3:7},o=(e,t)=>{const r=(e,t,r)=>{e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2]},n=(e,t,r)=>{e[0]=t[1]*r[2]-r[1]*t[2],e[1]=t[2]*r[0]-r[2]*t[0],e[2]=t[0]*r[1]-r[0]*t[1]},s=(e,t)=>{const r=e[t+0],n=e[t+1],s=e[t+2],a=1/Math.sqrt(r*r+n*n+s*s);e[t+0]*=a,e[t+1]*=a,e[t+2]*=a},a=(e,t,r)=>{for(let n=0;n<3;++n)e[n]=t[r+n]},o=t.length/3,f=e.length/3,c=new Float32Array(e.length),i=[0,0,0],u=[0,0,0],l=[0,0,0],y=[0,0,0],b=[0,0,0],d=[0,0,0];for(let f=0;f<o;++f){const o=3*t[3*f+0],_=3*t[3*f+1],T=3*t[3*f+2];a(i,e,o),a(u,e,_),a(l,e,T),r(y,u,i),r(b,l,i),n(d,y,b),s(d,0);for(let e=0;e<3;++e)c[o+e]+=d[e],c[_+e]+=d[e],c[T+e]+=d[e]}for(let e=0;e<f;++e)s(c,3*e);return new Uint8Array(c.buffer)},f=e=>{const t=(e=>{const t={},f=new r.DecoderBuffer;f.Init(e,e.length);const c=new r.Decoder;if(c.GetEncodedGeometryType(f)!==r.TRIANGULAR_MESH)return t.error="Failed to decode draco mesh: not a mesh",t;const i=new r.Mesh,u=c.DecodeBufferToMesh(f,i);if(!u||!u.ok()||0===i.ptr)return t.error="Failed to decode draco asset",t;const l=3*i.num_faces(),y=i.num_points()<=65535,b=l*(y?2:4),d=r._malloc(b);y?(c.GetTrianglesUInt16Array(i,b,d),t.indices=new Uint16Array(r.HEAPU16.buffer,d,l).slice().buffer):(c.GetTrianglesUInt32Array(i,b,d),t.indices=new Uint32Array(r.HEAPU32.buffer,d,l).slice().buffer),r._free(d);const _=[];for(let e=0;e<i.num_attributes();++e)_.push(c.GetAttribute(i,e));_.sort(((e,t)=>{var r,n;return(null!=(r=a[e.attribute_type()])?r:a.length)-(null!=(n=a[t.attribute_type()])?n:a.length)}));let T=0;const A=_.map((e=>{const t=T;return T+=4*Math.ceil(s(e)/4),t})),h=_.some((e=>1===e.attribute_type())),w=A[1];if(!h){for(let e=1;e<A.length;++e)A[e]+=12;T+=12}t.vertices=new ArrayBuffer(i.num_points()*T);const U=new Uint8Array(t.vertices);for(let e=0;e<i.num_attributes();++e){const a=_[e],f=s(a),u=i.num_points()*f,l=r._malloc(u);c.GetAttributeDataArrayForAllPoints(i,a,a.data_type(),u,l);const b=new Uint8Array(r.HEAPU8.buffer,l,u);for(let t=0;t<i.num_points();++t)for(let r=0;r<f;++r)U[t*T+A[e]+r]=b[t*f+r];if(!h&&0===a.attribute_type()){const e=o(n(b,a.data_type()),y?new Uint16Array(t.indices):new Uint32Array(t.indices));for(let t=0;t<i.num_points();++t)for(let r=0;r<12;++r)U[t*T+w+r]=e[12*t+r]}r._free(l)}return r.destroy(i),r.destroy(c),r.destroy(f),t})(new Uint8Array(e.buffer));self.postMessage({jobId:e.jobId,error:t.error,indices:t.indices,vertices:t.vertices},[t.indices,t.vertices].filter((e=>null!=e)))},c=[];self.onmessage=e=>{const t=e.data;switch(t.type){case"init":self.DracoDecoderModule({instantiateWasm:(e,r)=>(WebAssembly.instantiate(t.module,e).then((e=>r(e))).catch((e=>console.error("instantiate failed + "+e))),{})}).then((e=>{r=e,c.forEach((e=>f(e)))}));break;case"decodeMesh":r?f(t):c.push(t)}}}export{e as DracoWorker};
