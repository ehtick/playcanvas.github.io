import{FILTER_NEAREST as e,ADDRESS_CLAMP_TO_EDGE as t,PIXELFORMAT_R8_G8_B8_A8 as s}from"../../../graphics/constants.js";import{RenderTarget as r}from"../../../graphics/render-target.js";import{Texture as i}from"../../../graphics/texture.js";import{LAYERID_DEPTH as a}from"../../../scene/constants.js";class h{constructor(e,t){this.effect=e,this.inputTarget=t,this.outputTarget=null,this.name=e.constructor.name}}class f{constructor(e,t){this.app=e,this.camera=t,this.destinationRenderTarget=null,this.effects=[],this.enabled=!1,this.depthTarget=null,t.on("set:rect",this.onCameraRectChanged,this)}_allocateColorBuffer(s,r){const a=this.camera.rect,h=Math.floor(a.z*this.app.graphicsDevice.width),f=Math.floor(a.w*this.app.graphicsDevice.height);return new i(this.app.graphicsDevice,{name:r,format:s,width:h,height:f,mipmaps:!1,minFilter:e,magFilter:e,addressU:t,addressV:t})}_createOffscreenTarget(e,t){const i=this.app.graphicsDevice,a=t?i.getHdrFormat():s,h=this.camera.entity.name+"-posteffect-"+this.effects.length,f=this._allocateColorBuffer(a,h);return new r({colorBuffer:f,depth:e,stencil:e&&this.app.graphicsDevice.supportsStencil,samples:e?i.samples:1})}_resizeOffscreenTarget(e){const t=e.colorBuffer.format,s=e.colorBuffer.name;e.destroyFrameBuffers(),e.destroyTextureBuffers(),e._colorBuffer=this._allocateColorBuffer(t,s)}_destroyOffscreenTarget(e){e.destroyTextureBuffers(),e.destroy()}addEffect(e){const t=this.effects,s=0===t.length,r=this._createOffscreenTarget(s,e.hdr),i=new h(e,r);t.push(i),this._sourceTarget=i.inputTarget,t.length>1&&(t[t.length-2].outputTarget=i.inputTarget),this._newPostEffect=e,e.needsDepthBuffer&&this._requestDepthMap(),this.enable(),this._newPostEffect=void 0}removeEffect(e){let t=-1;for(let s=0,r=this.effects.length;s<r;s++)if(this.effects[s].effect===e){t=s;break}t>=0&&(t>0?this.effects[t-1].outputTarget=t+1<this.effects.length?this.effects[t+1].inputTarget:null:this.effects.length>1&&(this.effects[1].inputTarget._depth||(this._destroyOffscreenTarget(this.effects[1].inputTarget),this.effects[1].inputTarget=this._createOffscreenTarget(!0,this.effects[1].hdr),this._sourceTarget=this.effects[1].inputTarget),this.camera.renderTarget=this.effects[1].inputTarget),this._destroyOffscreenTarget(this.effects[t].inputTarget),this.effects.splice(t,1)),this.enabled&&e.needsDepthBuffer&&this._releaseDepthMap(),0===this.effects.length&&this.disable()}_requestDepthMaps(){for(let e=0,t=this.effects.length;e<t;e++){const t=this.effects[e].effect;this._newPostEffect!==t&&(t.needsDepthBuffer&&this._requestDepthMap())}}_releaseDepthMaps(){for(let e=0,t=this.effects.length;e<t;e++){this.effects[e].effect.needsDepthBuffer&&this._releaseDepthMap()}}_requestDepthMap(){const e=this.app.scene.layers.getLayerById(a);e&&(e.incrementCounter(),this.camera.requestSceneDepthMap(!0))}_releaseDepthMap(){const e=this.app.scene.layers.getLayerById(a);e&&(e.decrementCounter(),this.camera.requestSceneDepthMap(!1))}destroy(){for(let e=0,t=this.effects.length;e<t;e++)this.effects[e].inputTarget.destroy();this.effects.length=0,this.disable()}enable(){!this.enabled&&this.effects.length&&(this.enabled=!0,this._requestDepthMaps(),this.app.graphicsDevice.on("resizecanvas",this._onCanvasResized,this),this.destinationRenderTarget=this.camera.renderTarget,this.camera.renderTarget=this.effects[0].inputTarget,this.camera.onPostprocessing=()=>{if(this.enabled){let e=null;const t=this.effects.length;if(t)for(let s=0;s<t;s++){const r=this.effects[s];let i=r.outputTarget;s===t-1&&(e=this.camera.rect,this.destinationRenderTarget&&(i=this.destinationRenderTarget)),r.effect.render(r.inputTarget,i,e)}}})}disable(){this.enabled&&(this.enabled=!1,this.app.graphicsDevice.off("resizecanvas",this._onCanvasResized,this),this._releaseDepthMaps(),this._destroyOffscreenTarget(this._sourceTarget),this.camera.renderTarget=null,this.camera.onPostprocessing=null)}_onCanvasResized(e,t){const s=this.camera.rect,r=this.app.graphicsDevice;this.camera.camera.aspectRatio=r.width*s.z/(r.height*s.w),this.resizeRenderTargets()}resizeRenderTargets(){const e=this.camera.rect,t=Math.floor(e.z*this.app.graphicsDevice.width),s=Math.floor(e.w*this.app.graphicsDevice.height),r=this.effects;for(let e=0,i=r.length;e<i;e++){const i=r[e];i.inputTarget.width===t&&i.inputTarget.height===s||this._resizeOffscreenTarget(i.inputTarget)}}onCameraRectChanged(e,t,s){this.enabled&&this.resizeRenderTargets()}}export{f as PostEffectQueue};
