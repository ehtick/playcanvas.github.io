import"../../core/tracing.js";import"../../core/time.js";import{Vec3 as e}from"../../core/math/vec3.js";import{Mat3 as t}from"../../core/math/mat3.js";import{Mat4 as s}from"../../core/math/mat4.js";import{BoundingSphere as r}from"../../core/shape/bounding-sphere.js";import{SORTKEY_FORWARD as i,SORTKEY_DEPTH as a,VIEW_CENTER as o,PROJECTION_ORTHOGRAPHIC as n,LIGHTTYPE_DIRECTIONAL as l,SHADOWUPDATE_NONE as h,LIGHTTYPE_SPOT as c,LIGHTTYPE_OMNI as d}from"../constants.js";import{LightTextureAtlas as p}from"../lighting/light-texture-atlas.js";import{Material as m}from"../materials/material.js";import{CLEARFLAG_COLOR as u,CLEARFLAG_DEPTH as f,CLEARFLAG_STENCIL as w,DEVICETYPE_WEBGPU as g,CULLFACE_NONE as v,CULLFACE_FRONTANDBACK as _,CULLFACE_FRONT as x,CULLFACE_BACK as M,UNIFORMTYPE_MAT4 as I,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as C,SHADERSTAGE_VERTEX as y,SHADERSTAGE_FRAGMENT as T,TEXTUREDIMENSION_2D as V,SAMPLETYPE_UNFILTERABLE_FLOAT as S,BINDGROUP_VIEW as b,SEMANTIC_ATTR as P}from"../../platform/graphics/constants.js";import{UniformBuffer as j}from"../../platform/graphics/uniform-buffer.js";import{BindGroup as F}from"../../platform/graphics/bind-group.js";import{UniformBufferFormat as B,UniformFormat as k}from"../../platform/graphics/uniform-buffer-format.js";import{BindGroupFormat as L,BindBufferFormat as R,BindTextureFormat as O}from"../../platform/graphics/bind-group-format.js";import{ShadowMapCache as D}from"./shadow-map-cache.js";import{ShadowRendererLocal as U}from"./shadow-renderer-local.js";import{ShadowRendererDirectional as z}from"./shadow-renderer-directional.js";import{CookieRenderer as A}from"./cookie-renderer.js";import{StaticMeshes as G}from"./static-meshes.js";let W=0;const N=[0,0,0,0],E=new s,Y=new s,q=new s,X=new e,Z=new e,H=new e,J=new t,K=new r,Q=(new s).setScale(1,-1,1),$=(new s).set([1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1]),ee=new s,te=new s,se=new s,re=new s,ie=new Set;class ae{constructor(e){this.clustersDebugRendered=!1,this.device=e,this.scene=null,this.lightTextureAtlas=new p(e),this.shadowMapCache=new D,this._shadowRendererLocal=new U(this,this.lightTextureAtlas),this._shadowRendererDirectional=new z(this,this.lightTextureAtlas),this._cookieRenderer=new A(e,this.lightTextureAtlas),this.viewUniformFormat=null,this.viewBindGroupFormat=null,this._skinTime=0,this._morphTime=0,this._cullTime=0,this._shadowMapTime=0,this._lightClustersTime=0,this._layerCompositionUpdateTime=0,this._shadowDrawCalls=0,this._skinDrawCalls=0,this._instancedDrawCalls=0,this._shadowMapUpdates=0,this._numDrawCallsCulled=0,this._camerasRendered=0,this._lightClusters=0;const t=e.scope;this.boneTextureId=t.resolve("texture_poseMap"),this.boneTextureSizeId=t.resolve("texture_poseMapSize"),this.poseMatrixId=t.resolve("matrix_pose[0]"),this.modelMatrixId=t.resolve("matrix_model"),this.normalMatrixId=t.resolve("matrix_normal"),this.viewInvId=t.resolve("matrix_viewInverse"),this.viewPos=new Float32Array(3),this.viewPosId=t.resolve("view_position"),this.projId=t.resolve("matrix_projection"),this.projSkyboxId=t.resolve("matrix_projectionSkybox"),this.viewId=t.resolve("matrix_view"),this.viewId3=t.resolve("matrix_view3"),this.viewProjId=t.resolve("matrix_viewProjection"),this.flipYId=t.resolve("projectionFlipY"),this.tbnBasis=t.resolve("tbnBasis"),this.nearClipId=t.resolve("camera_near"),this.farClipId=t.resolve("camera_far"),this.cameraParams=new Float32Array(4),this.cameraParamsId=t.resolve("camera_params"),this.alphaTestId=t.resolve("alpha_ref"),this.opacityMapId=t.resolve("texture_opacityMap"),this.exposureId=t.resolve("exposure"),this.twoSidedLightingNegScaleFactorId=t.resolve("twoSidedLightingNegScaleFactor"),this.morphWeightsA=t.resolve("morph_weights_a"),this.morphWeightsB=t.resolve("morph_weights_b"),this.morphPositionTex=t.resolve("morphPositionTex"),this.morphNormalTex=t.resolve("morphNormalTex"),this.morphTexParams=t.resolve("morph_tex_params")}destroy(){this._shadowRendererLocal=null,this._shadowRendererDirectional=null,this.shadowMapCache.destroy(),this.shadowMapCache=null,this._cookieRenderer.destroy(),this._cookieRenderer=null,this.lightTextureAtlas.destroy(),this.lightTextureAtlas=null}sortCompare(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist;if(e.zdist2&&t.zdist2)return e.zdist2-t.zdist2}return t._key[i]-e._key[i]}sortCompareMesh(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist}const s=e._key[i],r=t._key[i];return s===r&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:r-s}sortCompareDepth(e,t){const s=e._key[a],r=t._key[a];return s===r&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:r-s}setupViewport(e,t){const s=this.device,r=t?t.width:s.width,i=t?t.height:s.height,a=e.rect;let o=Math.floor(a.x*r),n=Math.floor(a.y*i),l=Math.floor(a.z*r),h=Math.floor(a.w*i);if(s.setViewport(o,n,l,h),e._scissorRectClear){const t=e.scissorRect;o=Math.floor(t.x*r),n=Math.floor(t.y*i),l=Math.floor(t.z*r),h=Math.floor(t.w*i)}s.setScissor(o,n,l,h)}clear(e,t){const s=(e.clearColor?u:0)|(e.clearDepth?f:0)|(e.clearStencil?w:0);if(s){this.device.clear({color:[t._clearColor.r,t._clearColor.g,t._clearColor.b,t._clearColor.a],depth:t._clearDepth,stencil:t._clearStencil,flags:s})}}setCameraUniforms(t,s,r){const i=null==s?void 0:s.flipY;let a=1;if(t.xr&&t.xr.session){let e;const s=t._node.parent;s&&(e=s.getWorldTransform());const r=t.xr.views;a=r.length;for(let i=0;i<a;i++){const a=r[i];s?(a.viewInvOffMat.mul2(e,a.viewInvMat),a.viewOffMat.copy(a.viewInvOffMat).invert()):(a.viewInvOffMat.copy(a.viewInvMat),a.viewOffMat.copy(a.viewMat)),a.viewMat3.setFromMat4(a.viewOffMat),a.projViewOffMat.mul2(a.projMat,a.viewOffMat),a.position[0]=a.viewInvOffMat.data[12],a.position[1]=a.viewInvOffMat.data[13],a.position[2]=a.viewInvOffMat.data[14],t.frustum.setFromMat4(a.projViewOffMat)}}else{let s=t.projectionMatrix;t.calculateProjection&&t.calculateProjection(s,o);let r=t.getProjectionMatrixSkybox();if(i&&(s=ee.mul2(Q,s),r=te.mul2(Q,r)),this.device.deviceType===g&&(s=se.mul2($,s),r=re.mul2($,r)),this.projId.setValue(s.data),this.projSkyboxId.setValue(r.data),t.calculateTransform)t.calculateTransform(Y,o);else{const s=t._node.getPosition(),r=t._node.getRotation();Y.setTRS(s,r,e.ONE)}this.viewInvId.setValue(Y.data),q.copy(Y).invert(),this.viewId.setValue(q.data),J.setFromMat4(q),this.viewId3.setValue(J.data),E.mul2(s,q),this.viewProjId.setValue(E.data),this.flipYId.setValue(i?-1:1),this.dispatchViewPos(t._node.getPosition()),t.frustum.setFromMat4(E)}this.tbnBasis.setValue(i?-1:1);const l=t._nearClip,h=t._farClip;this.nearClipId.setValue(l),this.farClipId.setValue(h),this.cameraParams[0]=1/h,this.cameraParams[1]=h,this.cameraParams[2]=l,this.cameraParams[3]=t.projection===n?1:0,this.cameraParamsId.setValue(this.cameraParams),this.exposureId.setValue(this.scene.physicalUnits?t.getExposure():this.scene.exposure),this.device.supportsUniformBuffers&&this.setupViewUniformBuffers(r,a)}setCamera(e,t,s,r=null){this.setCameraUniforms(e,t,r),this.clearView(e,t,s,!1)}clearView(e,t,s,r){const i=this.device;if(i.setRenderTarget(t),i.updateBegin(),r&&(i.setColorWrite(!0,!0,!0,!0),i.setDepthWrite(!0)),this.setupViewport(e,t),s){const t=e._clearOptions;i.clear(t||{color:[e._clearColor.r,e._clearColor.g,e._clearColor.b,e._clearColor.a],depth:e._clearDepth,flags:(e._clearColorBuffer?u:0)|(e._clearDepthBuffer?f:0)|(e._clearStencilBuffer?w:0),stencil:e._clearStencil})}}setCullMode(e,t,s){const r=s.material;let i=v;if(e){let e=1;if(r.cull>v&&r.cull<_){s.flipFaces&&(e*=-1),t&&(e*=-1);const r=s.node.worldTransform;r.getX(X),r.getY(Z),r.getZ(H),X.cross(X,Z),X.dot(H)<0&&(e*=-1)}i=e<0?r.cull===x?M:x:r.cull}if(this.device.setCullMode(i),i===v&&r.cull===v){const e=s.node.worldTransform;e.getX(X),e.getY(Z),e.getZ(H),X.cross(X,Z),this.twoSidedLightingNegScaleFactorId.setValue(X.dot(H)<0?-1:1)}}updateCameraFrustum(t){if(t.xr&&t.xr.views.length){const e=t.xr.views[0];return E.mul2(e.projMat,e.viewOffMat),void t.frustum.setFromMat4(E)}const s=t.projectionMatrix;if(t.calculateProjection&&t.calculateProjection(s,o),t.calculateTransform)t.calculateTransform(Y,o);else{const s=t._node.getPosition(),r=t._node.getRotation();Y.setTRS(s,r,e.ONE),this.viewInvId.setValue(Y.data)}q.copy(Y).invert(),E.mul2(s,q),t.frustum.setFromMat4(E)}setBaseConstants(e,t){e.setCullMode(t.cull),t.opacityMap&&(this.opacityMapId.setValue(t.opacityMap),this.alphaTestId.setValue(t.alphaTest))}updateCpuSkinMatrices(e){W++;const t=e.length;if(0!==t)for(let s=0;s<t;s++){const t=e[s].skinInstance;t&&(t.updateMatrices(e[s].node,W),t._dirty=!0)}}updateGpuSkinMatrices(e){const t=e.length;for(let s=0;s<t;s++){const t=e[s];if(t.visibleThisFrame){const e=t.skinInstance;e&&e._dirty&&(e.updateMatrixPalette(t.node,W),e._dirty=!1)}}}updateMorphing(e){const t=e.length;for(let s=0;s<t;s++){const t=e[s],r=t.morphInstance;r&&r._dirty&&t.visibleThisFrame&&r.update()}}gpuUpdate(e){this.updateGpuSkinMatrices(e),this.updateMorphing(e)}setVertexBuffers(e,t){e.setVertexBuffer(t.vertexBuffer)}setMorphing(e,t){if(t)if(t.morph.useTextureMorph)e.setVertexBuffer(t.morph.vertexBufferIds),this.morphPositionTex.setValue(t.texturePositions),this.morphNormalTex.setValue(t.textureNormals),this.morphTexParams.setValue(t._textureParams);else{for(let s=0;s<t._activeVertexBuffers.length;s++){const r=t._activeVertexBuffers[s];if(r){const t=P+(s+8);r.format.elements[0].name=t,r.format.elements[0].scopeId=e.scope.resolve(t),r.format.update(),e.setVertexBuffer(r)}}this.morphWeightsA.setValue(t._shaderMorphWeightsA),this.morphWeightsB.setValue(t._shaderMorphWeightsB)}}setSkinning(e,t){if(t.skinInstance)if(this._skinDrawCalls++,e.supportsBoneTextures){const e=t.skinInstance.boneTexture;this.boneTextureId.setValue(e),N[0]=e.width,N[1]=e.height,N[2]=1/e.width,N[3]=1/e.height,this.boneTextureSizeId.setValue(N)}else this.poseMatrixId.setValue(t.skinInstance.matrixPalette)}dispatchViewPos(e){const t=this.viewPos;t[0]=e.x,t[1]=e.y,t[2]=e.z,this.viewPosId.setValue(t)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new B(this.device,[new k("matrix_viewProjection",I)]),this.viewBindGroupFormat=new L(this.device,[new R(C,y|T)],[new O("lightsTextureFloat",T,V,S)]))}setupViewUniformBuffers(e,t){if(e){const s=this.device;for(;e.viewBindGroups.length<t;){const t=new j(s,this.viewUniformFormat),r=new F(s,this.viewBindGroupFormat,t);e.viewBindGroups.push(r)}const r=e.viewBindGroups[0];r.defaultUniformBuffer.update(),r.update(),s.setBindGroup(b,r)}}drawInstance(e,t,s,r,i){const a=t.instancingData;if(a)a.count>0&&(this._instancedDrawCalls++,e.setVertexBuffer(a.vertexBuffer),e.draw(s.primitive[r],a.count));else{const a=t.node.worldTransform;this.modelMatrixId.setValue(a.data),i&&this.normalMatrixId.setValue(t.node.normalMatrix.data),e.draw(s.primitive[r])}}drawInstance2(e,t,s,r){const i=t.instancingData;i?i.count>0&&(this._instancedDrawCalls++,e.draw(s.primitive[r],i.count,!0)):e.draw(s.primitive[r],void 0,!0)}cull(e,t,s){let r=0;const i=t.length,a=e.cullingMask||4294967295;if(!e.frustumCulling){for(let e=0;e<i;e++){const i=t[e];(i.visible||i.command)&&(i.mask&&0==(i.mask&a)||(s[r]=i,r++,i.visibleThisFrame=!0))}return r}for(let o=0;o<i;o++){const i=t[o];if(i.command)s[r]=i,r++,i.visibleThisFrame=!0;else{if(!i.visible)continue;let t=!0;if(i.mask&&0==(i.mask&a))continue;i.cull&&(t=i._isVisible(e)),t&&(s[r]=i,r++,i.visibleThisFrame=!0)}}return r}cullLights(e,t){const s=this.scene.clusteredLightingEnabled,r=this.scene.physicalUnits;for(let i=0;i<t.length;i++){const a=t[i];if(a.enabled)if(a._type!==l)if(a.getBoundingSphere(K),e.frustum.containsSphere(K)){a.visibleThisFrame=!0,a.usePhysicalUnits=r;const t=e.getScreenSize(K);a.maxScreenSize=Math.max(a.maxScreenSize,t)}else s||a.castShadows&&!a.shadowMap&&(a.visibleThisFrame=!0);else a.usePhysicalUnits=this.scene.physicalUnits}}cullShadowmaps(e){for(let t=0;t<e._lights.length;t++){const s=e._lights[t];if(s._type!==l&&s.visibleThisFrame&&s.castShadows&&s.shadowUpdateMode!==h){const r=e._lightCompositionData[t].shadowCastersList;this._shadowRendererLocal.cull(s,r)}}const t=e._renderActions;for(let s=0;s<t.length;s++){const r=t[s],i=r.directionalLightsIndices.length;for(let t=0;t<i;t++){const s=r.directionalLightsIndices[t],i=e._lights[s],a=e._lightCompositionData[s].shadowCastersList;this._shadowRendererDirectional.cull(i,a,r.camera.camera)}}}cullComposition(e){const t=e._renderActions;for(let s=0;s<t.length;s++){const r=t[s],i=r.layerIndex,a=e.layerList[i];if(!a.enabled||!e.subLayerEnabled[i])continue;const o=e.subLayerList[i],n=r.cameraIndex,l=a.cameras[n];if(l){l.frameUpdate(r.renderTarget),r.firstCameraUse&&(this.updateCameraFrustum(l.camera),this._camerasRendered++),this.cullLights(l.camera,a._lights);const e=a.instances,t=o?e.visibleTransparent[n]:e.visibleOpaque[n];if(!t.done){a.onPreCull&&a.onPreCull(n);const e=o?a.transparentMeshInstances:a.opaqueMeshInstances;t.length=this.cull(l.camera,e,t.list),t.done=!0,a.onPostCull&&a.onPostCull(n)}}}this.cullShadowmaps(e)}updateShaders(e,t){const s=e.length;for(let r=0;r<s;r++){const s=e[r].material;if(s&&!ie.has(s)&&(ie.add(s),s.getShaderVariant!==m.prototype.getShaderVariant)){if(t&&(!s.useLighting||s.emitter&&!s.emitter.lighting))continue;s.clearVariants()}}ie.clear()}renderCookies(e){const t=this.lightTextureAtlas.cookieRenderTarget;for(let s=0;s<e.length;s++){const r=e[s];r.atlasViewportAllocated&&(r.atlasSlotUpdated&&this._cookieRenderer.render(r,t))}}beginFrame(e,t){const s=e._meshInstances,r=this.scene;if(r.updateShaders||t){const e=!r.updateShaders&&t;this.updateShaders(s,e),r.updateShaders=!1,r._shaderVersion++}this.updateCpuSkinMatrices(s);const i=s.length;for(let e=0;e<i;e++)s[e].visibleThisFrame=!1;const a=e._lights,o=a.length;for(let e=0;e<o;e++)a[e].beginFrame()}updateLightTextureAtlas(e){this.lightTextureAtlas.update(e._splitLights[c],e._splitLights[d],this.scene.lighting)}updateClusters(e){const t=e.getEmptyWorldClusters(this.device),s=e._renderActions;for(let r=0;r<s.length;r++){const i=s[r],a=i.lightClusters;if(a&&a!==t&&!ie.has(a)){ie.add(a);const t=e.layerList[i.layerIndex];a.update(t.clusteredLightsSet,this.scene.gammaCorrection,this.scene.lighting)}}ie.clear()}updateLayerComposition(e,t){const s=e.layerList.length;for(let t=0;t<s;t++)e.layerList[t]._postRenderCounter=0;const r=this.scene,i=r._shaderVersion;for(let t=0;t<s;t++){const s=e.layerList[t];s._shaderVersion=i,s._preRenderCalledForCameras=0,s._postRenderCalledForCameras=0;const a=e.subLayerList[t];s._postRenderCounter|=a?2:1,s._postRenderCounterMax=s._postRenderCounter;for(let e=0;e<s.cameras.length;e++)s.instances.prepare(e);s._needsStaticPrepare&&s._staticLightHash&&!this.scene.clusteredLightingEnabled&&(s._staticPrepareDone&&(G.revert(s.opaqueMeshInstances),G.revert(s.transparentMeshInstances)),G.prepare(this.device,r,s.opaqueMeshInstances,s._lights),G.prepare(this.device,r,s.transparentMeshInstances,s._lights),e._dirty=!0,r.updateShaders=!0,s._needsStaticPrepare=!1,s._staticPrepareDone=!0)}return e._update(this.device,t)}baseUpdate(){this.clustersDebugRendered=!1,this.initViewBindGroupFormat()}}export{ae as Renderer};
