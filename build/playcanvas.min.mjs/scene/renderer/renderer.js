import"../../core/tracing.js";import"../../core/time.js";import{Vec3 as e}from"../../core/math/vec3.js";import{Mat3 as t}from"../../core/math/mat3.js";import{Mat4 as s}from"../../core/math/mat4.js";import{BoundingSphere as r}from"../../core/shape/bounding-sphere.js";import{SORTKEY_FORWARD as i,SORTKEY_DEPTH as a,VIEW_CENTER as o,PROJECTION_ORTHOGRAPHIC as n,LIGHTTYPE_DIRECTIONAL as l,SHADOWUPDATE_NONE as h,SHADOWUPDATE_THISFRAME as d,LIGHTTYPE_SPOT as c,LIGHTTYPE_OMNI as p}from"../constants.js";import{LightTextureAtlas as m}from"../lighting/light-texture-atlas.js";import{Material as u}from"../materials/material.js";import{CLEARFLAG_COLOR as f,CLEARFLAG_DEPTH as w,CLEARFLAG_STENCIL as g,DEVICETYPE_WEBGPU as v,CULLFACE_NONE as _,CULLFACE_FRONTANDBACK as x,CULLFACE_FRONT as M,CULLFACE_BACK as I,UNIFORMTYPE_MAT4 as C,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as y,SHADERSTAGE_VERTEX as T,SHADERSTAGE_FRAGMENT as V,TEXTUREDIMENSION_2D as S,SAMPLETYPE_UNFILTERABLE_FLOAT as b,BINDGROUP_VIEW as P,BINDGROUP_MESH as j,SEMANTIC_ATTR as B}from"../../platform/graphics/constants.js";import{UniformBuffer as F}from"../../platform/graphics/uniform-buffer.js";import{BindGroup as k}from"../../platform/graphics/bind-group.js";import{UniformBufferFormat as L,UniformFormat as R}from"../../platform/graphics/uniform-buffer-format.js";import{BindGroupFormat as U,BindBufferFormat as O,BindTextureFormat as D}from"../../platform/graphics/bind-group-format.js";import{ShadowMapCache as z}from"./shadow-map-cache.js";import{ShadowRendererLocal as A}from"./shadow-renderer-local.js";import{ShadowRendererDirectional as W}from"./shadow-renderer-directional.js";import{CookieRenderer as E}from"./cookie-renderer.js";import{StaticMeshes as G}from"./static-meshes.js";import{ShadowRenderer as N}from"./shadow-renderer.js";let Y=0;const q=[0,0,0,0],X=new s,Z=new s,H=new s,J=new e,K=new e,Q=new e,$=new t,ee=new r,te=(new s).setScale(1,-1,1),se=(new s).set([1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1]),re=new s,ie=new s,ae=new s,oe=new s,ne=new Set;class le{constructor(e){this.clustersDebugRendered=!1,this.device=e,this.scene=null,this.lightTextureAtlas=new m(e),this.shadowMapCache=new z,this.shadowRenderer=new N(this,this.lightTextureAtlas),this._shadowRendererLocal=new A(this,this.shadowRenderer),this._shadowRendererDirectional=new W(this,this.shadowRenderer),this._cookieRenderer=new E(e,this.lightTextureAtlas),this.viewUniformFormat=null,this.viewBindGroupFormat=null,this._skinTime=0,this._morphTime=0,this._cullTime=0,this._shadowMapTime=0,this._lightClustersTime=0,this._layerCompositionUpdateTime=0,this._shadowDrawCalls=0,this._skinDrawCalls=0,this._instancedDrawCalls=0,this._shadowMapUpdates=0,this._numDrawCallsCulled=0,this._camerasRendered=0,this._lightClusters=0;const t=e.scope;this.boneTextureId=t.resolve("texture_poseMap"),this.boneTextureSizeId=t.resolve("texture_poseMapSize"),this.poseMatrixId=t.resolve("matrix_pose[0]"),this.modelMatrixId=t.resolve("matrix_model"),this.normalMatrixId=t.resolve("matrix_normal"),this.viewInvId=t.resolve("matrix_viewInverse"),this.viewPos=new Float32Array(3),this.viewPosId=t.resolve("view_position"),this.projId=t.resolve("matrix_projection"),this.projSkyboxId=t.resolve("matrix_projectionSkybox"),this.viewId=t.resolve("matrix_view"),this.viewId3=t.resolve("matrix_view3"),this.viewProjId=t.resolve("matrix_viewProjection"),this.flipYId=t.resolve("projectionFlipY"),this.tbnBasis=t.resolve("tbnBasis"),this.nearClipId=t.resolve("camera_near"),this.farClipId=t.resolve("camera_far"),this.cameraParams=new Float32Array(4),this.cameraParamsId=t.resolve("camera_params"),this.alphaTestId=t.resolve("alpha_ref"),this.opacityMapId=t.resolve("texture_opacityMap"),this.exposureId=t.resolve("exposure"),this.twoSidedLightingNegScaleFactorId=t.resolve("twoSidedLightingNegScaleFactor"),this.morphWeightsA=t.resolve("morph_weights_a"),this.morphWeightsB=t.resolve("morph_weights_b"),this.morphPositionTex=t.resolve("morphPositionTex"),this.morphNormalTex=t.resolve("morphNormalTex"),this.morphTexParams=t.resolve("morph_tex_params")}destroy(){this.shadowRenderer=null,this._shadowRendererLocal=null,this._shadowRendererDirectional=null,this.shadowMapCache.destroy(),this.shadowMapCache=null,this._cookieRenderer.destroy(),this._cookieRenderer=null,this.lightTextureAtlas.destroy(),this.lightTextureAtlas=null}sortCompare(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist;if(e.zdist2&&t.zdist2)return e.zdist2-t.zdist2}return t._key[i]-e._key[i]}sortCompareMesh(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist}const s=e._key[i],r=t._key[i];return s===r&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:r-s}sortCompareDepth(e,t){const s=e._key[a],r=t._key[a];return s===r&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:r-s}setupViewport(e,t){const s=this.device,r=t?t.width:s.width,i=t?t.height:s.height,a=e.rect;let o=Math.floor(a.x*r),n=Math.floor(a.y*i),l=Math.floor(a.z*r),h=Math.floor(a.w*i);if(s.setViewport(o,n,l,h),e._scissorRectClear){const t=e.scissorRect;o=Math.floor(t.x*r),n=Math.floor(t.y*i),l=Math.floor(t.z*r),h=Math.floor(t.w*i)}s.setScissor(o,n,l,h)}clear(e,t){const s=(e.clearColor?f:0)|(e.clearDepth?w:0)|(e.clearStencil?g:0);if(s){this.device.clear({color:[t._clearColor.r,t._clearColor.g,t._clearColor.b,t._clearColor.a],depth:t._clearDepth,stencil:t._clearStencil,flags:s})}}setCameraUniforms(t,s){const r=null==s?void 0:s.flipY;let i=1;if(t.xr&&t.xr.session){let e;const s=t._node.parent;s&&(e=s.getWorldTransform());const r=t.xr.views;i=r.length;for(let a=0;a<i;a++){const i=r[a];s?(i.viewInvOffMat.mul2(e,i.viewInvMat),i.viewOffMat.copy(i.viewInvOffMat).invert()):(i.viewInvOffMat.copy(i.viewInvMat),i.viewOffMat.copy(i.viewMat)),i.viewMat3.setFromMat4(i.viewOffMat),i.projViewOffMat.mul2(i.projMat,i.viewOffMat),i.position[0]=i.viewInvOffMat.data[12],i.position[1]=i.viewInvOffMat.data[13],i.position[2]=i.viewInvOffMat.data[14],t.frustum.setFromMat4(i.projViewOffMat)}}else{let s=t.projectionMatrix;t.calculateProjection&&t.calculateProjection(s,o);let i=t.getProjectionMatrixSkybox();if(r&&(s=re.mul2(te,s),i=ie.mul2(te,i)),this.device.deviceType===v&&(s=ae.mul2(se,s),i=oe.mul2(se,i)),this.projId.setValue(s.data),this.projSkyboxId.setValue(i.data),t.calculateTransform)t.calculateTransform(Z,o);else{const s=t._node.getPosition(),r=t._node.getRotation();Z.setTRS(s,r,e.ONE)}this.viewInvId.setValue(Z.data),H.copy(Z).invert(),this.viewId.setValue(H.data),$.setFromMat4(H),this.viewId3.setValue($.data),X.mul2(s,H),this.viewProjId.setValue(X.data),this.flipYId.setValue(r?-1:1),this.dispatchViewPos(t._node.getPosition()),t.frustum.setFromMat4(X)}this.tbnBasis.setValue(r?-1:1);const a=t._nearClip,l=t._farClip;return this.nearClipId.setValue(a),this.farClipId.setValue(l),this.cameraParams[0]=1/l,this.cameraParams[1]=l,this.cameraParams[2]=a,this.cameraParams[3]=t.projection===n?1:0,this.cameraParamsId.setValue(this.cameraParams),this.exposureId.setValue(this.scene.physicalUnits?t.getExposure():this.scene.exposure),i}setCamera(e,t,s,r=null){this.setCameraUniforms(e,t),this.clearView(e,t,s,!1)}clearView(e,t,s,r){const i=this.device;if(i.setRenderTarget(t),i.updateBegin(),r&&(i.setColorWrite(!0,!0,!0,!0),i.setDepthWrite(!0)),this.setupViewport(e,t),s){const t=e._clearOptions;i.clear(t||{color:[e._clearColor.r,e._clearColor.g,e._clearColor.b,e._clearColor.a],depth:e._clearDepth,flags:(e._clearColorBuffer?f:0)|(e._clearDepthBuffer?w:0)|(e._clearStencilBuffer?g:0),stencil:e._clearStencil})}}setCullMode(e,t,s){const r=s.material;let i=_;if(e){let e=1;if(r.cull>_&&r.cull<x){s.flipFaces&&(e*=-1),t&&(e*=-1);const r=s.node.worldTransform;r.getX(J),r.getY(K),r.getZ(Q),J.cross(J,K),J.dot(Q)<0&&(e*=-1)}i=e<0?r.cull===M?I:M:r.cull}if(this.device.setCullMode(i),i===_&&r.cull===_){const e=s.node.worldTransform;e.getX(J),e.getY(K),e.getZ(Q),J.cross(J,K),this.twoSidedLightingNegScaleFactorId.setValue(J.dot(Q)<0?-1:1)}}updateCameraFrustum(t){if(t.xr&&t.xr.views.length){const e=t.xr.views[0];return X.mul2(e.projMat,e.viewOffMat),void t.frustum.setFromMat4(X)}const s=t.projectionMatrix;if(t.calculateProjection&&t.calculateProjection(s,o),t.calculateTransform)t.calculateTransform(Z,o);else{const s=t._node.getPosition(),r=t._node.getRotation();Z.setTRS(s,r,e.ONE),this.viewInvId.setValue(Z.data)}H.copy(Z).invert(),X.mul2(s,H),t.frustum.setFromMat4(X)}setBaseConstants(e,t){e.setCullMode(t.cull),t.opacityMap&&(this.opacityMapId.setValue(t.opacityMap),this.alphaTestId.setValue(t.alphaTest))}updateCpuSkinMatrices(e){Y++;const t=e.length;if(0!==t)for(let s=0;s<t;s++){const t=e[s].skinInstance;t&&(t.updateMatrices(e[s].node,Y),t._dirty=!0)}}updateGpuSkinMatrices(e){const t=e.length;for(let s=0;s<t;s++){const t=e[s];if(t.visibleThisFrame){const e=t.skinInstance;e&&e._dirty&&(e.updateMatrixPalette(t.node,Y),e._dirty=!1)}}}updateMorphing(e){const t=e.length;for(let s=0;s<t;s++){const t=e[s],r=t.morphInstance;r&&r._dirty&&t.visibleThisFrame&&r.update()}}gpuUpdate(e){this.updateGpuSkinMatrices(e),this.updateMorphing(e)}setVertexBuffers(e,t){e.setVertexBuffer(t.vertexBuffer)}setMorphing(e,t){if(t)if(t.morph.useTextureMorph)e.setVertexBuffer(t.morph.vertexBufferIds),this.morphPositionTex.setValue(t.texturePositions),this.morphNormalTex.setValue(t.textureNormals),this.morphTexParams.setValue(t._textureParams);else{for(let s=0;s<t._activeVertexBuffers.length;s++){const r=t._activeVertexBuffers[s];if(r){const t=B+(s+8);r.format.elements[0].name=t,r.format.elements[0].scopeId=e.scope.resolve(t),r.format.update(),e.setVertexBuffer(r)}}this.morphWeightsA.setValue(t._shaderMorphWeightsA),this.morphWeightsB.setValue(t._shaderMorphWeightsB)}}setSkinning(e,t){if(t.skinInstance)if(this._skinDrawCalls++,e.supportsBoneTextures){const e=t.skinInstance.boneTexture;this.boneTextureId.setValue(e),q[0]=e.width,q[1]=e.height,q[2]=1/e.width,q[3]=1/e.height,this.boneTextureSizeId.setValue(q)}else this.poseMatrixId.setValue(t.skinInstance.matrixPalette)}dispatchViewPos(e){const t=this.viewPos;t[0]=e.x,t[1]=e.y,t[2]=e.z,this.viewPosId.setValue(t)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new L(this.device,[new R("matrix_viewProjection",C)]),this.viewBindGroupFormat=new U(this.device,[new O(y,T|V)],[new D("lightsTextureFloat",V,S,b)]))}setupViewUniformBuffers(e,t,s,r){const i=this.device;for(;e.length<r;){const r=new F(i,t),a=new k(i,s,r);e.push(a)}const a=e[0];a.defaultUniformBuffer.update(),a.update(),i.setBindGroup(P,a)}setupMeshUniformBuffers(e,t){const s=this.device;if(s.supportsUniformBuffers){this.modelMatrixId.setValue(e.node.worldTransform.data),this.normalMatrixId.setValue(e.node.normalMatrix.data);const r=e.getBindGroup(s,t);r.defaultUniformBuffer.update(),r.update(),s.setBindGroup(j,r)}}drawInstance(e,t,s,r,i){const a=t.instancingData;if(a)a.count>0&&(this._instancedDrawCalls++,e.setVertexBuffer(a.vertexBuffer),e.draw(s.primitive[r],a.count));else{const a=t.node.worldTransform;this.modelMatrixId.setValue(a.data),i&&this.normalMatrixId.setValue(t.node.normalMatrix.data),e.draw(s.primitive[r])}}drawInstance2(e,t,s,r){const i=t.instancingData;i?i.count>0&&(this._instancedDrawCalls++,e.draw(s.primitive[r],i.count,!0)):e.draw(s.primitive[r],void 0,!0)}cull(e,t,s){let r=0;const i=t.length,a=e.cullingMask||4294967295;if(!e.frustumCulling){for(let e=0;e<i;e++){const i=t[e];(i.visible||i.command)&&(i.mask&&0==(i.mask&a)||(s[r]=i,r++,i.visibleThisFrame=!0))}return r}for(let o=0;o<i;o++){const i=t[o];if(i.command)s[r]=i,r++,i.visibleThisFrame=!0;else{if(!i.visible)continue;let t=!0;if(i.mask&&0==(i.mask&a))continue;i.cull&&(t=i._isVisible(e)),t&&(s[r]=i,r++,i.visibleThisFrame=!0)}}return r}cullLights(e,t){const s=this.scene.clusteredLightingEnabled,r=this.scene.physicalUnits;for(let i=0;i<t.length;i++){const a=t[i];if(a.enabled)if(a._type!==l)if(a.getBoundingSphere(ee),e.frustum.containsSphere(ee)){a.visibleThisFrame=!0,a.usePhysicalUnits=r;const t=e.getScreenSize(ee);a.maxScreenSize=Math.max(a.maxScreenSize,t)}else s||a.castShadows&&!a.shadowMap&&(a.visibleThisFrame=!0);else a.usePhysicalUnits=this.scene.physicalUnits}}cullShadowmaps(e){const t=this.scene.clusteredLightingEnabled;for(let s=0;s<e._lights.length;s++){const r=e._lights[s];if(r._type!==l&&(t&&r.atlasSlotUpdated&&r.shadowUpdateMode===h&&(r.shadowUpdateMode=d),r.visibleThisFrame&&r.castShadows&&r.shadowUpdateMode!==h)){const t=e._lightCompositionData[s].shadowCastersList;this._shadowRendererLocal.cull(r,t)}}const s=e._renderActions;for(let t=0;t<s.length;t++){const r=s[t],i=r.directionalLightsIndices.length;for(let t=0;t<i;t++){const s=r.directionalLightsIndices[t],i=e._lights[s],a=e._lightCompositionData[s].shadowCastersList;this._shadowRendererDirectional.cull(i,a,r.camera.camera)}}}cullComposition(e){const t=e._renderActions;for(let s=0;s<t.length;s++){const r=t[s],i=r.layerIndex,a=e.layerList[i];if(!a.enabled||!e.subLayerEnabled[i])continue;const o=e.subLayerList[i],n=r.cameraIndex,l=a.cameras[n];if(l){l.frameUpdate(r.renderTarget),r.firstCameraUse&&(this.updateCameraFrustum(l.camera),this._camerasRendered++),this.cullLights(l.camera,a._lights);const e=a.instances,t=o?e.visibleTransparent[n]:e.visibleOpaque[n];if(!t.done){a.onPreCull&&a.onPreCull(n);const e=o?a.transparentMeshInstances:a.opaqueMeshInstances;t.length=this.cull(l.camera,e,t.list),t.done=!0,a.onPostCull&&a.onPostCull(n)}}}this.scene.clusteredLightingEnabled&&this.updateLightTextureAtlas(e),this.cullShadowmaps(e)}updateShaders(e,t){const s=e.length;for(let r=0;r<s;r++){const s=e[r].material;if(s&&!ne.has(s)&&(ne.add(s),s.getShaderVariant!==u.prototype.getShaderVariant)){if(t&&(!s.useLighting||s.emitter&&!s.emitter.lighting))continue;s.clearVariants()}}ne.clear()}renderCookies(e){const t=this.lightTextureAtlas.cookieRenderTarget;for(let s=0;s<e.length;s++){const r=e[s];r.atlasViewportAllocated&&(r.atlasSlotUpdated&&this._cookieRenderer.render(r,t))}}beginFrame(e,t){const s=e._meshInstances,r=this.scene;if(r.updateShaders||t){const e=!r.updateShaders&&t;this.updateShaders(s,e),r.updateShaders=!1,r._shaderVersion++}this.updateCpuSkinMatrices(s);const i=s.length;for(let e=0;e<i;e++)s[e].visibleThisFrame=!1;const a=e._lights,o=a.length;for(let e=0;e<o;e++)a[e].beginFrame()}updateLightTextureAtlas(e){this.lightTextureAtlas.update(e._splitLights[c],e._splitLights[p],this.scene.lighting)}updateClusters(e){const t=e.getEmptyWorldClusters(this.device),s=e._renderActions;for(let r=0;r<s.length;r++){const i=s[r],a=i.lightClusters;if(a&&a!==t&&!ne.has(a)){ne.add(a);const t=e.layerList[i.layerIndex];a.update(t.clusteredLightsSet,this.scene.gammaCorrection,this.scene.lighting)}}ne.clear()}updateLayerComposition(e,t){const s=e.layerList.length;for(let t=0;t<s;t++)e.layerList[t]._postRenderCounter=0;const r=this.scene,i=r._shaderVersion;for(let t=0;t<s;t++){const s=e.layerList[t];s._shaderVersion=i,s._preRenderCalledForCameras=0,s._postRenderCalledForCameras=0;const a=e.subLayerList[t];s._postRenderCounter|=a?2:1,s._postRenderCounterMax=s._postRenderCounter;for(let e=0;e<s.cameras.length;e++)s.instances.prepare(e);s._needsStaticPrepare&&s._staticLightHash&&!this.scene.clusteredLightingEnabled&&(s._staticPrepareDone&&(G.revert(s.opaqueMeshInstances),G.revert(s.transparentMeshInstances)),G.prepare(this.device,r,s.opaqueMeshInstances,s._lights),G.prepare(this.device,r,s.transparentMeshInstances,s._lights),e._dirty=!0,r.updateShaders=!0,s._needsStaticPrepare=!1,s._staticPrepareDone=!0)}return e._update(this.device,t)}frameUpdate(){this.clustersDebugRendered=!1,this.initViewBindGroupFormat()}}export{le as Renderer};
