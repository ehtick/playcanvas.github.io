import"../../core/time.js";import{Vec3 as e}from"../../math/vec3.js";import{Mat4 as t}from"../../math/mat4.js";import{BoundingBox as r}from"../../shape/bounding-box.js";import{BoundingSphere as s}from"../../shape/bounding-sphere.js";import{SEMANTIC_POSITION as i,PRIMITIVE_TRIANGLES as n}from"../../graphics/constants.js";import{IndexBuffer as o}from"../../graphics/index-buffer.js";import{LIGHTTYPE_SPOT as a,LIGHTTYPE_OMNI as c}from"../constants.js";import{Mesh as l}from"../mesh.js";import{MeshInstance as m}from"../mesh-instance.js";const h=new s;class f{static lightCompare(e,t){return e.key-t.key}static prepare(s,u,p,g){const d=p,A=d.length,_=[],b=new e,L=new e,w=new r,y=new t,S=[],x=[],M=[],U=[];for(let e=0;e<A;e++){const t=d[e];if(t.isStatic){const e=t.aabb;U.length=0;for(let s=c;s<=a;s++)for(let i=0;i<g.length;i++){const n=g[i];if(n._type===s&&(n.enabled&&n.mask&t.mask&&n.isStatic)){if(x[i]||(x[i]=new r,n._node.getWorldTransform(),n.getBoundingSphere(h),x[i].center.copy(h.center),x[i].halfExtents.set(h.radius,h.radius,h.radius)),!x[i].intersects(e))continue;U.push(i)}}if(0===U.length){_.push(t);continue}const u=t.mesh,p=u.vertexBuffer,d=u.indexBuffer[t.renderStyle],A=2===d.bytesPerIndex?new Uint16Array(d.lock()):new Uint32Array(d.lock()),v=u.primitive[t.renderStyle].count/3,k=u.primitive[t.renderStyle].base,E=p.format.elements,N=p.format.size/4,V=new Float32Array(p.storage);let X;for(let e=0;e<E.length;e++)E[e].name===i&&(X=E[e].offset/4);S.length=v;for(let e=0;e<v;e++)S[e]=0;let j=!1;M.length=6*v;for(let e=0;e<v;e++){let t=Number.MAX_VALUE,r=Number.MAX_VALUE,s=Number.MAX_VALUE,i=-Number.MAX_VALUE,n=-Number.MAX_VALUE,o=-Number.MAX_VALUE;for(let a=0;a<3;a++){let c=A[3*e+a+k];c=c*N+X;const l=V[c],m=V[c+1],h=V[c+2];l<t&&(t=l),m<r&&(r=m),h<s&&(s=h),l>i&&(i=l),m>n&&(n=m),h>o&&(o=h)}const a=6*e;M[a]=t,M[a+1]=r,M[a+2]=s,M[a+3]=i,M[a+4]=n,M[a+5]=o}for(let e=0;e<U.length;e++){const r=U[e];y.copy(t.node.worldTransform).invert(),w.setFromTransformedAabb(x[r],y);const s=w.getMin(),i=w.getMax(),n=1<<e;for(let e=0;e<v;e++){const t=6*e;M[t]<=i.x&&M[t+3]>=s.x&&M[t+1]<=i.y&&M[t+4]>=s.y&&M[t+2]<=i.z&&M[t+5]>=s.z&&(S[e]|=n,j=!0)}}if(j){const e={};for(let t=0;t<v;t++){const r=3*t+k,s=S[t];e[s]||(e[s]=[]);const i=e[s];i.push(A[r]),i.push(A[r+1]),i.push(A[r+2])}for(const i in e){const a=e[i],c=new o(s,d.format,a.length,d.usage);(2===c.bytesPerIndex?new Uint16Array(c.lock()):new Uint32Array(c.lock())).set(a),c.unlock();let h=Number.MAX_VALUE,u=Number.MAX_VALUE,A=Number.MAX_VALUE,w=-Number.MAX_VALUE,y=-Number.MAX_VALUE,S=-Number.MAX_VALUE;for(let e=0;e<a.length;e++){const t=a[e],r=V[t*N+X],s=V[t*N+X+1],i=V[t*N+X+2];r<h&&(h=r),s<u&&(u=s),i<A&&(A=i),r>w&&(w=r),s>y&&(y=s),i>S&&(S=i)}b.set(h,u,A),L.set(w,y,S);const x=new r;x.setMinMax(b,L);const M=new l(s);M.vertexBuffer=p,M.indexBuffer[0]=c,M.primitive[0].type=n,M.primitive[0].base=0,M.primitive[0].count=a.length,M.primitive[0].indexed=!0,M.aabb=x;const v=new m(M,t.material,t.node);v.isStatic=t.isStatic,v.visible=t.visible,v.layer=t.layer,v.castShadow=t.castShadow,v._receiveShadow=t._receiveShadow,v.cull=t.cull,v.pick=t.pick,v.mask=t.mask,v.parameters=t.parameters,v._shaderDefs=t._shaderDefs,v._staticSource=t,t._staticLightList?v._staticLightList=t._staticLightList:v._staticLightList=[];for(let e=0;e<U.length;e++){if(i&1<<e){const t=g[U[e]];v._staticLightList.indexOf(t)<0&&v._staticLightList.push(t)}}v._staticLightList.sort(f.lightCompare),_.push(v)}}else _.push(t)}else _.push(t)}p.length=_.length;for(let e=0;e<_.length;e++)p[e]=_[e]}static revert(e){const t=e,r=t.length,s=[];let i;for(let e=0;e<r;e++){const r=t[e];r._staticSource?r._staticSource!==i&&(s.push(r._staticSource),i=r._staticSource):s.push(r)}e.length=s.length;for(let t=0;t<s.length;t++)e[t]=s[t]}}export{f as StaticMeshes};
