import"../../core/tracing.js";import"../../core/time.js";import{Color as e}from"../../core/math/color.js";import{Mat4 as t}from"../../core/math/mat4.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Vec4 as r}from"../../core/math/vec4.js";import{DEVICETYPE_WEBGPU as i,FUNC_LESSEQUAL as a,UNIFORMTYPE_MAT4 as o,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as n,SHADERSTAGE_VERTEX as h,SHADERSTAGE_FRAGMENT as d}from"../../platform/graphics/constants.js";import{drawQuadWithShader as l}from"../graphics/quad-render-utils.js";import{SHADOW_VSM8 as c,SHADOW_VSM32 as p,SHADOW_PCF5 as u,SHADOW_PCF3 as f,LIGHTTYPE_OMNI as m,LIGHTTYPE_DIRECTIONAL as w,SORTKEY_DEPTH as g,SHADOWUPDATE_NONE as S,SHADOWUPDATE_THISFRAME as V,BLUR_GAUSSIAN as y,SHADER_SHADOW as v}from"../constants.js";import{ShaderPass as b}from"../shader-pass.js";import{shaderChunks as B}from"../shader-lib/chunks/chunks.js";import{createShaderFromCode as C}from"../shader-lib/utils.js";import{LightCamera as _}from"./light-camera.js";import{UniformBufferFormat as M,UniformFormat as O}from"../../platform/graphics/uniform-buffer-format.js";import{BindGroupFormat as F,BindBufferFormat as D}from"../../platform/graphics/bind-group-format.js";function P(e,t){return Math.exp(-e*e/(2*t*t))}const R=new t,U=new t,x=new Float32Array(2),I=new r(1,1,0,0),j={r:1,g:2,b:3,a:4},T=new t;function k(e){const t=e.material,s=e.skinInstance?10:0;let r=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(r=j[e])}return s+r}class L{constructor(e,t){this.device=e.device,this.renderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.polygonOffsetId=s.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShaderCode=[B.blurVSMPS,"#define GAUSS\n"+B.blurVSMPS];const r="#define PACKED\n";this.blurPackedVsmShaderCode=[r+this.blurVsmShaderCode[0],r+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius"),this.viewUniformFormat=null,this.viewBindGroupFormat=null}static createShadowCamera(t,s,r,i){const a=_.create("ShadowCamera",r,i);return a.clearColor=s>=c&&s<=p?new e(0,0,0,0):new e(1,1,1,1),a.clearDepthBuffer=!0,a.clearStencilBuffer=!1,a}static setShadowCameraSettings(e,t,s,r,i){let a=s===u||s===f&&t.supportsDepthShadow;r!==m||i||(a=!1),e.clearColorBuffer=!a}cullShadowCasters(e,t,s){let r=0;const i=e.length;for(let a=0;a<i;a++){const i=e[a];i.cull&&!i._isVisible(s)||(i.visibleThisFrame=!0,t[r]=i,r++)}t.length=r,t.sort(this.renderer.sortCompareDepth)}setupRenderState(e,t){const s=this.renderer.scene.clusteredLightingEnabled;e.webgl2||e.deviceType===i?t._type!==m||s?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(t._type===m?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset))),e.setBlending(!1),e.setDepthWrite(!0),e.setDepthTest(!0),e.setDepthFunc(a);(s?t._isPcf&&e.webgl2:t._isPcf&&e.webgl2&&t._type!==m)?e.setColorWrite(!1,!1,!1,!1):e.setColorWrite(!0,!0,!0,!0)}restoreRenderState(e){e.webgl2?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,t,r,i){const a=t._node;e._type!==w&&(this.renderer.dispatchViewPos(a.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),R.setTRS(a.getPosition(),a.getRotation(),s.ONE).invert(),U.mul2(t.projectionMatrix,R);const o=r.shadowViewport;t.rect=o,t.scissorRect=r.shadowScissor,T.setViewport(o.x,o.y,o.z,o.w),r.shadowMatrix.mul2(T,U),e._type===w&&e._shadowMatrixPalette.set(r.shadowMatrix.data,16*i)}submitCasters(e,t){const s=this.device,r=this.renderer,i=r.scene,a=1<<v,o=b.getShadow(t._type,t._shadowType),n=e.length;for(let t=0;t<n;t++){const n=e[t],h=n.mesh;n.ensureMaterial(s);const d=n.material;r.setBaseConstants(s,d),r.setSkinning(s,n),d.dirty&&(d.updateUniforms(s,i),d.dirty=!1),d.chunks&&(r.setCullMode(!0,!1,n),d.setParameters(s),n.setParameters(s,a));let l=n._shader[o];l||(n.updatePassShader(i,o,null,null,this.viewUniformFormat,this.viewBindGroupFormat),l=n._shader[o],n._key[g]=k(n)),!l.failed&&s.setShader(l),r.setVertexBuffers(s,h),r.setMorphing(s,n.morphInstance),this.renderer.setupMeshUniformBuffers(n,o);const c=n.renderStyle;s.setIndexBuffer(h.indexBuffer[c]),r.drawInstance(s,n,h,c),r._shadowDrawCalls++}}needsShadowRendering(e){const t=e.enabled&&e.castShadows&&e.shadowUpdateMode!==S&&e.visibleThisFrame;return e.shadowUpdateMode===V&&(e.shadowUpdateMode=S),t&&(this.renderer._shadowMapUpdates+=e.numShadowFaces),t}getLightRenderData(e,t,s){return e.getRenderData(e._type===w?t:null,s)}setupRenderPass(e,t,s){const r=t.renderTarget;if(e.init(r),s){const s=t.clearColorBuffer;e.colorOps.clear=s,s&&e.colorOps.clearValue.copy(t.clearColor),e.depthStencilOps.storeDepth=!s,e.setClearDepth(1)}e.requiresCubemaps=!1}prepareFace(e,t,s){const r=e._type,i=e._shadowType,a=this.renderer.scene.clusteredLightingEnabled,o=this.getLightRenderData(e,t,s).shadowCamera;L.setShadowCameraSettings(o,this.device,i,r,a);const n=r===w?0:s;return o.renderTarget=e._shadowMap.renderTargets[n],o}renderFace(e,t,s,r){const i=this.device;this.setupRenderState(i,e);const a=this.getLightRenderData(e,t,s),o=a.shadowCamera;this.dispatchUniforms(e,o,a,s);const n=o.renderTarget;this.renderer.setCameraUniforms(o,n),i.supportsUniformBuffers&&this.renderer.setupViewUniformBuffers(a.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,1),r?this.renderer.clearView(o,n,!0,!1):this.renderer.setupViewport(o,n),this.submitCasters(a.visibleCasters,e),this.restoreRenderState(i)}render(e,t){if(this.needsShadowRendering(e)){const s=e.numShadowFaces;for(let r=0;r<s;r++)this.prepareFace(e,t,r),this.renderFace(e,t,r,!0);this.renderVms(e,t)}}renderVms(e,t){if(e._isVsm&&e._vsmBlurSize>1){this.renderer.scene.clusteredLightingEnabled&&e._type!==w||this.applyVsmBlur(e,t)}}getVsmBlurShader(e,t,s){let r=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][s];if(!r){this.blurVsmWeights[s]=function(e){e>25&&(e=25);const t=(e-1)/6,s=.5*(e-1),r=new Array(e);let i=0;for(let a=0;a<e;++a)r[a]=P(a-s,t),i+=r[a];for(let t=0;t<e;++t)r[t]/=i;return r}(s);const i=B.fullscreenQuadVS;let a="#define SAMPLES "+s+"\n";a+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const o="blurVsm"+t+s+e;r=C(this.device,i,a,o),e?this.blurPackedVsmShader[t][s]=r:this.blurVsmShader[t][s]=r}return r}applyVsmBlur(e,t){const s=this.device,r=e.getRenderData(e._type===w?t:null,0).shadowCamera.renderTarget,i=this.renderer.shadowMapCache.get(s,e),a=i.renderTargets[0],o=e._shadowType===c,n=e.vsmBlurMode,h=e._vsmBlurSize,d=this.getVsmBlurShader(o,n,h);I.z=e._shadowResolution-2,I.w=I.z,this.sourceId.setValue(r.colorBuffer),x[0]=1/e._shadowResolution,x[1]=0,this.pixelOffsetId.setValue(x),n===y&&this.weightId.setValue(this.blurVsmWeights[h]),l(s,a,d,null,I),this.sourceId.setValue(a.colorBuffer),x[1]=x[0],x[0]=0,this.pixelOffsetId.setValue(x),l(s,r,d,null,I),this.renderer.shadowMapCache.add(e,i)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new M(this.device,[new O("matrix_viewProjection",o)]),this.viewBindGroupFormat=new F(this.device,[new D(n,h|d)],[]))}frameUpdate(){this.initViewBindGroupFormat()}}export{L as ShadowRenderer};
