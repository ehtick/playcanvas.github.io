import"../../core/debug.js";import"../../core/time.js";import{Color as e}from"../../core/math/color.js";import{Mat4 as t}from"../../core/math/mat4.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Vec4 as r}from"../../core/math/vec4.js";import{UNIFORMTYPE_MAT4 as i,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as a,SHADERSTAGE_VERTEX as o,SHADERSTAGE_FRAGMENT as h}from"../../platform/graphics/constants.js";import{drawQuadWithShader as n}from"../graphics/quad-render-utils.js";import{SHADOW_VSM8 as d,SHADOW_VSM32 as l,SHADOW_PCF5 as p,SHADOW_PCF1 as c,SHADOW_PCF3 as u,LIGHTTYPE_OMNI as f,LIGHTTYPE_DIRECTIONAL as m,SORTKEY_DEPTH as w,SHADOWUPDATE_NONE as g,SHADOWUPDATE_THISFRAME as S,BLUR_GAUSSIAN as V,SHADER_SHADOW as b}from"../constants.js";import{ShaderPass as v}from"../shader-pass.js";import{shaderChunks as y}from"../shader-lib/chunks/chunks.js";import{createShaderFromCode as B}from"../shader-lib/utils.js";import{LightCamera as C}from"./light-camera.js";import{UniformBufferFormat as _,UniformFormat as P}from"../../platform/graphics/uniform-buffer-format.js";import{BindGroupFormat as O,BindBufferFormat as M}from"../../platform/graphics/bind-group-format.js";import{BlendState as D}from"../../platform/graphics/blend-state.js";import{DepthState as U}from"../../platform/graphics/depth-state.js";function F(e,t){return Math.exp(-e*e/(2*t*t))}const j=new t,x=new t,R=new Float32Array(2),I=new r(1,1,0,0),T={r:1,g:2,b:3,a:4},W=new t;function k(e){const t=e.material,s=e.skinInstance?10:0;let r=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(r=T[e])}return s+r}class G{constructor(e,t){this.shadowPassCache=[],this.device=e.device,this.renderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.polygonOffsetId=s.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShaderCode=[y.blurVSMPS,"#define GAUSS\n"+y.blurVSMPS];const r="#define PACKED\n";this.blurPackedVsmShaderCode=[r+this.blurVsmShaderCode[0],r+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius"),this.viewUniformFormat=null,this.viewBindGroupFormat=null,this.blendStateWrite=new D,this.blendStateNoWrite=new D,this.blendStateNoWrite.setColorWrite(!1,!1,!1,!1)}static createShadowCamera(t,s,r,i){const a=C.create("ShadowCamera",r,i);return a.clearColor=s>=d&&s<=l?new e(0,0,0,0):new e(1,1,1,1),a.clearDepthBuffer=!0,a.clearStencilBuffer=!1,a}static setShadowCameraSettings(e,t,s,r,i){let a=s===p||(s===c||s===u)&&t.supportsDepthShadow;r!==f||i||(a=!1),e.clearColorBuffer=!a}cullShadowCasters(e,t,s){let r=0;const i=e.length;for(let a=0;a<i;a++){const i=e[a];i.castShadow&&(i.cull&&!i._isVisible(s)||(i.visibleThisFrame=!0,t[r]=i,r++))}t.length=r,t.sort(this.renderer.sortCompareDepth)}setupRenderState(e,t){const s=this.renderer.scene.clusteredLightingEnabled;e.webgl2||e.isWebGPU?t._type!==f||s?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(t._type===f?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset)));const r=e.webgl2||e.isWebGPU,i=s?t._isPcf&&r:t._isPcf&&r&&t._type!==f;e.setBlendState(i?this.blendStateNoWrite:this.blendStateWrite),e.setDepthState(U.DEFAULT),e.setStencilState(null,null)}restoreRenderState(e){e.webgl2||e.isWebGPU?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,t,r,i){const a=t._node;e._type!==m&&(this.renderer.dispatchViewPos(a.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),j.setTRS(a.getPosition(),a.getRotation(),s.ONE).invert(),x.mul2(t.projectionMatrix,j);const o=r.shadowViewport;t.rect=o,t.scissorRect=r.shadowScissor,W.setViewport(o.x,o.y,o.z,o.w),r.shadowMatrix.mul2(W,x),e._type===m&&e._shadowMatrixPalette.set(r.shadowMatrix.data,16*i)}getShadowPass(e){var t;const s=e._type,r=e._shadowType;let i=null==(t=this.shadowPassCache[s])?void 0:t[r];if(!i){const e=`ShadowPass_${s}_${r}`;i=v.get(this.device).allocate(e,{isShadow:!0,lightType:s,shadowType:r}),this.shadowPassCache[s]||(this.shadowPassCache[s]=[]),this.shadowPassCache[s][r]=i}return i.index}submitCasters(e,t){const s=this.device,r=this.renderer,i=r.scene,a=1<<b,o=this.getShadowPass(t),h=e.length;for(let t=0;t<h;t++){const h=e[t],n=h.mesh;h.ensureMaterial(s);const d=h.material;r.setBaseConstants(s,d),r.setSkinning(s,h),d.dirty&&(d.updateUniforms(s,i),d.dirty=!1),d.chunks&&(r.setupCullMode(!0,1,h),d.setParameters(s),h.setParameters(s,a));let l=h._shader[o];l||(h.updatePassShader(i,o,null,null,this.viewUniformFormat,this.viewBindGroupFormat),l=h._shader[o],h._key[w]=k(h)),!l.failed&&s.setShader(l),r.setVertexBuffers(s,n),r.setMorphing(s,h.morphInstance),this.renderer.setupMeshUniformBuffers(h,o);const p=h.renderStyle;s.setIndexBuffer(n.indexBuffer[p]),r.drawInstance(s,h,n,p),r._shadowDrawCalls++}}needsShadowRendering(e){const t=e.enabled&&e.castShadows&&e.shadowUpdateMode!==g&&e.visibleThisFrame;return e.shadowUpdateMode===S&&(e.shadowUpdateMode=g),t&&(this.renderer._shadowMapUpdates+=e.numShadowFaces),t}getLightRenderData(e,t,s){return e.getRenderData(e._type===m?t:null,s)}setupRenderPass(e,t,s){const r=t.renderTarget;e.init(r),e.depthStencilOps.clearDepthValue=1,e.depthStencilOps.clearDepth=s,r.depthBuffer?e.depthStencilOps.storeDepth=!0:(e.colorOps.clearValue.copy(t.clearColor),e.colorOps.clear=s,e.depthStencilOps.storeDepth=!1),e.requiresCubemaps=!1}prepareFace(e,t,s){const r=e._type,i=e._shadowType,a=this.renderer.scene.clusteredLightingEnabled,o=this.getLightRenderData(e,t,s).shadowCamera;G.setShadowCameraSettings(o,this.device,i,r,a);const h=r===m?0:s;return o.renderTarget=e._shadowMap.renderTargets[h],o}renderFace(e,t,s,r,i=!0){const a=this.device,o=this.getLightRenderData(e,t,s),h=o.shadowCamera;this.dispatchUniforms(e,h,o,s);const n=h.renderTarget,d=this.renderer;d.setCameraUniforms(h,n),a.supportsUniformBuffers&&d.setupViewUniformBuffers(o.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,1),i?(d.setupViewport(h,n),r&&d.clear(h)):d.clearView(h,n,!0,!1),this.setupRenderState(a,e),this.submitCasters(o.visibleCasters,e),this.restoreRenderState(a)}render(e,t,s=!0){if(this.needsShadowRendering(e)){const r=e.numShadowFaces;for(let i=0;i<r;i++)this.prepareFace(e,t,i),this.renderFace(e,t,i,!0,s);this.renderVsm(e,t)}}renderVsm(e,t){if(e._isVsm&&e._vsmBlurSize>1){this.renderer.scene.clusteredLightingEnabled&&e._type!==m||this.applyVsmBlur(e,t)}}getVsmBlurShader(e,t,s){let r=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][s];if(!r){this.blurVsmWeights[s]=function(e){const t=(e-1)/6,s=.5*(e-1),r=new Array(e);let i=0;for(let a=0;a<e;++a)r[a]=F(a-s,t),i+=r[a];for(let t=0;t<e;++t)r[t]/=i;return r}(s);const i=y.fullscreenQuadVS;let a="#define SAMPLES "+s+"\n";a+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const o="blurVsm"+t+s+e;r=B(this.device,i,a,o),e?this.blurPackedVsmShader[t][s]=r:this.blurVsmShader[t][s]=r}return r}applyVsmBlur(e,t){const s=this.device;s.setBlendState(D.NOBLEND);const r=e.getRenderData(e._type===m?t:null,0).shadowCamera.renderTarget,i=this.renderer.shadowMapCache.get(s,e),a=i.renderTargets[0],o=e._shadowType===d,h=e.vsmBlurMode,l=e._vsmBlurSize,p=this.getVsmBlurShader(o,h,l);I.z=e._shadowResolution-2,I.w=I.z,this.sourceId.setValue(r.colorBuffer),R[0]=1/e._shadowResolution,R[1]=0,this.pixelOffsetId.setValue(R),h===V&&this.weightId.setValue(this.blurVsmWeights[l]),n(s,a,p,null,I),this.sourceId.setValue(a.colorBuffer),R[1]=R[0],R[0]=0,this.pixelOffsetId.setValue(R),n(s,r,p,null,I),this.renderer.shadowMapCache.add(e,i)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new _(this.device,[new P("matrix_viewProjection",i)]),this.viewBindGroupFormat=new O(this.device,[new M(a,o|h)],[]))}frameUpdate(){this.initViewBindGroupFormat()}}export{G as ShadowRenderer};
