import"../../core/tracing.js";import{math as e}from"../../math/math.js";import{Vec3 as t}from"../../math/vec3.js";import{Vec4 as s}from"../../math/vec4.js";import{Mat4 as a}from"../../math/mat4.js";import{Color as r}from"../../math/color.js";import{BoundingBox as o}from"../../shape/bounding-box.js";import{SHADOW_VSM8 as i,SHADOW_VSM32 as n,SHADOW_PCF5 as d,SHADOW_PCF3 as h,LIGHTTYPE_SPOT as l,LIGHTTYPE_OMNI as c,LIGHTTYPE_DIRECTIONAL as p,SORTKEY_DEPTH as f,SHADOWUPDATE_NONE as u,SHADOWUPDATE_THISFRAME as m,BLUR_GAUSSIAN as w,SHADER_SHADOW as g}from"../constants.js";import{LightCamera as S}from"./light-camera.js";import{FUNC_LESSEQUAL as y}from"../../graphics/constants.js";import{drawQuadWithShader as C}from"../../graphics/simple-post-effect.js";import{shaderChunks as b}from"../../graphics/program-lib/chunks/chunks.js";import{createShaderFromCode as _}from"../../graphics/program-lib/utils.js";import{ShadowMap as V}from"./shadow-map.js";import{ShadowMapCache as v}from"./shadow-map-cache.js";import{Frustum as x}from"../../shape/frustum.js";import{ShaderPass as M}from"../shader-pass.js";const R=[new t,new t,new t,new t,new t,new t,new t,new t],D={min:0,max:0};function P(e,t,s){R[0].x=R[1].x=R[2].x=R[3].x=t.x,R[1].y=R[3].y=R[7].y=R[5].y=t.y,R[2].z=R[3].z=R[6].z=R[7].z=t.z,R[4].x=R[5].x=R[6].x=R[7].x=s.x,R[0].y=R[2].y=R[4].y=R[6].y=s.y,R[0].z=R[1].z=R[4].z=R[5].z=s.z;let a=9999999999,r=-9999999999;for(let t=0;t<8;++t){e.transformPoint(R[t],R[t]);const s=R[t].z;s<a&&(a=s),s>r&&(r=s)}return D.min=a,D.max=r,D}function B(e,t){return Math.exp(-e*e/(2*t*t))}const T=new o,O=new a,j=new a,I=new Float32Array(2),z=new s(1,1,0,0),A={r:1,g:2,b:3,a:4},E=new t,L=new a;function k(e){const t=e.material,s=e.skinInstance?10:0;let a=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(a=A[e])}return s+a}class F{constructor(e,t){this.device=e.device,this.forwardRenderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.polygonOffsetId=s.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShaderCode=[b.blurVSMPS,"#define GAUSS\n"+b.blurVSMPS];const a="#define PACKED\n";this.blurPackedVsmShaderCode=[a+this.blurVsmShaderCode[0],a+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius"),this.shadowMapCache=new v}destroy(){this.shadowMapCache.destroy(),this.shadowMapCache=null}static createShadowCamera(e,t,s,a){const o=S.create("ShadowCamera",s,a);return o.clearColor=t>=i&&t<=n?new r(0,0,0,0):new r(1,1,1,1),o.clearDepthBuffer=!0,o.clearStencilBuffer=!1,o}static setShadowCameraSettings(e,t,s,a,r){let o=s===d||s===h&&t.webgl2;a!==c||r||(o=!1),e.clearColorBuffer=!o}cullShadowCasters(e,t,s){let a=0;const r=e.length;for(let o=0;o<r;o++){const r=e[o];r.cull&&!r._isVisible(s)||(r.visibleThisFrame=!0,t[a]=r,a++)}t.length=a,t.sort(this.forwardRenderer.depthSortCompare)}cullLocal(t,s){const a=this.forwardRenderer.scene.clusteredLightingEnabled;t.visibleThisFrame=!0,a||t._shadowMap||(t._shadowMap=V.create(this.device,t));const r=t._type,o=r===l?1:6;for(let i=0;i<o;i++){const o=t.getRenderData(null,i),n=o.shadowCamera;n.nearClip=t.attenuationEnd/1e3,n.farClip=t.attenuationEnd;const d=n._node,h=t._node;if(d.setPosition(h.getPosition()),r===l)n.fov=2*t._outerConeAngle,d.setRotation(h.getRotation()),d.rotateLocal(-90,0,0);else if(r===c)if(a){const s=2/(this.lightTextureAtlas.shadowAtlasResolution*t.atlasViewport.z/3)*this.lightTextureAtlas.shadowEdgePixels;n.fov=Math.atan(1+s)*e.RAD_TO_DEG*2}else n.fov=90;this.forwardRenderer.updateCameraFrustum(n),this.cullShadowCasters(s,o.visibleCasters,n)}}generateSplitDistances(t,s,a){t._shadowCascadeDistances.fill(a);for(let r=1;r<t.numCascades;r++){const o=r/t.numCascades,i=s+(a-s)*o,n=s*(a/s)**o,d=e.lerp(i,n,t.cascadeDistribution);t._shadowCascadeDistances[r-1]=d}}cullDirectional(e,t,s){e.visibleThisFrame=!0,e._shadowMap||(e._shadowMap=V.create(this.device,e));const a=s._nearClip;this.generateSplitDistances(e,a,e.shadowDistance);for(let r=0;r<e.numCascades;r++){const o=e.getRenderData(s,r),i=o.shadowCamera;i.renderTarget=e._shadowMap.renderTargets[0],o.shadowViewport.copy(e.cascades[r]),o.shadowScissor.copy(e.cascades[r]);const n=i._node,d=e._node;n.setPosition(d.getPosition()),n.setRotation(d.getRotation()),n.rotateLocal(-90,0,0);const h=0===r?a:e._shadowCascadeDistances[r-1],l=e._shadowCascadeDistances[r],c=x.getPoints(s,h,l);E.set(0,0,0);const p=s.node.getWorldTransform();for(let e=0;e<8;e++)p.transformPoint(c[e],c[e]),E.add(c[e]);E.mulScalar(1/8);let f=0;for(let e=0;e<8;e++){const t=c[e].sub(E).length();t>f&&(f=t)}const u=n.right,m=n.up,w=n.forward,g=.25*e._shadowResolution/f,S=Math.ceil(E.dot(m)*g)/g,y=Math.ceil(E.dot(u)*g)/g,C=m.mulScalar(S),b=u.mulScalar(y),_=E.dot(w),V=w.mulScalar(_);E.add2(C,b).add(V),n.setPosition(E),n.translateLocal(0,0,1e6),i.nearClip=0,i.farClip=2e6,i.orthoHeight=f,this.forwardRenderer.updateCameraFrustum(i),this.cullShadowCasters(t,o.visibleCasters,i);let v=!0;const M=o.visibleCasters;for(let e=0;e<M.length;e++){const t=M[e];v?(v=!1,T.copy(t.aabb)):T.add(t.aabb)}O.copy(n.getWorldTransform()).invert();const R=P(O,T.getMin(),T.getMax());n.translateLocal(0,0,R.max+.1),i.farClip=R.max-R.min+.2}}setupRenderState(e,t){const s=this.forwardRenderer.scene.clusteredLightingEnabled;e.webgl2?t._type!==c||s?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(t._type===c?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset))),e.setBlending(!1),e.setDepthWrite(!0),e.setDepthTest(!0),e.setDepthFunc(y);(s?t._isPcf&&e.webgl2:t._isPcf&&e.webgl2&&t._type!==c)?e.setColorWrite(!1,!1,!1,!1):e.setColorWrite(!0,!0,!0,!0)}restoreRenderState(e){e.webgl2?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,s,a,r){const o=s._node;e._type!==p&&(this.forwardRenderer.dispatchViewPos(o.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),O.setTRS(o.getPosition(),o.getRotation(),t.ONE).invert(),j.mul2(s.projectionMatrix,O);const i=a.shadowViewport;s.rect=i,s.scissorRect=a.shadowScissor,L.setViewport(i.x,i.y,i.z,i.w),a.shadowMatrix.mul2(L,j),e._type===p&&e._shadowMatrixPalette.set(a.shadowMatrix.data,16*r)}submitCasters(e,t){const s=this.device,a=this.forwardRenderer,r=a.scene,o=1<<g,i=M.getShadow(t._type,t._shadowType),n=e.length;for(let t=0;t<n;t++){const n=e[t],d=n.mesh;n.ensureMaterial(s);const h=n.material;a.setBaseConstants(s,h),a.setSkinning(s,n,h),h.dirty&&(h.updateUniforms(s,r),h.dirty=!1),h.chunks&&(a.setCullMode(!0,!1,n),h.setParameters(s),n.setParameters(s,o));let l=n._shader[i];l||(n.updatePassShader(r,i),l=n._shader[i],n._key[f]=k(n)),!l.failed&&s.setShader(l),a.setVertexBuffers(s,d),a.setMorphing(s,n.morphInstance);const c=n.renderStyle;s.setIndexBuffer(d.indexBuffer[c]),a.drawInstance(s,n,d,c),a._shadowDrawCalls++}}render(e,t){if(e.enabled&&e.castShadows&&e.shadowUpdateMode!==u&&e.visibleThisFrame){const s=this.device;e.shadowUpdateMode===m&&(e.shadowUpdateMode=u);const a=e._type,r=e._shadowType,o=e.numShadowFaces,i=this.forwardRenderer;i._shadowMapUpdates+=o;const n=i.scene.clusteredLightingEnabled;this.setupRenderState(s,e);for(let d=0;d<o;d++){const o=e.getRenderData(a===p?t:null,d),h=o.shadowCamera;F.setShadowCameraSettings(h,s,r,a,n);const l=a===p?0:d;h.renderTarget=e._shadowMap.renderTargets[l],this.dispatchUniforms(e,h,o,d),i.setCamera(h,h.renderTarget,!0),this.submitCasters(o.visibleCasters,e)}if(e._isVsm&&e._vsmBlurSize>1){this.forwardRenderer.scene.clusteredLightingEnabled&&a!==p||this.applyVsmBlur(e,t)}this.restoreRenderState(s)}}getVsmBlurShader(e,t,s){let a=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][s];if(!a){this.blurVsmWeights[s]=function(e){e>25&&(e=25);const t=(e-1)/6,s=.5*(e-1),a=new Array(e);let r=0;for(let o=0;o<e;++o)a[o]=B(o-s,t),r+=a[o];for(let t=0;t<e;++t)a[t]/=r;return a}(s);const r=b.fullscreenQuadVS;let o="#define SAMPLES "+s+"\n";o+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const i="blurVsm"+t+s+e;a=_(this.device,r,o,i),e?this.blurPackedVsmShader[t][s]=a:this.blurVsmShader[t][s]=a}return a}applyVsmBlur(e,t){const s=this.device,a=e.getRenderData(e._type===p?t:null,0).shadowCamera.renderTarget,r=this.shadowMapCache.get(s,e),o=r.renderTargets[0],n=e._shadowType===i,d=e.vsmBlurMode,h=e._vsmBlurSize,l=this.getVsmBlurShader(n,d,h);z.z=e._shadowResolution-2,z.w=z.z,this.sourceId.setValue(a.colorBuffer),I[0]=1/e._shadowResolution,I[1]=0,this.pixelOffsetId.setValue(I),d===w&&this.weightId.setValue(this.blurVsmWeights[h]),C(s,o,l,null,z),this.sourceId.setValue(o.colorBuffer),I[1]=I[0],I[0]=0,this.pixelOffsetId.setValue(I),C(s,a,l,null,z),this.shadowMapCache.add(e,r)}}export{F as ShadowRenderer};
