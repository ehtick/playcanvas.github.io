import"../../core/tracing.js";import"../../core/time.js";import{Color as e}from"../../core/math/color.js";import{Mat4 as t}from"../../core/math/mat4.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Vec4 as r}from"../../core/math/vec4.js";import{FUNC_LESSEQUAL as a}from"../../platform/graphics/constants.js";import{drawQuadWithShader as i}from"../../platform/graphics/simple-post-effect.js";import{SHADOW_VSM8 as o,SHADOW_VSM32 as n,SHADOW_PCF5 as h,SHADOW_PCF3 as d,LIGHTTYPE_OMNI as l,LIGHTTYPE_DIRECTIONAL as c,SORTKEY_DEPTH as p,SHADOWUPDATE_NONE as u,SHADOWUPDATE_THISFRAME as f,BLUR_GAUSSIAN as m,SHADER_SHADOW as g}from"../constants.js";import{ShaderPass as w}from"../shader-pass.js";import{shaderChunks as S}from"../shader-lib/chunks/chunks.js";import{createShaderFromCode as V}from"../shader-lib/utils.js";import{LightCamera as y}from"./light-camera.js";function b(e,t){return Math.exp(-e*e/(2*t*t))}const C=new t,_=new t,v=new Float32Array(2),B=new r(1,1,0,0),M={r:1,g:2,b:3,a:4},O=new t;function D(e){const t=e.material,s=e.skinInstance?10:0;let r=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(r=M[e])}return s+r}class P{constructor(e,t){this.device=e.device,this.renderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.polygonOffsetId=s.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShaderCode=[S.blurVSMPS,"#define GAUSS\n"+S.blurVSMPS];const r="#define PACKED\n";this.blurPackedVsmShaderCode=[r+this.blurVsmShaderCode[0],r+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius")}static createShadowCamera(t,s,r,a){const i=y.create("ShadowCamera",r,a);return i.clearColor=s>=o&&s<=n?new e(0,0,0,0):new e(1,1,1,1),i.clearDepthBuffer=!0,i.clearStencilBuffer=!1,i}static setShadowCameraSettings(e,t,s,r,a){let i=s===h||s===d&&t.webgl2;r!==l||a||(i=!1),e.clearColorBuffer=!i}cullShadowCasters(e,t,s){let r=0;const a=e.length;for(let i=0;i<a;i++){const a=e[i];a.cull&&!a._isVisible(s)||(a.visibleThisFrame=!0,t[r]=a,r++)}t.length=r,t.sort(this.renderer.sortCompareDepth)}setupRenderState(e,t){const s=this.renderer.scene.clusteredLightingEnabled;e.webgl2?t._type!==l||s?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(t._type===l?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset))),e.setBlending(!1),e.setDepthWrite(!0),e.setDepthTest(!0),e.setDepthFunc(a);(s?t._isPcf&&e.webgl2:t._isPcf&&e.webgl2&&t._type!==l)?e.setColorWrite(!1,!1,!1,!1):e.setColorWrite(!0,!0,!0,!0)}restoreRenderState(e){e.webgl2?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,t,r,a){const i=t._node;e._type!==c&&(this.renderer.dispatchViewPos(i.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),C.setTRS(i.getPosition(),i.getRotation(),s.ONE).invert(),_.mul2(t.projectionMatrix,C);const o=r.shadowViewport;t.rect=o,t.scissorRect=r.shadowScissor,O.setViewport(o.x,o.y,o.z,o.w),r.shadowMatrix.mul2(O,_),e._type===c&&e._shadowMatrixPalette.set(r.shadowMatrix.data,16*a)}submitCasters(e,t){const s=this.device,r=this.renderer,a=r.scene,i=1<<g,o=w.getShadow(t._type,t._shadowType),n=e.length;for(let t=0;t<n;t++){const n=e[t],h=n.mesh;n.ensureMaterial(s);const d=n.material;r.setBaseConstants(s,d),r.setSkinning(s,n),d.dirty&&(d.updateUniforms(s,a),d.dirty=!1),d.chunks&&(r.setCullMode(!0,!1,n),d.setParameters(s),n.setParameters(s,i));let l=n._shader[o];l||(n.updatePassShader(a,o),l=n._shader[o],n._key[p]=D(n)),!l.failed&&s.setShader(l),r.setVertexBuffers(s,h),r.setMorphing(s,n.morphInstance);const c=n.renderStyle;s.setIndexBuffer(h.indexBuffer[c]),r.drawInstance(s,n,h,c),r._shadowDrawCalls++}}needsShadowRendering(e){const t=e.enabled&&e.castShadows&&e.shadowUpdateMode!==u&&e.visibleThisFrame;return e.shadowUpdateMode===f&&(e.shadowUpdateMode=u),this.renderer._shadowMapUpdates+=e.numShadowFaces,t}getLightRenderData(e,t,s){return e.getRenderData(e._type===c?t:null,s)}setupRenderPass(e,t,s){const r=t.renderTarget;if(e.init(r),s){const s=t.clearColorBuffer;e.colorOps.clear=s,s&&e.colorOps.clearValue.copy(t.clearColor),e.depthStencilOps.storeDepth=!s,e.setClearDepth(1)}e.requiresCubemaps=!1}prepareFace(e,t,s){const r=e._type,a=e._shadowType,i=this.renderer.scene.clusteredLightingEnabled,o=this.getLightRenderData(e,t,s).shadowCamera;P.setShadowCameraSettings(o,this.device,a,r,i);const n=r===c?0:s;return o.renderTarget=e._shadowMap.renderTargets[n],o}renderFace(e,t,s,r){const a=this.device;this.setupRenderState(a,e);const i=this.getLightRenderData(e,t,s),o=i.shadowCamera;this.dispatchUniforms(e,o,i,s);const n=o.renderTarget;this.renderer.setCameraUniforms(o,n,null),r?this.renderer.clearView(o,n,!0,!1):this.renderer.setupViewport(o,n),this.submitCasters(i.visibleCasters,e),this.restoreRenderState(a)}render(e,t){if(this.needsShadowRendering(e)){const s=e.numShadowFaces;for(let r=0;r<s;r++)this.prepareFace(e,t,r),this.renderFace(e,t,r,!0);this.renderVms(e,t)}}renderVms(e,t){if(e._isVsm&&e._vsmBlurSize>1){this.renderer.scene.clusteredLightingEnabled&&e._type!==c||this.applyVsmBlur(e,t)}}getVsmBlurShader(e,t,s){let r=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][s];if(!r){this.blurVsmWeights[s]=function(e){e>25&&(e=25);const t=(e-1)/6,s=.5*(e-1),r=new Array(e);let a=0;for(let i=0;i<e;++i)r[i]=b(i-s,t),a+=r[i];for(let t=0;t<e;++t)r[t]/=a;return r}(s);const a=S.fullscreenQuadVS;let i="#define SAMPLES "+s+"\n";i+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const o="blurVsm"+t+s+e;r=V(this.device,a,i,o),e?this.blurPackedVsmShader[t][s]=r:this.blurVsmShader[t][s]=r}return r}applyVsmBlur(e,t){const s=this.device,r=e.getRenderData(e._type===c?t:null,0).shadowCamera.renderTarget,a=this.renderer.shadowMapCache.get(s,e),n=a.renderTargets[0],h=e._shadowType===o,d=e.vsmBlurMode,l=e._vsmBlurSize,p=this.getVsmBlurShader(h,d,l);B.z=e._shadowResolution-2,B.w=B.z,this.sourceId.setValue(r.colorBuffer),v[0]=1/e._shadowResolution,v[1]=0,this.pixelOffsetId.setValue(v),d===m&&this.weightId.setValue(this.blurVsmWeights[l]),i(s,n,p,null,B),this.sourceId.setValue(n.colorBuffer),v[1]=v[0],v[0]=0,this.pixelOffsetId.setValue(v),i(s,r,p,null,B),this.renderer.shadowMapCache.add(e,a)}}export{P as ShadowRenderer};
