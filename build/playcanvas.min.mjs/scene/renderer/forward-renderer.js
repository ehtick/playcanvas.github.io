import"../../core/time.js";import"../../core/tracing.js";import{Vec3 as t}from"../../core/math/vec3.js";import{Color as e}from"../../core/math/color.js";import{FUNC_ALWAYS as s,STENCILOP_KEEP as i,BINDGROUP_MESH as a}from"../../platform/graphics/constants.js";import{RenderPass as o}from"../../platform/graphics/render-pass.js";import{LIGHTSHAPE_PUNCTUAL as r,LIGHTTYPE_OMNI as h,LIGHTTYPE_SPOT as n,SHADOWUPDATE_NONE as l,SHADOWUPDATE_THISFRAME as d,LIGHTTYPE_DIRECTIONAL as c,FOG_NONE as g,FOG_LINEAR as p,LAYERID_DEPTH as u,COMPUPDATED_LIGHTS as f}from"../constants.js";import{Renderer as m}from"./renderer.js";import{LightCamera as w}from"./light-camera.js";import"../lighting/world-clusters-debug.js";import{SceneGrab as _}from"../graphics/scene-grab.js";const C=new e(254/255,254/255,254/255,254/255),I={drawCalls:[],isNewMaterial:[],lightMaskChanged:[]};class S extends m{constructor(t){super(t);const e=this.device;this._forwardDrawCalls=0,this._materialSwitches=0,this._depthMapTime=0,this._forwardTime=0,this._sortTime=0;const s=e.scope;this.fogColorId=s.resolve("fog_color"),this.fogStartId=s.resolve("fog_start"),this.fogEndId=s.resolve("fog_end"),this.fogDensityId=s.resolve("fog_density"),this.ambientId=s.resolve("light_globalAmbient"),this.skyboxIntensityId=s.resolve("skyboxIntensity"),this.cubeMapRotationMatrixId=s.resolve("cubeMapRotationMatrix"),this.lightColorId=[],this.lightDir=[],this.lightDirId=[],this.lightShadowMapId=[],this.lightShadowMatrixId=[],this.lightShadowParamsId=[],this.lightShadowIntensity=[],this.lightRadiusId=[],this.lightPos=[],this.lightPosId=[],this.lightWidth=[],this.lightWidthId=[],this.lightHeight=[],this.lightHeightId=[],this.lightInAngleId=[],this.lightOutAngleId=[],this.lightCookieId=[],this.lightCookieIntId=[],this.lightCookieMatrixId=[],this.lightCookieOffsetId=[],this.shadowMatrixPaletteId=[],this.shadowCascadeDistancesId=[],this.shadowCascadeCountId=[],this.screenSizeId=s.resolve("uScreenSize"),this._screenSize=new Float32Array(4),this.fogColor=new Float32Array(3),this.ambientColor=new Float32Array(3)}destroy(){super.destroy()}dispatchGlobalLights(t){if(this.ambientColor[0]=t.ambientLight.r,this.ambientColor[1]=t.ambientLight.g,this.ambientColor[2]=t.ambientLight.b,t.gammaCorrection)for(let t=0;t<3;t++)this.ambientColor[t]=Math.pow(this.ambientColor[t],2.2);if(t.physicalUnits)for(let e=0;e<3;e++)this.ambientColor[e]*=t.ambientLuminance;this.ambientId.setValue(this.ambientColor),this.skyboxIntensityId.setValue(t.physicalUnits?t.skyboxLuminance:t.skyboxIntensity),this.cubeMapRotationMatrixId.setValue(t._skyboxRotationMat3.data)}_resolveLight(t,e){const s="light"+e;this.lightColorId[e]=t.resolve(s+"_color"),this.lightDir[e]=new Float32Array(3),this.lightDirId[e]=t.resolve(s+"_direction"),this.lightShadowMapId[e]=t.resolve(s+"_shadowMap"),this.lightShadowMatrixId[e]=t.resolve(s+"_shadowMatrix"),this.lightShadowParamsId[e]=t.resolve(s+"_shadowParams"),this.lightShadowIntensity[e]=t.resolve(s+"_shadowIntensity"),this.lightRadiusId[e]=t.resolve(s+"_radius"),this.lightPos[e]=new Float32Array(3),this.lightPosId[e]=t.resolve(s+"_position"),this.lightWidth[e]=new Float32Array(3),this.lightWidthId[e]=t.resolve(s+"_halfWidth"),this.lightHeight[e]=new Float32Array(3),this.lightHeightId[e]=t.resolve(s+"_halfHeight"),this.lightInAngleId[e]=t.resolve(s+"_innerConeAngle"),this.lightOutAngleId[e]=t.resolve(s+"_outerConeAngle"),this.lightCookieId[e]=t.resolve(s+"_cookie"),this.lightCookieIntId[e]=t.resolve(s+"_cookieIntensity"),this.lightCookieMatrixId[e]=t.resolve(s+"_cookieMatrix"),this.lightCookieOffsetId[e]=t.resolve(s+"_cookieOffset"),this.shadowMatrixPaletteId[e]=t.resolve(s+"_shadowMatrixPalette[0]"),this.shadowCascadeDistancesId[e]=t.resolve(s+"_shadowCascadeDistances[0]"),this.shadowCascadeCountId[e]=t.resolve(s+"_shadowCascadeCount")}setLTCDirectionalLight(e,s,i,a,o){this.lightPos[s][0]=a.x-i.x*o,this.lightPos[s][1]=a.y-i.y*o,this.lightPos[s][2]=a.z-i.z*o,this.lightPosId[s].setValue(this.lightPos[s]);const r=e.transformVector(new t(-.5,0,0));this.lightWidth[s][0]=r.x*o,this.lightWidth[s][1]=r.y*o,this.lightWidth[s][2]=r.z*o,this.lightWidthId[s].setValue(this.lightWidth[s]);const h=e.transformVector(new t(0,0,.5));this.lightHeight[s][0]=h.x*o,this.lightHeight[s][1]=h.y*o,this.lightHeight[s][2]=h.z*o,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchDirectLights(t,e,s,i){let a=0;const o=this.device.scope;for(let h=0;h<t.length;h++){if(!(t[h].mask&s))continue;const n=t[h],l=n._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(o,a),this.lightColorId[a].setValue(e.gammaCorrection?n._linearFinalColor:n._finalColor),l.getY(n._direction).mulScalar(-1),n._direction.normalize(),this.lightDir[a][0]=n._direction.x,this.lightDir[a][1]=n._direction.y,this.lightDir[a][2]=n._direction.z,this.lightDirId[a].setValue(this.lightDir[a]),n.shape!==r&&this.setLTCDirectionalLight(l,a,n._direction,i._node.getPosition(),i.farClip),n.castShadows){const t=n.getRenderData(i,0),e=n._getUniformBiasValues(t);this.lightShadowMapId[a].setValue(t.shadowBuffer),this.lightShadowMatrixId[a].setValue(t.shadowMatrix.data),this.shadowMatrixPaletteId[a].setValue(n._shadowMatrixPalette),this.shadowCascadeDistancesId[a].setValue(n._shadowCascadeDistances),this.shadowCascadeCountId[a].setValue(n.numCascades),this.lightShadowIntensity[a].setValue(n.shadowIntensity);const s=n._shadowRenderParams;s.length=3,s[0]=n._shadowResolution,s[1]=e.normalBias,s[2]=e.bias,this.lightShadowParamsId[a].setValue(s)}a++}return a}setLTCPositionalLight(e,s){const i=e.transformVector(new t(-.5,0,0));this.lightWidth[s][0]=i.x,this.lightWidth[s][1]=i.y,this.lightWidth[s][2]=i.z,this.lightWidthId[s].setValue(this.lightWidth[s]);const a=e.transformVector(new t(0,0,.5));this.lightHeight[s][0]=a.x,this.lightHeight[s][1]=a.y,this.lightHeight[s][2]=a.z,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchOmniLight(t,e,s,i){const a=s._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(e,i),this.lightRadiusId[i].setValue(s.attenuationEnd),this.lightColorId[i].setValue(t.gammaCorrection?s._linearFinalColor:s._finalColor),a.getTranslation(s._position),this.lightPos[i][0]=s._position.x,this.lightPos[i][1]=s._position.y,this.lightPos[i][2]=s._position.z,this.lightPosId[i].setValue(this.lightPos[i]),s.shape!==r&&this.setLTCPositionalLight(a,i),s.castShadows){const t=s.getRenderData(null,0);this.lightShadowMapId[i].setValue(t.shadowBuffer);const e=s._getUniformBiasValues(t),a=s._shadowRenderParams;a.length=4,a[0]=s._shadowResolution,a[1]=e.normalBias,a[2]=e.bias,a[3]=1/s.attenuationEnd,this.lightShadowParamsId[i].setValue(a),this.lightShadowIntensity[i].setValue(s.shadowIntensity)}s._cookie&&(this.lightCookieId[i].setValue(s._cookie),this.lightShadowMatrixId[i].setValue(a.data),this.lightCookieIntId[i].setValue(s.cookieIntensity))}dispatchSpotLight(t,e,s,i){const a=s._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(e,i),this.lightInAngleId[i].setValue(s._innerConeAngleCos),this.lightOutAngleId[i].setValue(s._outerConeAngleCos),this.lightRadiusId[i].setValue(s.attenuationEnd),this.lightColorId[i].setValue(t.gammaCorrection?s._linearFinalColor:s._finalColor),a.getTranslation(s._position),this.lightPos[i][0]=s._position.x,this.lightPos[i][1]=s._position.y,this.lightPos[i][2]=s._position.z,this.lightPosId[i].setValue(this.lightPos[i]),s.shape!==r&&this.setLTCPositionalLight(a,i),a.getY(s._direction).mulScalar(-1),s._direction.normalize(),this.lightDir[i][0]=s._direction.x,this.lightDir[i][1]=s._direction.y,this.lightDir[i][2]=s._direction.z,this.lightDirId[i].setValue(this.lightDir[i]),s.castShadows){const t=s.getRenderData(null,0);this.lightShadowMapId[i].setValue(t.shadowBuffer),this.lightShadowMatrixId[i].setValue(t.shadowMatrix.data);const e=s._getUniformBiasValues(t),a=s._shadowRenderParams;a.length=4,a[0]=s._shadowResolution,a[1]=e.normalBias,a[2]=e.bias,a[3]=1/s.attenuationEnd,this.lightShadowParamsId[i].setValue(a),this.lightShadowIntensity[i].setValue(s.shadowIntensity)}if(s._cookie){if(!s.castShadows){const t=w.evalSpotCookieMatrix(s);this.lightShadowMatrixId[i].setValue(t.data)}this.lightCookieId[i].setValue(s._cookie),this.lightCookieIntId[i].setValue(s.cookieIntensity),s._cookieTransform&&(s._cookieTransformUniform[0]=s._cookieTransform.x,s._cookieTransformUniform[1]=s._cookieTransform.y,s._cookieTransformUniform[2]=s._cookieTransform.z,s._cookieTransformUniform[3]=s._cookieTransform.w,this.lightCookieMatrixId[i].setValue(s._cookieTransformUniform),s._cookieOffsetUniform[0]=s._cookieOffset.x,s._cookieOffsetUniform[1]=s._cookieOffset.y,this.lightCookieOffsetId[i].setValue(s._cookieOffsetUniform))}}dispatchLocalLights(t,e,s,i,a){let o=i;const r=this.device.scope,l=t[h],d=l.length;for(let t=0;t<d;t++){const i=l[t];i.mask&s&&(i.isStatic||(this.dispatchOmniLight(e,r,i,o),o++))}let c=0;if(a){let t=a[c];for(;t&&t._type===h;)this.dispatchOmniLight(e,r,t,o),o++,c++,t=a[c]}const g=t[n],p=g.length;for(let t=0;t<p;t++){const i=g[t];i.mask&s&&(i.isStatic||(this.dispatchSpotLight(e,r,i,o),o++))}if(a){let t=a[c];for(;t&&t._type===n;)this.dispatchSpotLight(e,r,t,o),o++,c++,t=a[c]}}renderShadowsLocal(t,e){const s=this.scene.clusteredLightingEnabled;for(let i=0;i<t.length;i++){const a=t[i];if(s){if(!a.atlasViewportAllocated)continue;a.atlasSlotUpdated&&a.shadowUpdateMode===l&&(a.shadowUpdateMode=d)}this._shadowRendererLocal.render(a,e)}}renderForwardPrepareMaterials(t,e,s,i,a,o,r){const h=(t,e,s)=>{I.drawCalls.push(t),I.isNewMaterial.push(e),I.lightMaskChanged.push(s)};I.drawCalls.length=0,I.isNewMaterial.length=0,I.lightMaskChanged.length=0;const n=this.device,l=this.scene,d=o?o._lightHash:0;let c,g,p,u=null;for(let t=0;t<s;t++){const s=e[t];if(!a||!s.mask||a&s.mask)if(s.command)h(s,!1,!1);else{s.ensureMaterial(n);const t=s.material,e=s._shaderDefs,a=s.mask;if(t&&t===u&&e!==c&&(u=null),(s.isStatic||g)&&(u=null),t!==u&&(this._materialSwitches++,t._scene=l,t.dirty&&(t.updateUniforms(n,l),t.dirty=!1),t._dirtyBlend&&(l.layers._dirtyBlend=!0)),!s._shader[r]||s._shaderDefs!==e||s._lightHash!==d){if(s.isStatic)s.updatePassShader(l,r,s._staticLightList,i,this.viewUniformFormat,this.viewBindGroupFormat);else{const a=r+"_"+e+"_"+d;s._shader[r]=t.variants[a],s._shader[r]||(s.updatePassShader(l,r,null,i,this.viewUniformFormat,this.viewBindGroupFormat),t.variants[a]=s._shader[r])}s._lightHash=d}h(s,t!==u,!u||a!==p),u=t,c=e,p=a,g=s.isStatic}}return I}renderForwardInternal(t,e,o,r,h,n){const l=this.device,d=l.supportsUniformBuffers,g=this.scene,p=1<<r,u=e.drawCalls.length;for(let f=0;f<u;f++){const m=e.drawCalls[f];if(m.command)m.command();else{const w=e.isNewMaterial[f],_=e.lightMaskChanged[f],C=m.material;m._shaderDefs;const I=m.mask;if(w){const e=m._shader[r];if(!e.failed&&l.setShader(e),C.setParameters(l),_){const e=this.dispatchDirectLights(o[c],g,I,t);this.dispatchLocalLights(o,g,I,e,m._staticLightList)}this.alphaTestId.setValue(C.alphaTest),l.setBlending(C.blend),C.blend&&(C.separateAlphaBlend?(l.setBlendFunctionSeparate(C.blendSrc,C.blendDst,C.blendSrcAlpha,C.blendDstAlpha),l.setBlendEquationSeparate(C.blendEquation,C.blendAlphaEquation)):(l.setBlendFunction(C.blendSrc,C.blendDst),l.setBlendEquation(C.blendEquation))),l.setColorWrite(C.redWrite,C.greenWrite,C.blueWrite,C.alphaWrite),l.setDepthWrite(C.depthWrite),C.depthWrite&&!C.depthTest?(l.setDepthFunc(s),l.setDepthTest(!0)):(l.setDepthFunc(C.depthFunc),l.setDepthTest(C.depthTest)),l.setAlphaToCoverage(C.alphaToCoverage),C.depthBias||C.slopeDepthBias?(l.setDepthBias(!0),l.setDepthBiasValues(C.depthBias,C.slopeDepthBias)):l.setDepthBias(!1)}this.setCullMode(t._cullFaces,n,m);const S=m.stencilFront||C.stencilFront,P=m.stencilBack||C.stencilBack;S||P?(l.setStencilTest(!0),S===P?(l.setStencilFunc(S.func,S.ref,S.readMask),l.setStencilOperation(S.fail,S.zfail,S.zpass,S.writeMask)):(S?(l.setStencilFuncFront(S.func,S.ref,S.readMask),l.setStencilOperationFront(S.fail,S.zfail,S.zpass,S.writeMask)):(l.setStencilFuncFront(s,0,255),l.setStencilOperationFront(i,i,i,255)),P?(l.setStencilFuncBack(P.func,P.ref,P.readMask),l.setStencilOperationBack(P.fail,P.zfail,P.zpass,P.writeMask)):(l.setStencilFuncBack(s,0,255),l.setStencilOperationBack(i,i,i,255)))):l.setStencilTest(!1);const v=m.mesh;if(m.setParameters(l,p),this.setVertexBuffers(l,v),this.setMorphing(l,m.morphInstance),this.setSkinning(l,m),d){this.modelMatrixId.setValue(m.node.worldTransform.data),this.normalMatrixId.setValue(m.node.normalMatrix.data);const t=m.getBindGroup(l,r);t.defaultUniformBuffer.update(),t.update(),l.setBindGroup(a,t)}const y=m.renderStyle;if(l.setIndexBuffer(v.indexBuffer[y]),h&&h(m,f),t.xr&&t.xr.session&&t.xr.views.length){const e=t.xr.views;for(let t=0;t<e.length;t++){const s=e[t];l.setViewport(s.viewport.x,s.viewport.y,s.viewport.z,s.viewport.w),this.projId.setValue(s.projMat.data),this.projSkyboxId.setValue(s.projMat.data),this.viewId.setValue(s.viewOffMat.data),this.viewInvId.setValue(s.viewInvOffMat.data),this.viewId3.setValue(s.viewMat3.data),this.viewProjId.setValue(s.projViewOffMat.data),this.viewPosId.setValue(s.position),0===t?this.drawInstance(l,m,v,y,!0):this.drawInstance2(l,m,v,y),this._forwardDrawCalls++}}else this.drawInstance(l,m,v,y,!0),this._forwardDrawCalls++;f<u-1&&!e.isNewMaterial[f+1]&&C.setParameters(l,m.parameters)}}}renderForward(t,e,s,i,a,o,r,h,n){const l=this.renderForwardPrepareMaterials(t,e,s,i,o,h,a);this.renderForwardInternal(t,l,i,a,r,n),I.length=0}setSceneConstants(){const t=this.scene;if(this.dispatchGlobalLights(t),t.fog!==g){if(this.fogColor[0]=t.fogColor.r,this.fogColor[1]=t.fogColor.g,this.fogColor[2]=t.fogColor.b,t.gammaCorrection)for(let t=0;t<3;t++)this.fogColor[t]=Math.pow(this.fogColor[t],2.2);this.fogColorId.setValue(this.fogColor),t.fog===p?(this.fogStartId.setValue(t.fogStart),this.fogEndId.setValue(t.fogEnd)):this.fogDensityId.setValue(t.fogDensity)}const e=this.device;this._screenSize[0]=e.width,this._screenSize[1]=e.height,this._screenSize[2]=1/e.width,this._screenSize[3]=1/e.height,this.screenSizeId.setValue(this._screenSize)}updateLightStats(t,e){}buildFrameGraph(t,e){t.reset(),this.update(e);const s=this.scene.clusteredLightingEnabled;if(s){this.updateLightTextureAtlas(e);const s=new o(this.device,(()=>{this.scene.lighting.cookiesEnabled&&(this.renderCookies(e._splitLights[n]),this.renderCookies(e._splitLights[h]))}));s.requiresCubemaps=!1,t.addRenderPass(s)}const i=new o(this.device,(()=>{(!s||s&&this.scene.lighting.shadowsEnabled)&&(this.renderShadowsLocal(e._splitLights[n]),this.renderShadowsLocal(e._splitLights[h])),s&&this.updateClusters(e)}));i.requiresCubemaps=!1,t.addRenderPass(i);let a=0,r=!0,l=null;const d=e._renderActions;for(let s=a;s<d.length;s++){const i=d[s],h=e.layerList[i.layerIndex],n=h.cameras[i.cameraIndex];if(!i.isLayerEnabled(e))continue;const c=h.id===u&&(n.renderSceneColorMap||n.renderSceneDepthMap);i.hasDirectionalShadowLights&&n&&this._shadowRendererDirectional.buildFrameGraph(t,i,n),r&&(r=!1,a=s,l=i.renderTarget);let g=s+1;for(;d[g]&&!d[g].isLayerEnabled(e);)g++;const p=d[g],f=!!p&&e.layerList[p.layerIndex].id===u&&(n.renderSceneColorMap||n.renderSceneDepthMap);if(!p||p.renderTarget!==l||p.hasDirectionalShadowLights||f||c){if(this.addMainRenderPass(t,e,l,a,s,c),i.triggerPostprocess&&null!=n&&n.onPostprocessing){const s=new o(this.device,(()=>{this.renderPassPostprocessing(i,e)}));s.requiresCubemaps=!1,t.addRenderPass(s)}r=!0}}}addMainRenderPass(t,e,s,i,a,r){const h={start:i,end:a},n=new o(this.device,(()=>{this.renderPassRenderActions(e,h)})),l=e._renderActions[i],d=e.layerList[l.layerIndex].cameras[l.cameraIndex],c=r&&_.requiresRenderPass(this.device,d);(!r||c)&&(n.init(s),n.fullSizeClearRect=d.camera.fullSizeClearRect,c?(n.setClearColor(C),n.setClearDepth(1)):n.fullSizeClearRect&&(l.clearColor&&n.setClearColor(d.camera.clearColor),l.clearDepth&&n.setClearDepth(d.camera.clearDepth),l.clearStencil&&n.setClearStencil(d.camera.clearStencil))),t.addRenderPass(n)}update(t){this.baseUpdate();const e=this.scene.clusteredLightingEnabled;this.scene._updateSky(this.device);const s=this.updateLayerComposition(t,e),i=0!=(s&f);this.updateLightStats(t,s),this.beginFrame(t,i),this.setSceneConstants(),this.cullComposition(t),this.gpuUpdate(t._meshInstances)}renderPassPostprocessing(t,e){e.layerList[t.layerIndex].cameras[t.cameraIndex].onPostprocessing()}renderPassRenderActions(t,e){const s=t._renderActions;for(let i=e.start;i<=e.end;i++)this.renderRenderAction(t,s[i],i===e.start)}renderRenderAction(t,e,s){const i=this.scene.clusteredLightingEnabled,a=this.device,o=e.layerIndex,r=t.layerList[o],h=t.subLayerList[o],n=e.cameraIndex,l=r.cameras[n];if(e.isLayerEnabled(t)){if(l&&e.firstCameraUse&&l.onPreRender&&l.onPreRender(),!h&&r.onPreRenderOpaque?r.onPreRenderOpaque(n):h&&r.onPreRenderTransparent&&r.onPreRenderTransparent(n),r._preRenderCalledForCameras&1<<n||(r.onPreRender&&r.onPreRender(n),r._preRenderCalledForCameras|=1<<n),l){var d;this.setupViewport(l.camera,e.renderTarget),s&&l.camera.fullSizeClearRect||this.clear(e,l.camera),r._sortVisible(h,l.camera.node,n);const t=r.instances,o=h?t.visibleTransparent[n]:t.visibleOpaque[n];this.scene.immediate.onPreRenderLayer(r,o,h),i&&e.lightClusters&&(e.lightClusters.activate(this.lightTextureAtlas),this.clustersDebugRendered||this.scene.lighting.debugLayer!==r.id||(this.clustersDebugRendered=!0)),this.scene._activeCamera=l.camera,this.setCameraUniforms(l.camera,e.renderTarget,e);const c=!!(l.camera._flipFaces^(null==e||null==(d=e.renderTarget)?void 0:d.flipY)),g=this._forwardDrawCalls;this.renderForward(l.camera,o.list,o.length,r._splitLights,r.shaderPass,r.cullingMask,r.onDrawCall,r,c),r._forwardDrawCalls+=this._forwardDrawCalls-g,a.setColorWrite(!0,!0,!0,!0),a.setStencilTest(!1),a.setAlphaToCoverage(!1),a.setDepthBias(!1),e.lastCameraUse&&l.onPostRender&&l.onPostRender()}!h&&r.onPostRenderOpaque?r.onPostRenderOpaque(n):h&&r.onPostRenderTransparent&&r.onPostRenderTransparent(n),!r.onPostRender||r._postRenderCalledForCameras&1<<n||(r._postRenderCounter&=~(h?2:1),0===r._postRenderCounter&&(r.onPostRender(n),r._postRenderCalledForCameras|=1<<n,r._postRenderCounter=r._postRenderCounterMax))}}}export{S as ForwardRenderer};
