import"../../core/time.js";import"../../core/debug.js";import{Vec3 as e}from"../../core/math/vec3.js";import{Color as t}from"../../core/math/color.js";import{RenderPass as s}from"../../platform/graphics/render-pass.js";import{LIGHTSHAPE_PUNCTUAL as i,LIGHTTYPE_OMNI as a,LIGHTTYPE_SPOT as r,LIGHTTYPE_DIRECTIONAL as o,FOG_NONE as h,FOG_LINEAR as n,LAYERID_DEPTH as l,COMPUPDATED_LIGHTS as d}from"../constants.js";import{Renderer as c}from"./renderer.js";import{LightCamera as g}from"./light-camera.js";import"../lighting/world-clusters-debug.js";import{SceneGrab as m}from"../graphics/scene-grab.js";import{BlendState as p}from"../../platform/graphics/blend-state.js";const u=new t(254/255,254/255,254/255,254/255),f={drawCalls:[],isNewMaterial:[],lightMaskChanged:[],clear:function(){this.drawCalls.length=0,this.isNewMaterial.length=0,this.lightMaskChanged.length=0}};class C extends c{constructor(e){super(e);const t=this.device;this._forwardDrawCalls=0,this._materialSwitches=0,this._depthMapTime=0,this._forwardTime=0,this._sortTime=0;const s=t.scope;this.fogColorId=s.resolve("fog_color"),this.fogStartId=s.resolve("fog_start"),this.fogEndId=s.resolve("fog_end"),this.fogDensityId=s.resolve("fog_density"),this.ambientId=s.resolve("light_globalAmbient"),this.skyboxIntensityId=s.resolve("skyboxIntensity"),this.cubeMapRotationMatrixId=s.resolve("cubeMapRotationMatrix"),this.pcssDiskSamplesId=s.resolve("pcssDiskSamples[0]"),this.pcssSphereSamplesId=s.resolve("pcssSphereSamples[0]"),this.lightColorId=[],this.lightDir=[],this.lightDirId=[],this.lightShadowMapId=[],this.lightShadowMatrixId=[],this.lightShadowParamsId=[],this.lightShadowIntensity=[],this.lightRadiusId=[],this.lightPos=[],this.lightPosId=[],this.lightWidth=[],this.lightWidthId=[],this.lightHeight=[],this.lightHeightId=[],this.lightInAngleId=[],this.lightOutAngleId=[],this.lightCookieId=[],this.lightCookieIntId=[],this.lightCookieMatrixId=[],this.lightCookieOffsetId=[],this.lightShadowSearchAreaId=[],this.lightCameraParamsId=[],this.shadowMatrixPaletteId=[],this.shadowCascadeDistancesId=[],this.shadowCascadeCountId=[],this.screenSizeId=s.resolve("uScreenSize"),this._screenSize=new Float32Array(4),this.fogColor=new Float32Array(3),this.ambientColor=new Float32Array(3),this.pcssDiskSamples=function(e){const t=[];for(let s=0;s<e;++s){const i=Math.sqrt(s+.5)/Math.sqrt(e);t.push(i)}return t}(16),this.pcssSphereSamples=function(e){const t=[];for(let s=0;s<e;s++){const i=s/e,a=Math.sqrt(1-i*i);t.push(a)}return t}(16)}destroy(){super.destroy()}dispatchGlobalLights(e){if(this.ambientColor[0]=e.ambientLight.r,this.ambientColor[1]=e.ambientLight.g,this.ambientColor[2]=e.ambientLight.b,e.gammaCorrection)for(let e=0;e<3;e++)this.ambientColor[e]=Math.pow(this.ambientColor[e],2.2);if(e.physicalUnits)for(let t=0;t<3;t++)this.ambientColor[t]*=e.ambientLuminance;this.ambientId.setValue(this.ambientColor),this.skyboxIntensityId.setValue(e.physicalUnits?e.skyboxLuminance:e.skyboxIntensity),this.cubeMapRotationMatrixId.setValue(e._skyboxRotationMat3.data)}_resolveLight(e,t){const s="light"+t;this.lightColorId[t]=e.resolve(s+"_color"),this.lightDir[t]=new Float32Array(3),this.lightDirId[t]=e.resolve(s+"_direction"),this.lightShadowMapId[t]=e.resolve(s+"_shadowMap"),this.lightShadowMatrixId[t]=e.resolve(s+"_shadowMatrix"),this.lightShadowParamsId[t]=e.resolve(s+"_shadowParams"),this.lightShadowIntensity[t]=e.resolve(s+"_shadowIntensity"),this.lightShadowSearchAreaId[t]=e.resolve(s+"_shadowSearchArea"),this.lightRadiusId[t]=e.resolve(s+"_radius"),this.lightPos[t]=new Float32Array(3),this.lightPosId[t]=e.resolve(s+"_position"),this.lightWidth[t]=new Float32Array(3),this.lightWidthId[t]=e.resolve(s+"_halfWidth"),this.lightHeight[t]=new Float32Array(3),this.lightHeightId[t]=e.resolve(s+"_halfHeight"),this.lightInAngleId[t]=e.resolve(s+"_innerConeAngle"),this.lightOutAngleId[t]=e.resolve(s+"_outerConeAngle"),this.lightCookieId[t]=e.resolve(s+"_cookie"),this.lightCookieIntId[t]=e.resolve(s+"_cookieIntensity"),this.lightCookieMatrixId[t]=e.resolve(s+"_cookieMatrix"),this.lightCookieOffsetId[t]=e.resolve(s+"_cookieOffset"),this.lightCameraParamsId[t]=e.resolve(s+"_cameraParams"),this.shadowMatrixPaletteId[t]=e.resolve(s+"_shadowMatrixPalette[0]"),this.shadowCascadeDistancesId[t]=e.resolve(s+"_shadowCascadeDistances[0]"),this.shadowCascadeCountId[t]=e.resolve(s+"_shadowCascadeCount")}setLTCDirectionalLight(t,s,i,a,r){this.lightPos[s][0]=a.x-i.x*r,this.lightPos[s][1]=a.y-i.y*r,this.lightPos[s][2]=a.z-i.z*r,this.lightPosId[s].setValue(this.lightPos[s]);const o=t.transformVector(new e(-.5,0,0));this.lightWidth[s][0]=o.x*r,this.lightWidth[s][1]=o.y*r,this.lightWidth[s][2]=o.z*r,this.lightWidthId[s].setValue(this.lightWidth[s]);const h=t.transformVector(new e(0,0,.5));this.lightHeight[s][0]=h.x*r,this.lightHeight[s][1]=h.y*r,this.lightHeight[s][2]=h.z*r,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchDirectLights(e,t,s,a){let r=0;const o=this.device.scope;for(let h=0;h<e.length;h++){if(!(e[h].mask&s))continue;const n=e[h],l=n._node.getWorldTransform();if(this.lightColorId[r]||this._resolveLight(o,r),this.lightColorId[r].setValue(t.gammaCorrection?n._linearFinalColor:n._finalColor),l.getY(n._direction).mulScalar(-1),n._direction.normalize(),this.lightDir[r][0]=n._direction.x,this.lightDir[r][1]=n._direction.y,this.lightDir[r][2]=n._direction.z,this.lightDirId[r].setValue(this.lightDir[r]),n.shape!==i&&this.setLTCDirectionalLight(l,r,n._direction,a._node.getPosition(),a.farClip),n.castShadows){const e=n.getRenderData(a,0),t=n._getUniformBiasValues(e);this.lightShadowMapId[r].setValue(e.shadowBuffer),this.lightShadowMatrixId[r].setValue(e.shadowMatrix.data),this.shadowMatrixPaletteId[r].setValue(n._shadowMatrixPalette),this.shadowCascadeDistancesId[r].setValue(n._shadowCascadeDistances),this.shadowCascadeCountId[r].setValue(n.numCascades),this.lightShadowIntensity[r].setValue(n.shadowIntensity);const s=1/(e.shadowCamera.renderTarget.width/n.penumbraSize);this.lightShadowSearchAreaId[r].setValue(s);const i=n._shadowCameraParams;i.length=4,i[0]=0,i[1]=e.shadowCamera._farClip,i[2]=e.shadowCamera._nearClip,i[3]=1,this.lightCameraParamsId[r].setValue(i);const o=n._shadowRenderParams;o.length=4,o[0]=n._shadowResolution,o[1]=t.normalBias,o[2]=t.bias,o[3]=0,this.lightShadowParamsId[r].setValue(o)}r++}return r}setLTCPositionalLight(t,s){const i=t.transformVector(new e(-.5,0,0));this.lightWidth[s][0]=i.x,this.lightWidth[s][1]=i.y,this.lightWidth[s][2]=i.z,this.lightWidthId[s].setValue(this.lightWidth[s]);const a=t.transformVector(new e(0,0,.5));this.lightHeight[s][0]=a.x,this.lightHeight[s][1]=a.y,this.lightHeight[s][2]=a.z,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchOmniLight(e,t,s,a){const r=s._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(t,a),this.lightRadiusId[a].setValue(s.attenuationEnd),this.lightColorId[a].setValue(e.gammaCorrection?s._linearFinalColor:s._finalColor),r.getTranslation(s._position),this.lightPos[a][0]=s._position.x,this.lightPos[a][1]=s._position.y,this.lightPos[a][2]=s._position.z,this.lightPosId[a].setValue(this.lightPos[a]),s.shape!==i&&this.setLTCPositionalLight(r,a),s.castShadows){const e=s.getRenderData(null,0);this.lightShadowMapId[a].setValue(e.shadowBuffer);const t=s._getUniformBiasValues(e),i=s._shadowRenderParams;i.length=4,i[0]=s._shadowResolution,i[1]=t.normalBias,i[2]=t.bias,i[3]=1/s.attenuationEnd,this.lightShadowParamsId[a].setValue(i),this.lightShadowIntensity[a].setValue(s.shadowIntensity);const r=1/(e.shadowCamera.renderTarget.width/s.penumbraSize);this.lightShadowSearchAreaId[a].setValue(r);const o=s._shadowCameraParams;o.length=4,o[0]=0,o[1]=e.shadowCamera._farClip,o[2]=e.shadowCamera._nearClip,o[3]=0,this.lightCameraParamsId[a].setValue(o)}s._cookie&&(this.lightCookieId[a].setValue(s._cookie),this.lightShadowMatrixId[a].setValue(r.data),this.lightCookieIntId[a].setValue(s.cookieIntensity))}dispatchSpotLight(e,t,s,a){const r=s._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(t,a),this.lightInAngleId[a].setValue(s._innerConeAngleCos),this.lightOutAngleId[a].setValue(s._outerConeAngleCos),this.lightRadiusId[a].setValue(s.attenuationEnd),this.lightColorId[a].setValue(e.gammaCorrection?s._linearFinalColor:s._finalColor),r.getTranslation(s._position),this.lightPos[a][0]=s._position.x,this.lightPos[a][1]=s._position.y,this.lightPos[a][2]=s._position.z,this.lightPosId[a].setValue(this.lightPos[a]),s.shape!==i&&this.setLTCPositionalLight(r,a),r.getY(s._direction).mulScalar(-1),s._direction.normalize(),this.lightDir[a][0]=s._direction.x,this.lightDir[a][1]=s._direction.y,this.lightDir[a][2]=s._direction.z,this.lightDirId[a].setValue(this.lightDir[a]),s.castShadows){const e=s.getRenderData(null,0);this.lightShadowMapId[a].setValue(e.shadowBuffer),this.lightShadowMatrixId[a].setValue(e.shadowMatrix.data);const t=s._getUniformBiasValues(e),i=s._shadowRenderParams;i.length=4,i[0]=s._shadowResolution,i[1]=t.normalBias,i[2]=t.bias,i[3]=1/s.attenuationEnd,this.lightShadowParamsId[a].setValue(i),this.lightShadowIntensity[a].setValue(s.shadowIntensity);const r=1/(e.shadowCamera.renderTarget.width/s.penumbraSize),o=e.shadowCamera._fov*Math.PI/180,h=1/Math.tan(o/2);this.lightShadowSearchAreaId[a].setValue(r*h);const n=s._shadowCameraParams;n.length=4,n[0]=0,n[1]=e.shadowCamera._farClip,n[2]=e.shadowCamera._nearClip,n[3]=0,this.lightCameraParamsId[a].setValue(n)}if(s._cookie){if(!s.castShadows){const e=g.evalSpotCookieMatrix(s);this.lightShadowMatrixId[a].setValue(e.data)}this.lightCookieId[a].setValue(s._cookie),this.lightCookieIntId[a].setValue(s.cookieIntensity),s._cookieTransform&&(s._cookieTransformUniform[0]=s._cookieTransform.x,s._cookieTransformUniform[1]=s._cookieTransform.y,s._cookieTransformUniform[2]=s._cookieTransform.z,s._cookieTransformUniform[3]=s._cookieTransform.w,this.lightCookieMatrixId[a].setValue(s._cookieTransformUniform),s._cookieOffsetUniform[0]=s._cookieOffset.x,s._cookieOffsetUniform[1]=s._cookieOffset.y,this.lightCookieOffsetId[a].setValue(s._cookieOffsetUniform))}}dispatchLocalLights(e,t,s,i,o){let h=i;const n=this.device.scope,l=e[a],d=l.length;for(let e=0;e<d;e++){const i=l[e];i.mask&s&&(i.isStatic||(this.dispatchOmniLight(t,n,i,h),h++))}let c=0;if(o){let e=o[c];for(;e&&e._type===a;)this.dispatchOmniLight(t,n,e,h),h++,c++,e=o[c]}const g=e[r],m=g.length;for(let e=0;e<m;e++){const i=g[e];i.mask&s&&(i.isStatic||(this.dispatchSpotLight(t,n,i,h),h++))}if(o){let e=o[c];for(;e&&e._type===r;)this.dispatchSpotLight(t,n,e,h),h++,c++,e=o[c]}}renderForwardPrepareMaterials(e,t,s,i,a,r,o){const h=(e,t,s)=>{f.drawCalls.push(e),f.isNewMaterial.push(t),f.lightMaskChanged.push(s)};f.clear();const n=this.device,l=this.scene,d=r?r._lightHash:0;let c,g,m,p=null;for(let e=0;e<s;e++){const s=t[e];if(!a||!s.mask||a&s.mask)if(s.command)h(s,!1,!1);else{s.ensureMaterial(n);const e=s.material,t=s._shaderDefs,a=s.mask;if(e&&e===p&&t!==c&&(p=null),(s.isStatic||g)&&(p=null),e!==p&&(this._materialSwitches++,e._scene=l,e.dirty&&(e.updateUniforms(n,l),e.dirty=!1),e._dirtyBlend&&(l.layers._dirtyBlend=!0)),!s._shader[o]||s._shaderDefs!==t||s._lightHash!==d){if(s.isStatic)s.updatePassShader(l,o,s._staticLightList,i,this.viewUniformFormat,this.viewBindGroupFormat);else{const a=o+"_"+t+"_"+d;s._shader[o]=e.variants[a],s._shader[o]||(s.updatePassShader(l,o,null,i,this.viewUniformFormat,this.viewBindGroupFormat),e.variants[a]=s._shader[o])}s._lightHash=d}h(s,e!==p,!p||a!==m),p=e,c=t,m=a,g=s.isStatic}}return null==n.endShaderBatch||n.endShaderBatch(),f}renderForwardInternal(e,t,s,i,a,r){const h=this.device,n=this.scene,l=1<<i,d=r?-1:1;let c=!1;const g=t.drawCalls.length;for(let r=0;r<g;r++){const u=t.drawCalls[r];if(u.command)u.command();else{var m,p;const f=t.isNewMaterial[r],C=t.lightMaskChanged[r],w=u.material;u._shaderDefs;const _=u.mask;if(f){const t=u._shader[i];if(!t.failed&&h.setShader(t),c=t.failed,c)break;if(w.setParameters(h),C){const t=this.dispatchDirectLights(s[o],n,_,e);this.dispatchLocalLights(s,n,_,t,u._staticLightList)}this.alphaTestId.setValue(w.alphaTest),h.setBlendState(w.blendState),h.setDepthState(w.depthState),h.setAlphaToCoverage(w.alphaToCoverage),w.depthBias||w.slopeDepthBias?(h.setDepthBias(!0),h.setDepthBiasValues(w.depthBias,w.slopeDepthBias)):h.setDepthBias(!1)}this.setupCullMode(e._cullFaces,d,u);const I=null!=(m=u.stencilFront)?m:w.stencilFront,S=null!=(p=u.stencilBack)?p:w.stencilBack;h.setStencilState(I,S);const P=u.mesh;u.setParameters(h,l),this.setVertexBuffers(h,P),this.setMorphing(h,u.morphInstance),this.setSkinning(h,u),this.setupMeshUniformBuffers(u,i);const v=u.renderStyle;if(h.setIndexBuffer(P.indexBuffer[v]),null==a||a(u,r),e.xr&&e.xr.session&&e.xr.views.length){const t=e.xr.views;for(let e=0;e<t.length;e++){const s=t[e];h.setViewport(s.viewport.x,s.viewport.y,s.viewport.z,s.viewport.w),this.projId.setValue(s.projMat.data),this.projSkyboxId.setValue(s.projMat.data),this.viewId.setValue(s.viewOffMat.data),this.viewInvId.setValue(s.viewInvOffMat.data),this.viewId3.setValue(s.viewMat3.data),this.viewProjId.setValue(s.projViewOffMat.data),this.viewPosId.setValue(s.position),0===e?this.drawInstance(h,u,P,v,!0):this.drawInstance2(h,u,P,v),this._forwardDrawCalls++}}else this.drawInstance(h,u,P,v,!0),this._forwardDrawCalls++;r<g-1&&!t.isNewMaterial[r+1]&&w.setParameters(h,u.parameters)}}}renderForward(e,t,s,i,a,r,o,h,n){const l=this.renderForwardPrepareMaterials(e,t,s,i,r,h,a);this.renderForwardInternal(e,l,i,a,o,n),f.clear()}setSceneConstants(){const e=this.scene;if(this.dispatchGlobalLights(e),e.fog!==h){if(this.fogColor[0]=e.fogColor.r,this.fogColor[1]=e.fogColor.g,this.fogColor[2]=e.fogColor.b,e.gammaCorrection)for(let e=0;e<3;e++)this.fogColor[e]=Math.pow(this.fogColor[e],2.2);this.fogColorId.setValue(this.fogColor),e.fog===n?(this.fogStartId.setValue(e.fogStart),this.fogEndId.setValue(e.fogEnd)):this.fogDensityId.setValue(e.fogDensity)}const t=this.device;this._screenSize[0]=t.width,this._screenSize[1]=t.height,this._screenSize[2]=1/t.width,this._screenSize[3]=1/t.height,this.screenSizeId.setValue(this._screenSize),this.pcssDiskSamplesId.setValue(this.pcssDiskSamples),this.pcssSphereSamplesId.setValue(this.pcssSphereSamples)}updateLightStats(e,t){}buildFrameGraph(e,t){const i=this.scene.clusteredLightingEnabled;if(e.reset(),this.update(t),i){{const i=new s(this.device,(()=>{this.scene.lighting.cookiesEnabled&&(this.renderCookies(t._splitLights[r]),this.renderCookies(t._splitLights[a]))}));i.requiresCubemaps=!1,e.addRenderPass(i)}{const i=new s(this.device);if(i.requiresCubemaps=!1,e.addRenderPass(i),this.scene.lighting.shadowsEnabled){const e=t._splitLights;this._shadowRendererLocal.prepareClusteredRenderPass(i,e[r],e[a])}i.after=()=>{this.updateClusters(t)}}}else{const s=t._splitLights;this._shadowRendererLocal.buildNonClusteredRenderPasses(e,s[r],s[a])}let o=0,h=!0,n=null;const d=t._renderActions;for(let i=o;i<d.length;i++){const a=d[i],r=t.layerList[a.layerIndex],c=r.cameras[a.cameraIndex];if(!a.isLayerEnabled(t))continue;const g=r.id===l&&(c.renderSceneColorMap||c.renderSceneDepthMap);a.hasDirectionalShadowLights&&c&&this._shadowRendererDirectional.buildFrameGraph(e,a,c),h&&(h=!1,o=i,n=a.renderTarget);let m=i+1;for(;d[m]&&!d[m].isLayerEnabled(t);)m++;const p=d[m],u=!!p&&t.layerList[p.layerIndex].id===l&&(c.renderSceneColorMap||c.renderSceneDepthMap);if(!p||p.renderTarget!==n||p.hasDirectionalShadowLights||u||g){if(this.addMainRenderPass(e,t,n,o,i,g),a.triggerPostprocess&&null!=c&&c.onPostprocessing){const i=new s(this.device,(()=>{this.renderPassPostprocessing(a,t)}));i.requiresCubemaps=!1,e.addRenderPass(i)}h=!0}}}addMainRenderPass(e,t,i,a,r,o){const h={start:a,end:r},n=new s(this.device,(()=>{this.renderPassRenderActions(t,h)})),l=t._renderActions,d=l[a],c=l[r],g=t.layerList[d.layerIndex].cameras[d.cameraIndex];g&&(d.firstCameraUse&&g.onPreRender&&(n.before=()=>{g.onPreRender()}),c.lastCameraUse&&g.onPostRender&&(n.after=()=>{g.onPostRender()}));const p=o&&m.requiresRenderPass(this.device,g);(!o||p)&&(n.init(i),n.fullSizeClearRect=g.camera.fullSizeClearRect,p?(n.setClearColor(u),n.setClearDepth(1)):n.fullSizeClearRect&&(d.clearColor&&n.setClearColor(g.camera.clearColor),d.clearDepth&&n.setClearDepth(g.camera.clearDepth),d.clearStencil&&n.setClearStencil(g.camera.clearStencil))),e.addRenderPass(n)}update(e){this.frameUpdate(),this.shadowRenderer.frameUpdate();const t=this.scene.clusteredLightingEnabled;this.scene._updateSky(this.device);const s=this.updateLayerComposition(e,t),i=0!=(s&d);this.updateLightStats(e,s),this.beginFrame(e,i),this.setSceneConstants(),this.cullComposition(e),this.gpuUpdate(e._meshInstances)}renderPassPostprocessing(e,t){t.layerList[e.layerIndex].cameras[e.cameraIndex].onPostprocessing()}renderPassRenderActions(e,t){const s=e._renderActions;for(let i=t.start;i<=t.end;i++)this.renderRenderAction(e,s[i],i===t.start)}renderRenderAction(e,t,s){const i=this.scene.clusteredLightingEnabled,a=this.device,r=t.layerIndex,o=e.layerList[r],h=e.subLayerList[r],n=t.cameraIndex,l=o.cameras[n];if(t.isLayerEnabled(e)){if(!h&&o.onPreRenderOpaque?o.onPreRenderOpaque(n):h&&o.onPreRenderTransparent&&o.onPreRenderTransparent(n),o._preRenderCalledForCameras&1<<n||(o.onPreRender&&o.onPreRender(n),o._preRenderCalledForCameras|=1<<n),l){var d,c,g;this.setupViewport(l.camera,t.renderTarget),s&&l.camera.fullSizeClearRect||this.clear(l.camera,t.clearColor,t.clearDepth,t.clearStencil),o._sortVisible(h,l.camera.node,n);const e=o.instances,r=h?e.visibleTransparent[n]:e.visibleOpaque[n];this.scene.immediate.onPreRenderLayer(o,r,h),i&&t.lightClusters&&(t.lightClusters.activate(),this.clustersDebugRendered||this.scene.lighting.debugLayer!==o.id||(this.clustersDebugRendered=!0)),this.scene._activeCamera=l.camera;const m=this.setCameraUniforms(l.camera,t.renderTarget);a.supportsUniformBuffers&&this.setupViewUniformBuffers(t.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,m);const u=!!(l.camera._flipFaces^(null==t||null==(d=t.renderTarget)?void 0:d.flipY)),f=null!=(c=null==(g=l.camera.shaderPassInfo)?void 0:g.index)?c:o.shaderPass,C=this._forwardDrawCalls;this.renderForward(l.camera,r.list,r.length,o._splitLights,f,o.cullingMask,o.onDrawCall,o,u),o._forwardDrawCalls+=this._forwardDrawCalls-C,a.setBlendState(p.NOBLEND),a.setStencilState(null,null),a.setAlphaToCoverage(!1),a.setDepthBias(!1)}!h&&o.onPostRenderOpaque?o.onPostRenderOpaque(n):h&&o.onPostRenderTransparent&&o.onPostRenderTransparent(n),!o.onPostRender||o._postRenderCalledForCameras&1<<n||(o._postRenderCounter&=~(h?2:1),0===o._postRenderCounter&&(o.onPostRender(n),o._postRenderCalledForCameras|=1<<n,o._postRenderCounter=o._postRenderCounterMax))}}}export{C as ForwardRenderer};
