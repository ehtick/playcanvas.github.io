import"../../core/tracing.js";import{math as e}from"../../core/math/math.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Mat4 as a}from"../../core/math/mat4.js";import{BoundingBox as t}from"../../core/shape/bounding-box.js";import{SHADOWUPDATE_NONE as r,SHADOWUPDATE_THISFRAME as o}from"../constants.js";import{RenderPass as n}from"../../platform/graphics/render-pass.js";import{ShadowMap as d}from"./shadow-map.js";const i=new t,c=new s,l=new a,h=[new s,new s,new s,new s,new s,new s,new s,new s],m={min:0,max:0};function w(e,s,a){h[0].x=h[1].x=h[2].x=h[3].x=s.x,h[1].y=h[3].y=h[7].y=h[5].y=s.y,h[2].z=h[3].z=h[6].z=h[7].z=s.z,h[4].x=h[5].x=h[6].x=h[7].x=a.x,h[0].y=h[2].y=h[4].y=h[6].y=a.y,h[0].z=h[1].z=h[4].z=h[5].z=a.z;let t=9999999999,r=-9999999999;for(let s=0;s<8;++s){e.transformPoint(h[s],h[s]);const a=h[s].z;a<t&&(t=a),a>r&&(r=a)}return m.min=t,m.max=r,m}class p{constructor(e,s){this.renderer=e,this.shadowRenderer=s,this.device=e.device}cull(e,s,a){e.visibleThisFrame=!0,e._shadowMap||(e._shadowMap=d.create(this.device,e));const t=a._nearClip;this.generateSplitDistances(e,t,e.shadowDistance);const o=e.shadowUpdateOverrides;for(let n=0;n<e.numCascades&&(null==o?void 0:o[n])!==r;n++){const r=e.getRenderData(a,n),o=r.shadowCamera;o.renderTarget=e._shadowMap.renderTargets[0],r.shadowViewport.copy(e.cascades[n]),r.shadowScissor.copy(e.cascades[n]);const d=o._node,h=e._node;d.setPosition(h.getPosition()),d.setRotation(h.getRotation()),d.rotateLocal(-90,0,0);const m=0===n?t:e._shadowCascadeDistances[n-1],p=e._shadowCascadeDistances[n],u=a.getFrustumCorners(m,p);c.set(0,0,0);const f=a.node.getWorldTransform();for(let e=0;e<8;e++)f.transformPoint(u[e],u[e]),c.add(u[e]);c.mulScalar(1/8);let g=0;for(let e=0;e<8;e++){const s=u[e].sub(c).length();s>g&&(g=s)}const x=d.right,C=d.up,R=d.forward,v=.25*e._shadowResolution/g,y=Math.ceil(c.dot(C)*v)/v,b=Math.ceil(c.dot(x)*v)/v,z=C.mulScalar(y),_=x.mulScalar(b),S=c.dot(R),D=R.mulScalar(S);c.add2(z,_).add(D),d.setPosition(c),d.translateLocal(0,0,1e6),o.nearClip=.01,o.farClip=2e6,o.orthoHeight=g,this.renderer.updateCameraFrustum(o),this.shadowRenderer.cullShadowCasters(s,r.visibleCasters,o);let P=!0;const j=r.visibleCasters;for(let e=0;e<j.length;e++){const s=j[e];P?(P=!1,i.copy(s.aabb)):i.add(s.aabb)}l.copy(d.getWorldTransform()).invert();const F=w(l,i.getMin(),i.getMax());d.translateLocal(0,0,F.max+.1),o.farClip=F.max-F.min+.2}}generateSplitDistances(s,a,t){s._shadowCascadeDistances.fill(t);for(let r=1;r<s.numCascades;r++){const o=r/s.numCascades,n=a+(t-a)*o,d=a*(t/a)**o,i=e.lerp(n,d,s.cascadeDistribution);s._shadowCascadeDistances[r-1]=i}}addLightRenderPasses(e,s,a){const t=s.numShadowFaces,d=s.shadowUpdateOverrides;let i,c=!0;for(let e=0;e<t;e++)(null==d?void 0:d[e])===r&&(c=!1),i=this.shadowRenderer.prepareFace(s,a,e);const l=new n(this.device,(()=>{for(let e=0;e<t;e++)(null==d?void 0:d[e])!==r&&this.shadowRenderer.renderFace(s,a,e,!c),(null==d?void 0:d[e])===o&&(d[e]=r)}));l.after=()=>{this.shadowRenderer.renderVms(s,a)},this.shadowRenderer.setupRenderPass(l,i,c),e.addRenderPass(l)}buildFrameGraph(e,s,a){const t=s.directionalLights;for(let s=0;s<t.length;s++){const r=t[s];this.shadowRenderer.needsShadowRendering(r)&&this.addLightRenderPasses(e,r,a.camera)}}}export{p as ShadowRendererDirectional};
