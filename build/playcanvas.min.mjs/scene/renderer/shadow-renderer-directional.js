import"../../core/tracing.js";import{math as e}from"../../core/math/math.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Mat4 as a}from"../../core/math/mat4.js";import{BoundingBox as t}from"../../core/shape/bounding-box.js";import{SHADOWUPDATE_NONE as o,SHADOWUPDATE_THISFRAME as r}from"../constants.js";import{RenderPass as n}from"../../platform/graphics/render-pass.js";import{ShadowRenderer as i}from"./shadow-renderer.js";import{ShadowMap as d}from"./shadow-map.js";const c=new t,l=new s,m=new a,h=[new s,new s,new s,new s,new s,new s,new s,new s],p={min:0,max:0};function w(e,s,a){h[0].x=h[1].x=h[2].x=h[3].x=s.x,h[1].y=h[3].y=h[7].y=h[5].y=s.y,h[2].z=h[3].z=h[6].z=h[7].z=s.z,h[4].x=h[5].x=h[6].x=h[7].x=a.x,h[0].y=h[2].y=h[4].y=h[6].y=a.y,h[0].z=h[1].z=h[4].z=h[5].z=a.z;let t=9999999999,o=-9999999999;for(let s=0;s<8;++s){e.transformPoint(h[s],h[s]);const a=h[s].z;a<t&&(t=a),a>o&&(o=a)}return p.min=t,p.max=o,p}class u extends i{cull(e,s,a){e.visibleThisFrame=!0,e._shadowMap||(e._shadowMap=d.create(this.device,e));const t=a._nearClip;this.generateSplitDistances(e,t,e.shadowDistance);const r=e.shadowUpdateOverrides;for(let n=0;n<e.numCascades&&(null==r?void 0:r[n])!==o;n++){const o=e.getRenderData(a,n),r=o.shadowCamera;r.renderTarget=e._shadowMap.renderTargets[0],o.shadowViewport.copy(e.cascades[n]),o.shadowScissor.copy(e.cascades[n]);const i=r._node,d=e._node;i.setPosition(d.getPosition()),i.setRotation(d.getRotation()),i.rotateLocal(-90,0,0);const h=0===n?t:e._shadowCascadeDistances[n-1],p=e._shadowCascadeDistances[n],u=a.getFrustumCorners(h,p);l.set(0,0,0);const f=a.node.getWorldTransform();for(let e=0;e<8;e++)f.transformPoint(u[e],u[e]),l.add(u[e]);l.mulScalar(1/8);let g=0;for(let e=0;e<8;e++){const s=u[e].sub(l).length();s>g&&(g=s)}const x=i.right,C=i.up,y=i.forward,v=.25*e._shadowResolution/g,b=Math.ceil(l.dot(C)*v)/v,z=Math.ceil(l.dot(x)*v)/v,_=C.mulScalar(b),S=x.mulScalar(z),j=l.dot(y),D=y.mulScalar(j);l.add2(_,S).add(D),i.setPosition(l),i.translateLocal(0,0,1e6),r.nearClip=.01,r.farClip=2e6,r.orthoHeight=g,this.renderer.updateCameraFrustum(r),this.cullShadowCasters(s,o.visibleCasters,r);let P=!0;const R=o.visibleCasters;for(let e=0;e<R.length;e++){const s=R[e];P?(P=!1,c.copy(s.aabb)):c.add(s.aabb)}m.copy(i.getWorldTransform()).invert();const F=w(m,c.getMin(),c.getMax());i.translateLocal(0,0,F.max+.1),r.farClip=F.max-F.min+.2}}generateSplitDistances(s,a,t){s._shadowCascadeDistances.fill(t);for(let o=1;o<s.numCascades;o++){const r=o/s.numCascades,n=a+(t-a)*r,i=a*(t/a)**r,d=e.lerp(n,i,s.cascadeDistribution);s._shadowCascadeDistances[o-1]=d}}addLightRenderPasses(e,s,a){const t=s.numShadowFaces,i=s.shadowUpdateOverrides;let d,c=!0;for(let e=0;e<t;e++)(null==i?void 0:i[e])===o&&(c=!1),d=this.prepareFace(s,a,e);const l=new n(this.device,(()=>{for(let e=0;e<t;e++)(null==i?void 0:i[e])!==o&&this.renderFace(s,a,e,!c),(null==i?void 0:i[e])===r&&(i[e]=o)}),(()=>{this.renderVms(s,a)}));this.setupRenderPass(l,d,c),e.addRenderPass(l)}buildFrameGraph(e,s,a){const t=s.directionalLights;for(let s=0;s<t.length;s++){const o=t[s];this.needsShadowRendering(o)&&this.addLightRenderPasses(e,o,a.camera)}}}export{u as ShadowRendererDirectional};
