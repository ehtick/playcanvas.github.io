import{math as t}from"../../core/math/math.js";import{ShadowRenderer as e}from"./shadow-renderer.js";import{ShadowMap as s}from"./shadow-map.js";import{LIGHTTYPE_SPOT as o,LIGHTTYPE_OMNI as a}from"../constants.js";class i extends e{cull(e,i){const r=this.renderer.scene.clusteredLightingEnabled;e.visibleThisFrame=!0,r||e._shadowMap||(e._shadowMap=s.create(this.device,e));const n=e._type,l=n===o?1:6;for(let s=0;s<l;s++){const l=e.getRenderData(null,s),d=l.shadowCamera;d.nearClip=e.attenuationEnd/1e3,d.farClip=e.attenuationEnd;const h=d._node,c=e._node;if(h.setPosition(c.getPosition()),n===o)d.fov=2*e._outerConeAngle,h.setRotation(c.getRotation()),h.rotateLocal(-90,0,0);else if(n===a)if(r){const s=2/(this.lightTextureAtlas.shadowAtlasResolution*e.atlasViewport.z/3)*this.lightTextureAtlas.shadowEdgePixels;d.fov=Math.atan(1+s)*t.RAD_TO_DEG*2}else d.fov=90;this.renderer.updateCameraFrustum(d),this.cullShadowCasters(i,l.visibleCasters,d)}}}export{i as ShadowRendererLocal};
