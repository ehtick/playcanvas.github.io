import{math as e}from"../../core/math/math.js";import{ShadowMap as t}from"./shadow-map.js";import{LIGHTTYPE_SPOT as s,LIGHTTYPE_OMNI as o}from"../constants.js";class a{constructor(e,t){this.renderer=e,this.shadowRenderer=t,this.device=e.device}cull(a,r){const i=this.renderer.scene.clusteredLightingEnabled;a.visibleThisFrame=!0,i||a._shadowMap||(a._shadowMap=t.create(this.device,a));const n=a._type,d=n===s?1:6;for(let t=0;t<d;t++){const d=a.getRenderData(null,t),h=d.shadowCamera;h.nearClip=a.attenuationEnd/1e3,h.farClip=a.attenuationEnd;const l=h._node,c=a._node;if(l.setPosition(c.getPosition()),n===s)h.fov=2*a._outerConeAngle,l.setRotation(c.getRotation()),l.rotateLocal(-90,0,0);else if(n===o)if(i){const t=2/(this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution*a.atlasViewport.z/3)*this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;h.fov=Math.atan(1+t)*e.RAD_TO_DEG*2}else h.fov=90;this.renderer.updateCameraFrustum(h),this.shadowRenderer.cullShadowCasters(r,d.visibleCasters,h)}}}export{a as ShadowRendererLocal};
