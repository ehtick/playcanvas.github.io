import{PRIMITIVE_TRISTRIP as t}from"../../platform/graphics/constants.js";import{BLEND_NORMAL as e}from"../constants.js";import{GraphNode as s}from"../graph-node.js";import{Mesh as r}from"../mesh.js";import{MeshInstance as a}from"../mesh-instance.js";import{BasicMaterial as h}from"../materials/basic-material.js";import{createShaderFromCode as i}from"../shader-lib/utils.js";import{shaderChunks as n}from"../shader-lib/chunks/chunks.js";import{ImmediateBatches as o}from"./immediate-batches.js";const l=[];class d{constructor(t){this.device=t,this.quadMesh=null,this.textureShader=null,this.depthTextureShader=null,this.cubeLocalPos=null,this.cubeWorldPos=null,this.batchesMap=new Map,this.allBatches=new Set,this.updatedLayers=new Set,this._materialDepth=null,this._materialNoDepth=null,this.layerMeshInstances=new Map}createMaterial(t){const s=new h;return s.vertexColors=!0,s.blend=!0,s.blendType=e,s.depthTest=t,s.update(),s}get materialDepth(){return this._materialDepth||(this._materialDepth=this.createMaterial(!0)),this._materialDepth}get materialNoDepth(){return this._materialNoDepth||(this._materialNoDepth=this.createMaterial(!1)),this._materialNoDepth}getBatch(t,e){let s=this.batchesMap.get(t);s||(s=new o(this.device),this.batchesMap.set(t,s)),this.allBatches.add(s);const r=e?this.materialDepth:this.materialNoDepth;return s.getBatch(r,t)}static getTextureVS(){return"\n\t\t\t\t\t\tattribute vec2 vertex_position;\n\t\t\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\t\t\tgl_Position = matrix_model * vec4(vertex_position, 0, 1);\n\t\t\t\t\t\t\t\tuv0 = vertex_position.xy + 0.5;\n\t\t\t\t\t\t}\n\t\t\t\t"}getTextureShader(){if(!this.textureShader){const t="\n\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\tuniform sampler2D colorMap;\n\t\t\t\t\t\t\t\tvoid main (void) {\n\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t";this.textureShader=i(this.device,d.getTextureVS(),t,"DebugTextureShader")}return this.textureShader}getDepthTextureShader(){if(!this.depthTextureShader){const t=`\n\t\t\t\t\t\t\t\t${n.screenDepthPS}\n\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\t\tfloat depth = getLinearScreenDepth(uv0) * camera_params.x;\n\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t`;this.depthTextureShader=i(this.device,d.getTextureVS(),t,"DebugDepthTextureShader")}return this.depthTextureShader}getQuadMesh(){return this.quadMesh||(this.quadMesh=new r(this.device),this.quadMesh.setPositions([-.5,-.5,0,.5,-.5,0,-.5,.5,0,.5,.5,0]),this.quadMesh.update(t)),this.quadMesh}drawMesh(t,e,s,r,h){if(!r){const h=this.getGraphNode(e);r=new a(s,t,h)}let i=this.layerMeshInstances.get(h);i||(i=[],this.layerMeshInstances.set(h,i)),i.push(r)}drawWireAlignedBox(t,e,s,r,a){l.push(t.x,t.y,t.z,t.x,e.y,t.z,t.x,e.y,t.z,e.x,e.y,t.z,e.x,e.y,t.z,e.x,t.y,t.z,e.x,t.y,t.z,t.x,t.y,t.z,t.x,t.y,e.z,t.x,e.y,e.z,t.x,e.y,e.z,e.x,e.y,e.z,e.x,e.y,e.z,e.x,t.y,e.z,e.x,t.y,e.z,t.x,t.y,e.z,t.x,t.y,t.z,t.x,t.y,e.z,t.x,e.y,t.z,t.x,e.y,e.z,e.x,e.y,t.z,e.x,e.y,e.z,e.x,t.y,t.z,e.x,t.y,e.z);this.getBatch(a,r).addLinesArrays(l,s),l.length=0}drawWireSphere(t,e,s,r,a,h){const i=2*Math.PI/r;let n=0;for(let s=0;s<r;s++){const s=Math.sin(n),r=Math.cos(n);n+=i;const a=Math.sin(n),h=Math.cos(n);l.push(t.x+e*s,t.y,t.z+e*r),l.push(t.x+e*a,t.y,t.z+e*h),l.push(t.x+e*s,t.y+e*r,t.z),l.push(t.x+e*a,t.y+e*h,t.z),l.push(t.x,t.y+e*s,t.z+e*r),l.push(t.x,t.y+e*a,t.z+e*h)}this.getBatch(h,a).addLinesArrays(l,s),l.length=0}getGraphNode(t){const e=new s("ImmediateDebug");return e.worldTransform=t,e._dirtyWorld=e._dirtyNormal=!1,e}onPreRenderLayer(t,e,s){if(this.batchesMap.forEach(((r,a)=>{a===t&&r.onPreRender(e,s)})),!this.updatedLayers.has(t)){this.updatedLayers.add(t);const s=this.layerMeshInstances.get(t);if(s){for(let t=0;t<s.length;t++)e.list[e.length+t]=s[t];e.length+=s.length,s.length=0}}}onPostRender(){this.allBatches.clear(),this.updatedLayers.clear()}}export{d as Immediate};
