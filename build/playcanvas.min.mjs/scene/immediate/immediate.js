import{PRIMITIVE_TRISTRIP as e}from"../../graphics/constants.js";import{shaderChunks as t}from"../../graphics/program-lib/chunks/chunks.js";import{createShaderFromCode as r}from"../../graphics/program-lib/utils.js";import{BLEND_NORMAL as s}from"../constants.js";import{BasicMaterial as a}from"../materials/basic-material.js";import{GraphNode as h}from"../graph-node.js";import{Mesh as i}from"../mesh.js";import{MeshInstance as n}from"../mesh-instance.js";import{ImmediateBatches as o}from"./immediate-batches.js";const l=[];class d{constructor(e){this.device=e,this.quadMesh=null,this.textureShader=null,this.depthTextureShader=null,this.cubeLocalPos=null,this.cubeWorldPos=null,this.batchesMap=new Map,this.allBatches=new Set,this.updatedLayers=new Set,this._materialDepth=null,this._materialNoDepth=null,this.layerMeshInstances=new Map}createMaterial(e){const t=new a;return t.vertexColors=!0,t.blend=!0,t.blendType=s,t.depthTest=e,t.update(),t}get materialDepth(){return this._materialDepth||(this._materialDepth=this.createMaterial(!0)),this._materialDepth}get materialNoDepth(){return this._materialNoDepth||(this._materialNoDepth=this.createMaterial(!1)),this._materialNoDepth}getBatch(e,t){let r=this.batchesMap.get(e);r||(r=new o(this.device),this.batchesMap.set(e,r)),this.allBatches.add(r);const s=t?this.materialDepth:this.materialNoDepth;return r.getBatch(s,e)}static getTextureVS(){return"\n            attribute vec2 vertex_position;\n            uniform mat4 matrix_model;\n            varying vec2 uv0;\n            void main(void) {\n                gl_Position = matrix_model * vec4(vertex_position, 0, 1);\n                uv0 = vertex_position.xy + 0.5;\n            }\n        "}getTextureShader(){if(!this.textureShader){const e="\n                varying vec2 uv0;\n                uniform sampler2D colorMap;\n                void main (void) {\n                    gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n                }\n            ";this.textureShader=r(this.device,d.getTextureVS(),e,"DebugTextureShader")}return this.textureShader}getDepthTextureShader(){if(!this.depthTextureShader){const e=`\n                ${t.screenDepthPS}\n                varying vec2 uv0;\n                void main() {\n                    float depth = getLinearScreenDepth(uv0) * camera_params.x;\n                    gl_FragColor = vec4(vec3(depth), 1.0);\n                }\n            `;this.depthTextureShader=r(this.device,d.getTextureVS(),e,"DebugDepthTextureShader")}return this.depthTextureShader}getQuadMesh(){return this.quadMesh||(this.quadMesh=new i(this.device),this.quadMesh.setPositions([-.5,-.5,0,.5,-.5,0,-.5,.5,0,.5,.5,0]),this.quadMesh.update(e)),this.quadMesh}drawMesh(e,t,r,s,a){if(!s){const a=this.getGraphNode(t);s=new n(r,e,a)}let h=this.layerMeshInstances.get(a);h||(h=[],this.layerMeshInstances.set(a,h)),h.push(s)}drawWireAlignedBox(e,t,r,s,a){l.push(e.x,e.y,e.z,e.x,t.y,e.z,e.x,t.y,e.z,t.x,t.y,e.z,t.x,t.y,e.z,t.x,e.y,e.z,t.x,e.y,e.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,t.z,e.x,t.y,t.z,t.x,t.y,t.z,t.x,t.y,t.z,t.x,e.y,t.z,t.x,e.y,t.z,e.x,e.y,t.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,e.z,e.x,t.y,t.z,t.x,t.y,e.z,t.x,t.y,t.z,t.x,e.y,e.z,t.x,e.y,t.z);this.getBatch(a,s).addLinesArrays(l,r),l.length=0}drawWireSphere(e,t,r,s,a,h){const i=2*Math.PI/s;let n=0;for(let r=0;r<s;r++){const r=Math.sin(n),s=Math.cos(n);n+=i;const a=Math.sin(n),h=Math.cos(n);l.push(e.x+t*r,e.y,e.z+t*s),l.push(e.x+t*a,e.y,e.z+t*h),l.push(e.x+t*r,e.y+t*s,e.z),l.push(e.x+t*a,e.y+t*h,e.z),l.push(e.x,e.y+t*r,e.z+t*s),l.push(e.x,e.y+t*a,e.z+t*h)}this.getBatch(h,a).addLinesArrays(l,r),l.length=0}getGraphNode(e){const t=new h("ImmediateDebug");return t.worldTransform=e,t._dirtyWorld=t._dirtyNormal=!1,t}onPreRenderLayer(e,t,r){if(this.batchesMap.forEach(((s,a)=>{a===e&&s.onPreRender(t,r)})),!this.updatedLayers.has(e)){this.updatedLayers.add(e);const r=this.layerMeshInstances.get(e);if(r){for(let e=0;e<r.length;e++)t.list[t.length+e]=r[e];t.length+=r.length,r.length=0}}}onPostRender(){this.allBatches.clear(),this.updatedLayers.clear()}}export{d as Immediate};
