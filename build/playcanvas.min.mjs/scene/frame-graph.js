class e{constructor(){this.renderPasses=[],this.renderTargetMap=new Map}addRenderPass(e){this.renderPasses.push(e)}reset(){this.renderPasses.length=0}compile(){const e=this.renderTargetMap,r=this.renderPasses;for(let s=0;s<r.length;s++){const t=r[s],l=t.renderTarget;if(void 0!==l){const r=e.get(l);if(r){const e=t.colorArrayOps.length;for(let s=0;s<e;s++){t.colorArrayOps[s].clear||(r.colorArrayOps[s].store=!0)}t.depthStencilOps.clearDepth||(r.depthStencilOps.storeDepth=!0),t.depthStencilOps.clearStencil||(r.depthStencilOps.storeStencil=!0)}e.set(l,t)}}let s=null,t=null;for(let e=0;e<r.length;e++){const l=r[e],o=l.renderTarget,n=null==o?void 0:o.colorBuffer;if(null!=n&&n.cubemap){if(s===n){const e=t.colorArrayOps.length;for(let r=0;r<e;r++)t.colorArrayOps[r].mipmaps=!1}s=o.colorBuffer,t=l}else l.requiresCubemaps&&(s=null,t=null)}e.forEach(((e,r)=>{null===r&&(e.colorOps.store=!0,e.colorOps.resolve=!1,e.colorOps.mipmaps=!1)})),e.clear()}render(e){this.compile();const r=this.renderPasses;for(let e=0;e<r.length;e++)r[e].render()}}export{e as FrameGraph};
