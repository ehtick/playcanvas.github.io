import"../core/tracing.js";import{RefCountedObject as t}from"../core/ref-counted-object.js";import{Vec3 as e}from"../core/math/vec3.js";import{FloatPacking as r}from"../core/math/float-packing.js";import{BoundingBox as s}from"../core/shape/bounding-box.js";import{Texture as i}from"../platform/graphics/texture.js";import{VertexBuffer as o}from"../platform/graphics/vertex-buffer.js";import{VertexFormat as h}from"../platform/graphics/vertex-format.js";import{PIXELFORMAT_RGBA16F as a,PIXELFORMAT_RGBA32F as n,PIXELFORMAT_RGB32F as l,BUFFER_STATIC as m,FILTER_NEAREST as u,ADDRESS_CLAMP_TO_EDGE as p,SEMANTIC_ATTR15 as c,TYPE_FLOAT32 as g}from"../platform/graphics/constants.js";import{GraphicsDeviceAccess as x}from"../platform/graphics/graphics-device-access.js";class _ extends t{constructor(t,e){super(),this.device=e||x.get(),t.forEach((t=>{})),this._targets=t.slice(),this.device.supportsMorphTargetTexturesCore&&(this.device.extTextureHalfFloat&&this.device.textureHalfFloatRenderable?this._renderTextureFormat=a:this.device.extTextureFloat&&this.device.textureFloatRenderable&&(this._renderTextureFormat=n),this.device.extTextureHalfFloat&&this.device.textureHalfFloatUpdatable?this._textureFormat=a:this.device.extTextureFloat&&(this._textureFormat=l),void 0!==this._renderTextureFormat&&void 0!==this._textureFormat&&(this._useTextureMorph=!0)),this._init(),this._updateMorphFlags(),this._calculateAabb()}get morphPositions(){return this._morphPositions}get morphNormals(){return this._morphNormals}get maxActiveTargets(){return this._useTextureMorph?this._targets.length:this._morphPositions&&this._morphNormals?4:8}get useTextureMorph(){return this._useTextureMorph}_init(){if(this._useTextureMorph&&(this._useTextureMorph=this._initTextureBased()),!this._useTextureMorph)for(let t=0;t<this._targets.length;t++)this._targets[t]._initVertexBuffers(this.device);for(let t=0;t<this._targets.length;t++)this._targets[t]._postInit()}_initTextureBased(){const t=[],e=[];for(let r=0;r<this._targets.length;r++){const s=this._targets[r];s.options.deltaPositions&&(t.push(s.options.deltaPositions),e.push({target:s,name:"texturePositions"})),s.options.deltaNormals&&(t.push(s.options.deltaNormals),e.push({target:s,name:"textureNormals"}))}const s=[],i=[];let n=1;const l=t[0].length;for(let e=0;e<l;e+=3){let r=!1;for(let s=0;s<t.length;s++){const i=t[s];if(0!==i[e]||0!==i[e+1]||0!==i[e+2]){r=!0;break}}r?(s.push(n+.2),i.push(e/3),n++):s.push(.2)}const u=Math.min(this.device.maxTextureSize,4096);let p=Math.ceil(Math.sqrt(n));p=Math.min(p,u);const x=Math.ceil(n/p);if(x>u)return!1;this.morphTextureWidth=p,this.morphTextureHeight=x;let _=!1,f=3;const d=r.float2Half;this._textureFormat===a&&(_=!0,f=4);for(let r=0;r<t.length;r++){const s=t[r],o=this._createTexture("MorphTarget",this._textureFormat),h=o.lock();for(let t=0;t<i.length;t++){const e=i[t];_?(h[t*f+f]=d(s[3*e]),h[t*f+f+1]=d(s[3*e+1]),h[t*f+f+2]=d(s[3*e+2])):(h[t*f+f]=s[3*e],h[t*f+f+1]=s[3*e+1],h[t*f+f+2]=s[3*e+2])}o.unlock();e[r].target._setTexture(e[r].name,o)}const T=[{semantic:c,components:1,type:g}];return this.vertexBufferIds=new o(this.device,new h(this.device,T),s.length,m,new Float32Array(s)),!0}destroy(){var t;null==(t=this.vertexBufferIds)||t.destroy(),this.vertexBufferIds=null;for(let t=0;t<this._targets.length;t++)this._targets[t].destroy();this._targets.length=0}get targets(){return this._targets}_updateMorphFlags(){this._morphPositions=!1,this._morphNormals=!1;for(let t=0;t<this._targets.length;t++){const e=this._targets[t];e.morphPositions&&(this._morphPositions=!0),e.morphNormals&&(this._morphNormals=!0)}}_calculateAabb(){const t=new e,r=new e;for(let e=0;e<this._targets.length;e++){const s=this._targets[e].aabb;t.min(s.getMin()),r.max(s.getMax())}this.aabb=new s,this.aabb.setMinMax(t,r)}_createTexture(t,e){return new i(this.device,{width:this.morphTextureWidth,height:this.morphTextureHeight,format:e,cubemap:!1,mipmaps:!1,minFilter:u,magFilter:u,addressU:p,addressV:p,name:t})}}export{_ as Morph};
