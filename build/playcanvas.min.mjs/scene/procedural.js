import{Vec2 as t}from"../core/math/vec2.js";import{Vec3 as e}from"../core/math/vec3.js";import"../core/tracing.js";import{SEMANTIC_TANGENT as s,SEMANTIC_BLENDINDICES as n,TYPE_UINT8 as a,SEMANTIC_BLENDWEIGHT as o}from"../platform/graphics/constants.js";import{Mesh as i}from"./mesh.js";const h=4/64,u=.875,c=[];function r(t,s){const n=s.length/3,a=t.length/3,o=new e,i=new e,h=new e,u=new e,c=new e,r=new e,l=[];for(let e=0;e<t.length;e++)l[e]=0;for(let e=0;e<n;e++){const n=s[3*e],a=s[3*e+1],d=s[3*e+2];o.set(t[3*n],t[3*n+1],t[3*n+2]),i.set(t[3*a],t[3*a+1],t[3*a+2]),h.set(t[3*d],t[3*d+1],t[3*d+2]),u.sub2(i,o),c.sub2(h,o),r.cross(u,c).normalize(),l[3*n]+=r.x,l[3*n+1]+=r.y,l[3*n+2]+=r.z,l[3*a]+=r.x,l[3*a+1]+=r.y,l[3*a+2]+=r.z,l[3*d]+=r.x,l[3*d+1]+=r.y,l[3*d+2]+=r.z}for(let t=0;t<a;t++){const e=l[3*t],s=l[3*t+1],n=l[3*t+2],a=1/Math.sqrt(e*e+s*s+n*n);l[3*t]*=a,l[3*t+1]*=a,l[3*t+2]*=a}return l}function l(s,n,a,o){const i=o.length/3,h=s.length/3,u=new e,c=new e,r=new e,l=new t,d=new t,p=new t,g=new e,v=new e,M=new Float32Array(3*h),f=new Float32Array(3*h),m=[];for(let t=0;t<i;t++){const e=o[3*t],n=o[3*t+1],i=o[3*t+2];u.set(s[3*e],s[3*e+1],s[3*e+2]),c.set(s[3*n],s[3*n+1],s[3*n+2]),r.set(s[3*i],s[3*i+1],s[3*i+2]),l.set(a[2*e],a[2*e+1]),d.set(a[2*n],a[2*n+1]),p.set(a[2*i],a[2*i+1]);const h=c.x-u.x,m=r.x-u.x,w=c.y-u.y,x=r.y-u.y,y=c.z-u.z,I=r.z-u.z,z=d.x-l.x,P=p.x-l.x,S=d.y-l.y,b=p.y-l.y,R=z*b-P*S;if(0===R)g.set(0,1,0),v.set(1,0,0);else{const t=1/R;g.set((b*h-S*m)*t,(b*w-S*x)*t,(b*y-S*I)*t),v.set((z*m-P*h)*t,(z*x-P*w)*t,(z*I-P*y)*t)}M[3*e+0]+=g.x,M[3*e+1]+=g.y,M[3*e+2]+=g.z,M[3*n+0]+=g.x,M[3*n+1]+=g.y,M[3*n+2]+=g.z,M[3*i+0]+=g.x,M[3*i+1]+=g.y,M[3*i+2]+=g.z,f[3*e+0]+=v.x,f[3*e+1]+=v.y,f[3*e+2]+=v.z,f[3*n+0]+=v.x,f[3*n+1]+=v.y,f[3*n+2]+=v.z,f[3*i+0]+=v.x,f[3*i+1]+=v.y,f[3*i+2]+=v.z}const w=new e,x=new e,y=new e,I=new e;for(let t=0;t<h;t++){y.set(n[3*t],n[3*t+1],n[3*t+2]),w.set(M[3*t],M[3*t+1],M[3*t+2]),x.set(f[3*t],f[3*t+1],f[3*t+2]);const e=y.dot(w);I.copy(y).mulScalar(e),I.sub2(w,I).normalize(),m[4*t]=I.x,m[4*t+1]=I.y,m[4*t+2]=I.z,I.cross(y,w),m[4*t+3]=I.dot(x)<0?-1:1}return m}function d(t,e,h){const u=new i(t);return u.setPositions(e),h&&(h.normals&&u.setNormals(h.normals),h.tangents&&u.setVertexStream(s,h.tangents,4),h.colors&&u.setColors32(h.colors),h.uvs&&u.setUvs(0,h.uvs),h.uvs1&&u.setUvs(1,h.uvs1),h.blendIndices&&u.setVertexStream(n,h.blendIndices,4,h.blendIndices.length/4,a),h.blendWeights&&u.setVertexStream(o,h.blendWeights,4),h.indices&&u.setIndices(h.indices)),u.update(),u}function p(t,e){const s=e&&void 0!==e.tubeRadius?e.tubeRadius:.2,n=e&&void 0!==e.ringRadius?e.ringRadius:.3,a=e&&void 0!==e.segments?e.segments:30,o=e&&void 0!==e.sides?e.sides:20,i=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,h=[],u=[],c=[],r=[];for(let t=0;t<=o;t++)for(let e=0;e<=a;e++){const i=Math.cos(2*Math.PI*e/a)*(n+s*Math.cos(2*Math.PI*t/o)),l=Math.sin(2*Math.PI*t/o)*s,d=Math.sin(2*Math.PI*e/a)*(n+s*Math.cos(2*Math.PI*t/o)),p=Math.cos(2*Math.PI*e/a)*Math.cos(2*Math.PI*t/o),g=Math.sin(2*Math.PI*t/o),v=Math.sin(2*Math.PI*e/a)*Math.cos(2*Math.PI*t/o),M=t/o,f=1-e/a;if(h.push(i,l,d),u.push(p,g,v),c.push(M,1-f),t<o&&e<a){const s=t*(a+1)+e,n=(t+1)*(a+1)+e,o=t*(a+1)+(e+1),i=(t+1)*(a+1)+(e+1);r.push(s,n,o),r.push(n,i,o)}}const p={normals:u,uvs:c,uvs1:c,indices:r};return i&&(p.tangents=l(h,u,c,r)),d(t,h,p)}function g(t,s,n,a,o,i){const c=new e,r=new e,l=new e,d=new e,p=new e,g=new e,v=[],M=[],f=[],m=[],w=[];let x;if(n>0)for(let e=0;e<=a;e++)for(let i=0;i<=o;i++){const x=i/o*2*Math.PI-Math.PI,y=Math.sin(x),I=Math.cos(x);p.set(y*t,-n/2,I*t),d.set(y*s,n/2,I*s),c.lerp(p,d,e/a),r.sub2(d,p).normalize(),g.set(I,0,-y),l.cross(g,r).normalize(),v.push(c.x,c.y,c.z),M.push(l.x,l.y,l.z);let z=i/o,P=e/a;f.push(z,1-P);const S=P;if(P=z,z=S,z=z*u+h,P=P*u+h,z/=3,m.push(z,1-P),e<a&&i<o){const t=e*(o+1)+i,s=e*(o+1)+(i+1),n=(e+1)*(o+1)+i,a=(e+1)*(o+1)+(i+1);w.push(t,s,n),w.push(s,a,n)}}if(i){const t=Math.floor(o/2),e=o,i=n/2;for(let n=0;n<=t;n++){const a=n*Math.PI*.5/t,o=Math.sin(a),c=Math.cos(a);for(let a=0;a<=e;a++){const r=2*a*Math.PI/e-Math.PI/2,l=Math.sin(r),d=Math.cos(r)*o,p=c,g=l*o;let w=1-a/e,x=1-n/t;v.push(d*s,p*s+i,g*s),M.push(d,p,g),f.push(w,1-x),w=w*u+h,x=x*u+h,w/=3,x/=3,w+=1/3,m.push(w,1-x)}}x=(a+1)*(o+1);for(let s=0;s<t;++s)for(let t=0;t<e;++t){const n=s*(e+1)+t,a=n+e+1;w.push(x+n+1,x+a,x+n),w.push(x+n+1,x+a+1,x+a)}for(let n=0;n<=t;n++){const a=.5*Math.PI+n*Math.PI*.5/t,o=Math.sin(a),c=Math.cos(a);for(let a=0;a<=e;a++){const r=2*a*Math.PI/e-Math.PI/2,l=Math.sin(r),d=Math.cos(r)*o,p=c,g=l*o;let w=1-a/e,x=1-n/t;v.push(d*s,p*s-i,g*s),M.push(d,p,g),f.push(w,1-x),w=w*u+h,x=x*u+h,w/=3,x/=3,w+=2/3,m.push(w,1-x)}}x=(a+1)*(o+1)+(e+1)*(t+1);for(let s=0;s<t;++s)for(let t=0;t<e;++t){const n=s*(e+1)+t,a=n+e+1;w.push(x+n+1,x+a,x+n),w.push(x+n+1,x+a+1,x+a)}}else{if(x=(a+1)*(o+1),t>0)for(let e=0;e<o;e++){const s=e/o*2*Math.PI,a=Math.sin(s),i=-n/2,c=Math.cos(s);let r=1-(a+1)/2,l=(c+1)/2;v.push(a*t,i,c*t),M.push(0,-1,0),f.push(r,1-l),r=r*u+h,l=l*u+h,r/=3,l/=3,r+=1/3,m.push(r,1-l),e>1&&w.push(x,x+e,x+e-1)}if(x+=o,s>0)for(let t=0;t<o;t++){const e=t/o*2*Math.PI,a=Math.sin(e),i=n/2,c=Math.cos(e);let r=1-(a+1)/2,l=(c+1)/2;v.push(a*s,i,c*s),M.push(0,1,0),f.push(r,1-l),r=r*u+h,l=l*u+h,r/=3,l/=3,r+=2/3,m.push(r,1-l),t>1&&w.push(x,x+t-1,x+t)}}return{positions:v,normals:M,uvs:f,uvs1:m,indices:w}}function v(t,e){let s=e&&(e.radius||e.baseRadius);s=void 0!==s?s:.5;const n=e&&void 0!==e.height?e.height:1,a=e&&void 0!==e.heightSegments?e.heightSegments:5,o=e&&void 0!==e.capSegments?e.capSegments:20,i=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,h=g(s,s,n,a,o,!1);return i&&(h.tangents=l(h.positions,h.normals,h.uvs,h.indices)),d(t,h.positions,h)}function M(t,e){const s=e&&void 0!==e.radius?e.radius:.3,n=e&&void 0!==e.height?e.height:1,a=e&&void 0!==e.heightSegments?e.heightSegments:1,o=e&&void 0!==e.sides?e.sides:20,i=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,h=g(s,s,n-2*s,a,o,!0);return i&&(h.tangents=l(h.positions,h.normals,h.uvs,h.indices)),d(t,h.positions,h)}function f(t,e){const s=e&&void 0!==e.baseRadius?e.baseRadius:.5,n=e&&void 0!==e.peakRadius?e.peakRadius:0,a=e&&void 0!==e.height?e.height:1,o=e&&void 0!==e.heightSegments?e.heightSegments:5,i=e&&void 0!==e.capSegments?e.capSegments:18,h=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,u=g(s,n,a,o,i,!1);return h&&(u.tangents=l(u.positions,u.normals,u.uvs,u.indices)),d(t,u.positions,u)}function m(t,e){const s=e&&void 0!==e.radius?e.radius:.5,n=e&&void 0!==e.latitudeBands?e.latitudeBands:16,a=e&&void 0!==e.longitudeBands?e.longitudeBands:16,o=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,i=[],h=[],u=[],c=[];for(let t=0;t<=n;t++){const e=t*Math.PI/n,o=Math.sin(e),c=Math.cos(e);for(let e=0;e<=a;e++){const r=2*e*Math.PI/a-Math.PI/2,l=Math.sin(r),d=Math.cos(r)*o,p=c,g=l*o,v=1-e/a,M=1-t/n;i.push(d*s,p*s,g*s),h.push(d,p,g),u.push(v,1-M)}}for(let t=0;t<n;++t)for(let e=0;e<a;++e){const s=t*(a+1)+e,n=s+a+1;c.push(s+1,n,s),c.push(s+1,n+1,n)}const r={normals:h,uvs:u,uvs1:u,indices:c};return o&&(r.tangents=l(i,h,u,c)),d(t,i,r)}function w(e,s){const n=s&&void 0!==s.halfExtents?s.halfExtents:new t(.5,.5),a=s&&void 0!==s.widthSegments?s.widthSegments:5,o=s&&void 0!==s.lengthSegments?s.lengthSegments:5,i=!(!s||void 0===s.calculateTangents)&&s.calculateTangents,h=[],u=[],c=[],r=[];let p=0;for(let t=0;t<=a;t++)for(let e=0;e<=o;e++){const s=-n.x+2*n.x*t/a,i=0,l=-(-n.y+2*n.y*e/o),d=t/a,g=e/o;h.push(s,i,l),u.push(0,1,0),c.push(d,1-g),t<a&&e<o&&(r.push(p+o+1,p+1,p),r.push(p+o+1,p+o+2,p+1)),p++}const g={normals:u,uvs:c,uvs1:c,indices:r};return i&&(g.tangents=l(h,u,c,r)),d(e,h,g)}function x(t,s){const n=s&&void 0!==s.halfExtents?s.halfExtents:new e(.5,.5,.5),a=s&&void 0!==s.widthSegments?s.widthSegments:1,o=s&&void 0!==s.lengthSegments?s.lengthSegments:1,i=s&&void 0!==s.heightSegments?s.heightSegments:1,c=!(!s||void 0===s.calculateTangents)&&s.calculateTangents,r=[new e(-n.x,-n.y,n.z),new e(n.x,-n.y,n.z),new e(n.x,n.y,n.z),new e(-n.x,n.y,n.z),new e(n.x,-n.y,-n.z),new e(-n.x,-n.y,-n.z),new e(-n.x,n.y,-n.z),new e(n.x,n.y,-n.z)],p=[[0,1,3],[4,5,7],[3,2,6],[1,0,4],[1,4,2],[5,0,6]],g=[[0,0,1],[0,0,-1],[0,1,0],[0,-1,0],[1,0,0],[-1,0,0]],v=1,M=2,f=3,m=4,w=5,x=[],y=[],I=[],z=[],P=[];let S=0;const b=(t,s,n)=>{const a=new e,o=new e,i=new e,c=new e;for(let e=0;e<=s;e++)for(let l=0;l<=n;l++){a.lerp(r[p[t][0]],r[p[t][1]],e/s),o.lerp(r[p[t][0]],r[p[t][2]],l/n),i.sub2(o,r[p[t][0]]),c.add2(a,i);let d=e/s,v=l/n;x.push(c.x,c.y,c.z),y.push(g[t][0],g[t][1],g[t][2]),I.push(d,1-v),d=d*u+h,v=v*u+h,d/=3,v/=3,d+=t%3/3,v+=Math.floor(t/3)/3,z.push(d,1-v),e<s&&l<n&&(P.push(S+n+1,S+1,S),P.push(S+n+1,S+n+2,S+1)),S++}};b(0,a,i),b(v,a,i),b(M,a,o),b(f,a,o),b(m,o,i),b(w,o,i);const R={normals:y,uvs:I,uvs1:z,indices:P};return c&&(R.tangents=l(x,y,I,P)),d(t,x,R)}function y(s,n){let a=null;for(let t=0;t<c.length;t++)c[t].type===n&&c[t].device===s&&(a=c[t].primData);if(!a){let o,i;switch(n){case"box":o=x(s,{halfExtents:new e(.5,.5,.5)}),i={x:2,y:2,z:2,uv:2/3};break;case"capsule":o=M(s,{radius:.5,height:2}),i={x:2*Math.PI,y:Math.PI,z:2*Math.PI,uv:1/3+1/3/3*2};break;case"cone":o=f(s,{baseRadius:.5,peakRadius:0,height:1}),i={x:2.54,y:2.54,z:2.54,uv:1/3+1/3/3};break;case"cylinder":o=v(s,{radius:.5,height:1}),i={x:Math.PI,y:1.58,z:Math.PI,uv:1/3+1/3/3*2};break;case"plane":o=w(s,{halfExtents:new t(.5,.5),widthSegments:1,lengthSegments:1}),i={x:0,y:1,z:0,uv:1};break;case"sphere":o=m(s,{radius:.5}),i={x:Math.PI,y:Math.PI,z:Math.PI,uv:1};break;case"torus":o=p(s,{tubeRadius:.2,ringRadius:.3}),i={x:.5*Math.PI*.5-.1*Math.PI*.1,y:.4,z:.4,uv:1};break;default:throw new Error("Invalid primitive type: "+n)}o.incRefCount(),a={mesh:o,area:i},c.push({type:n,device:s,primData:a})}return a}export{r as calculateNormals,l as calculateTangents,x as createBox,M as createCapsule,f as createCone,v as createCylinder,d as createMesh,w as createPlane,m as createSphere,p as createTorus,y as getShapePrimitive};
