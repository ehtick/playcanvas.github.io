import{hashCode as e}from"../../../core/hash.js";import"../../../core/tracing.js";import{LIGHTTYPE_DIRECTIONAL as n,SPRITE_RENDERMODE_SLICED as t,SPRITE_RENDERMODE_TILED as a,SPECULAR_PHONG as s,FRESNEL_SCHLICK as p,BLEND_NONE as i}from"../../constants.js";import{ShaderPass as o}from"../../shader-pass.js";import{LitShader as d}from"./lit-shader.js";import{ChunkBuilder as r}from"../chunk-builder.js";import{ChunkUtils as l}from"../chunk-utils.js";import{StandardMaterialOptions as c}from"../../materials/standard-material-options.js";const h=[],u={optionsContext:new c,optionsContextMin:new c,generateKey:function(t){const a=function(e){const n=[];for(const t in e)e.hasOwnProperty(t)&&"chunks"!==t&&"lights"!==t&&n.push(t);return n.sort()};let s;t===this.optionsContextMin?(this.propsMin||(this.propsMin=a(t)),s=this.propsMin):t===this.optionsContext?(this.props||(this.props=a(t)),s=this.props):s=a(t);let p="standard";for(let e=0;e<s.length;e++)t[s[e]]&&(p+=s[e]+t[s[e]]);if(t.chunks){const e=[];for(const n in t.chunks)t.chunks.hasOwnProperty(n)&&e.push(n+t.chunks[n]);e.sort(),p+=e}if(t.litOptions){for(const e in t.litOptions)p+=e+t.litOptions[e];if(t.litOptions.lights){const e=t.litOptions.clusteredLightingEnabled;for(let a=0;a<t.litOptions.lights.length;a++){const s=t.litOptions.lights[a];e&&s._type!==n||(p+=s.key)}}}return e(p)},_getUvSourceExpression:function(e,n,s){const p=s[e],i=s[n],d=o.isForward(s.pass);let r;return d&&s.litOptions.nineSlicedMode===t||d&&s.litOptions.nineSlicedMode===a?r="nineSlicedUv":(r=0===p?"vUv"+i:"vUV"+i+"_"+p,s.heightMap&&"heightMapTransform"!==e&&(r+=" + dUvOffset")),r},_addMapDef:function(e,n){return n?`#define ${e}\n`:`#undef ${e}\n`},_addMapDefs:function(e,n,t,a){return this._addMapDef("MAPFLOAT",e)+this._addMapDef("MAPCOLOR",n)+this._addMapDef("MAPVERTEX",t)+this._addMapDef("MAPTEXTURE",a)},_addMap:function(e,n,t,a,s,p=null){const i=e+"Map",o=i+"Uv",d=i+"Identifier",r=i+"Transform",c=i+"Channel",h=e+"VertexColorChannel",u=e+"VertexColor",f=e+"Mode",g=t[e+"Tint"],M=t[u],m=t[i],S=t[d],O=t[f];let k=a[n];if(m){const e=this._getUvSourceExpression(r,o,t);if(k=k.replace(/\$UV/g,e).replace(/\$CH/g,t[c]),s&&-1!==k.search(/\$SAMPLER/g)){let e="texture_"+i;const n=s[S];n?e=n:s[S]=e,k=k.replace(/\$SAMPLER/g,e)}if(p&&(k="aaa"===t[c]?k.replace(/\$DECODE/g,"passThrough"):k.replace(/\$DECODE/g,l.decodeFunc(t.litOptions.gamma||"srgb"!==p?p:"linear")),k.indexOf("$texture2DSAMPLE"))){const e={linear:"texture2D",srgb:"texture2DSRGB",rgbm:"texture2DRGBM",rgbe:"texture2DRGBE"};k=k.replace(/\$texture2DSAMPLE/g,e[p]||"texture2D")}}M&&(k=k.replace(/\$VC/g,t[h])),O&&(k=k.replace(/\$DETAILMODE/g,O));const C=!!(1&g),_=!!(2&g);return k=this._addMapDefs(C,_,M,m)+k,k.replace(/\$/g,"")},_correctChannel:function(e,n,t){if(t[e]>0){if(t[e]<n.length)return n.substring(0,t[e]);if(t[e]>n.length){let a=n;const s=a.charAt(a.length-1),p=t[e]-a.length;for(let e=0;e<p;e++)a+=s;return a}return n}},createShaderDefinition:function(e,n){const t=new d(e,n.litOptions),l=[],c=[],u=[],f={};for(const e in h){const t=e+"Map";if(n[e+"VertexColor"]){const t=e+"VertexColorChannel";n[t]=this._correctChannel(e,n[t],h)}if(n[t]){const a=t+"Channel",s=t+"Transform",p=t+"Uv";n[p]=Math.min(n[p],1),n[a]=this._correctChannel(e,n[a],h);const i=n[p];l[i]=!0,c[i]=c[i]||n[t]&&!n[s],n[s]&&u.push({name:e,id:n[s],uv:n[p]})}}n.forceUv1&&(l[1]=!0,c[1]=void 0===c[1]||c[1]),t.generateVertexShader(l,c,u),n.litOptions.shadingModel===s?(n.litOptions.fresnelModel=0,n.litOptions.ambientSH=!1):n.litOptions.fresnelModel=0===n.litOptions.fresnelModel?p:n.litOptions.fresnelModel;const g=new r,M=new r,m=new r;let S="";if(n.litOptions.nineSlicedMode===a?g.append("const float textureBias = -1000.0;"):g.append("uniform float textureBias;"),o.isForward(n.pass)){if(n.heightMap&&(g.append("vec2 dUvOffset;"),M.append(this._addMap("height","parallaxPS",n,t.chunks,f)),m.append("getParallax();")),n.litOptions.blendType!==i||n.litOptions.alphaTest||n.litOptions.alphaToCoverage?(g.append("float dAlpha;"),M.append(this._addMap("opacity","opacityPS",n,t.chunks,f)),m.append("getOpacity();"),n.litOptions.alphaTest&&(M.append(t.chunks.alphaTestPS),m.append("alphaTest(dAlpha);"))):g.append("float dAlpha = 1.0;"),t.needsNormal){if((n.normalMap||n.clearCoatNormalMap)&&(M.append(n.packedNormal?t.chunks.normalXYPS:t.chunks.normalXYZPS),!n.litOptions.hasTangents)){const e=n.normalMap?"normalMap":"clearCoatNormalMap";S=this._getUvSourceExpression(`${e}Transform`,`${e}Uv`,n)}g.append("vec3 dNormalW;"),M.append(this._addMap("normalDetail","normalDetailMapPS",n,t.chunks,f)),M.append(this._addMap("normal","normalMapPS",n,t.chunks,f)),m.append("getNormal();")}if(t.needsSceneColor&&g.append("uniform sampler2D uSceneColorMap;"),t.needsScreenSize&&g.append("uniform vec4 uScreenSize;"),t.needsTransforms&&(g.append("uniform mat4 matrix_viewProjection;"),g.append("uniform mat4 matrix_model;")),g.append("vec3 dAlbedo;"),n.diffuseDetail&&M.append(this._addMap("diffuseDetail","diffuseDetailMapPS",n,t.chunks,f,n.diffuseDetailEncoding)),M.append(this._addMap("diffuse","diffusePS",n,t.chunks,f,n.diffuseEncoding)),m.append("getAlbedo();"),n.litOptions.useRefraction&&(g.append("float dTransmission;"),M.append(this._addMap("refraction","transmissionPS",n,t.chunks,f)),m.append("getRefraction();"),g.append("float dThickness;"),M.append(this._addMap("thickness","thicknessPS",n,t.chunks,f)),m.append("getThickness();")),n.litOptions.useIridescence&&(g.append("vec3 dIridescenceFresnel;"),g.append("float dIridescence;"),M.append(this._addMap("iridescence","iridescencePS",n,t.chunks,f)),m.append("getIridescence();"),g.append("float dIridescenceThickness;"),M.append(this._addMap("iridescenceThickness","iridescenceThicknessPS",n,t.chunks,f)),m.append("getIridescenceThickness();")),t.lighting&&n.litOptions.useSpecular||t.reflections?(g.append("vec3 dSpecularity;"),g.append("float dGlossiness;"),n.litOptions.useSheen&&(g.append("vec3 sSpecularity;"),M.append(this._addMap("sheen","sheenPS",n,t.chunks,f,n.sheenEncoding)),m.append("getSheen();"),g.append("float sGlossiness;"),M.append(this._addMap("sheenGlossiness","sheenGlossPS",n,t.chunks,f)),m.append("getSheenGlossiness();")),n.litOptions.useMetalness&&(g.append("float dMetalness;"),M.append(this._addMap("metalness","metalnessPS",n,t.chunks,f)),m.append("getMetalness();")),n.litOptions.useSpecularityFactor&&(g.append("float dSpecularityFactor;"),M.append(this._addMap("specularityFactor","specularityFactorPS",n,t.chunks,f)),m.append("getSpecularityFactor();")),n.litOptions.useSpecularColor?M.append(this._addMap("specular","specularPS",n,t.chunks,f,n.specularEncoding)):M.append("void getSpecularity() { dSpecularity = vec3(1); }"),M.append(this._addMap("gloss","glossPS",n,t.chunks,f)),m.append("getGlossiness();"),m.append("getSpecularity();")):(g.append("vec3 dSpecularity = vec3(0.0);"),g.append("float dGlossiness = 0.0;")),(n.aoMap||n.aoVertexColor)&&(g.append("float dAo;"),M.append(this._addMap("ao","aoPS",n,t.chunks,f)),m.append("getAO();")),g.append("vec3 dEmission;"),M.append(this._addMap("emissive","emissivePS",n,t.chunks,f,n.emissiveEncoding)),m.append("getEmission();"),n.litOptions.useClearCoat&&(g.append("float ccSpecularity;"),g.append("float ccGlossiness;"),g.append("vec3 ccNormalW;"),M.append(this._addMap("clearCoat","clearCoatPS",n,t.chunks,f)),M.append(this._addMap("clearCoatGloss","clearCoatGlossPS",n,t.chunks,f)),M.append(this._addMap("clearCoatNormal","clearCoatNormalPS",n,t.chunks,f)),m.append("getClearCoat();"),m.append("getClearCoatGlossiness();"),m.append("getClearCoatNormal();")),n.litOptions.lightMapEnabled||n.lightMapVertexColors){const e=n.litOptions.dirLightMapEnabled&&n.litOptions.useSpecular,a=e?"lightmapDirPS":"lightmapSinglePS";g.append("vec3 dLightmap;"),e&&g.append("vec3 dLightmapDir;"),M.append(this._addMap("light",a,n,t.chunks,f,n.lightMapEncoding)),m.append("getLightMap();")}-1===M.code.indexOf("texture2DSRGB")&&-1===M.code.indexOf("texture2DRGBM")&&-1===M.code.indexOf("texture2DRGBE")||M.prepend(t.chunks.textureSamplePS)}else n.litOptions.alphaTest&&(g.append("float dAlpha;"),M.append(this._addMap("opacity","opacityPS",n,t.chunks,f)),M.append(t.chunks.alphaTestPS),m.append("getOpacity();"),m.append("alphaTest(dAlpha);"));for(const e in f)g.append(`uniform sampler2D ${f[e]};`);return m.code=`\n${m.code.split("\n").map((e=>`    ${e}`)).join("\n")}\n\n`,t.generateFragmentShader(g.code,M.code,m.code,S),t.getDefinition()}};export{h as _matTex2D,u as standard};
