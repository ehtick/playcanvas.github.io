import{SEMANTIC_POSITION as e,DEVICETYPE_WEBGPU as t,SEMANTIC_ATTR12 as i,SEMANTIC_ATTR13 as n,SEMANTIC_ATTR14 as a,SEMANTIC_ATTR15 as s,SEMANTIC_NORMAL as o,SEMANTIC_TANGENT as r,SEMANTIC_COLOR as l,SEMANTIC_ATTR8 as c,SEMANTIC_ATTR9 as d,SEMANTIC_ATTR10 as h,SEMANTIC_ATTR11 as u,SEMANTIC_BLENDWEIGHT as g,SEMANTIC_BLENDINDICES as f,PIXELFORMAT_RGBA8 as p,SHADERTAG_MATERIAL as S,SEMANTIC_TEXCOORD0 as m,SEMANTIC_TEXCOORD1 as _}from"../../../platform/graphics/constants.js";import{shaderChunks as v}from"../chunks/chunks.js";import{ChunkUtils as P}from"../chunk-utils.js";import{SPRITE_RENDERMODE_SLICED as b,SPRITE_RENDERMODE_TILED as C,LIGHTTYPE_SPOT as L,LIGHTSHAPE_SPHERE as w,LIGHTSHAPE_DISK as M,LIGHTSHAPE_RECT as D,SHADER_DEPTH as E,SHADOW_VSM32 as A,SHADOW_PCF3 as T,LIGHTTYPE_OMNI as N,SHADOW_VSM8 as y,LIGHTTYPE_DIRECTIONAL as x,SHADOW_PCF5 as F,LIGHTSHAPE_PUNCTUAL as W,FRESNEL_SCHLICK as R,SPECOCC_GLOSSDEPENDENT as O,SPECOCC_AO as V,SHADOW_VSM16 as k,SPECULAR_PHONG as I,shadowTypeToString as G,LIGHTFALLOFF_LINEAR as $,BLEND_NORMAL as B,BLEND_PREMULTIPLIED as H,BLEND_ADDITIVEALPHA as U,SHADER_PICK as j}from"../../constants.js";import{LightsBuffer as X}from"../../lighting/lights-buffer.js";import{ShaderPass as z}from"../../shader-pass.js";import{skinCode as q,begin as Q,end as Y,gammaCode as Z,tonemapCode as K,fogCode as J}from"./common.js";import"../../../core/tracing.js";import{ShaderUtils as ee}from"../../../platform/graphics/shader-utils.js";const te={vertex_normal:o,vertex_tangent:r,vertex_texCoord0:m,vertex_texCoord1:_,vertex_color:l,vertex_boneWeights:g,vertex_boneIndices:f},ie={vVertexColor:"vec4",vPositionW:"vec3",vNormalV:"vec3",vNormalW:"vec3",vTangentW:"vec3",vBinormalW:"vec3",vObjectSpaceUpW:"vec3",vUv0:"vec2",vUv1:"vec2"};class ne{constructor(t,i){if(this.device=t,this.options=i,this.attributes={vertex_position:e},i.chunks){this.chunks={};const e=i.chunks;for(const t in v)if(e.hasOwnProperty(t)){const i=e[t];for(const e in te)te.hasOwnProperty(e)&&i.indexOf(e)>=0&&(this.attributes[e]=te[e]);this.chunks[t]=i}else this.chunks[t]=v[t]}else this.chunks=v;this.lighting=i.lights.length>0||i.dirLightMapEnabled||i.clusteredLightingEnabled,this.reflections=!!i.reflectionSource,this.shadowPass=z.isShadow(i.pass),this.needsNormal=this.lighting||this.reflections||i.useSpecular||i.ambientSH||i.heightMapEnabled||i.enableGGXSpecular||i.clusteredLightingEnabled&&!this.shadowPass||i.clearCoatNormalMapEnabled,this.needsNormal=this.needsNormal&&!this.shadowPass,this.needsSceneColor=i.useDynamicRefraction,this.needsScreenSize=i.useDynamicRefraction,this.needsTransforms=i.useDynamicRefraction,this.varyings="",this.vshader=null,this.frontendDecl=null,this.frontendCode=null,this.frontendFunc=null,this.lightingUv=null,this.defines=[],this.fshader=null}_vsAddBaseCode(e,t,i){return e+=t.baseVS,i.nineSlicedMode!==b&&i.nineSlicedMode!==C||(e+=t.baseNineSlicedVS),e}_vsAddTransformCode(e,t,i,n){return e+=this.chunks.transformVS}_setMapTransform(e,t,i,n){const a=i+100*n;if(!e[3][a]){const s=`texture_${t}MapTransform`;e[0]+=`uniform vec3 ${s}0;\n`,e[0]+=`uniform vec3 ${s}1;\n`,e[1]+=`varying vec2 vUV${n}_${i};\n`,e[2]+=`   vUV${n}_${i} = vec2(dot(vec3(uv${n}, 1), ${s}0), dot(vec3(uv${n}, 1), ${s}1));\n`,e[3][a]=!0}return e}_fsGetBaseCode(){const e=this.options,t=this.chunks;let i=this.chunks.basePS;return e.nineSlicedMode===b?i+=t.baseNineSlicedPS:e.nineSlicedMode===C&&(i+=t.baseNineSlicedTiledPS),i}_fsGetStartCode(e,t,i,n){let a=i.startPS;return n.nineSlicedMode===b?a+=i.startNineSlicedPS:n.nineSlicedMode===C&&(a+=i.startNineSlicedTiledPS),a}_directionalShadowMapProjection(e,t,i,n,a){let s="";return e.numCascades>1&&(s+=`getShadowCascadeMatrix(light${n}_shadowMatrixPalette, light${n}_shadowCascadeDistances, light${n}_shadowCascadeCount);\n`,t=`(cascadeShadowMat, ${i});\n`),s+=a+t,s+=`fadeShadow(light${n}_shadowCascadeDistances);\n`,s}_nonPointShadowMapProjection(e,i,n,a,s){const o=`(${n}, ${a});\n`;return!i._normalOffsetBias||i._isVsm?i._type===L?i._isPcf&&(e.webgl2||e.extStandardDerivatives||e.deviceType===t)?"       getShadowCoordPerspZbuffer"+o:"       getShadowCoordPersp"+o:this._directionalShadowMapProjection(i,o,a,s,"getShadowCoordOrtho"):i._type===L?i._isPcf&&(e.webgl2||e.extStandardDerivatives||e.deviceType===t)?"       getShadowCoordPerspZbufferNormalOffset"+o:"       getShadowCoordPerspNormalOffset"+o:this._directionalShadowMapProjection(i,o,a,s,"getShadowCoordOrthoNormalOffset")}_getLightSourceShapeString(e){switch(e){case D:return"Rect";case M:return"Disk";case w:return"Sphere";default:return""}}generateVertexShader(e,t,p){const S=this.device,m=this.options,_=this.chunks;let v="",P="";v=this._vsAddBaseCode(v,_,m),P+="   vPositionW    = getWorldPosition();\n",this.options.pass===E&&(v+="varying float vDepth;\n",v+="#ifndef VIEWMATRIX\n",v+="#define VIEWMATRIX\n",v+="uniform mat4 matrix_view;\n",v+="#endif\n",v+="#ifndef CAMERAPLANES\n",v+="#define CAMERAPLANES\n",v+="uniform vec4 camera_params;\n\n",v+="#endif\n",P+="    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n"),this.options.useInstancing&&(this.attributes.instance_line1=i,this.attributes.instance_line2=n,this.attributes.instance_line3=a,this.attributes.instance_line4=s,v+=_.instancingVS),this.needsNormal&&(this.attributes.vertex_normal=o,P+="   vNormalW = getNormal();\n","sphereMap"===m.reflectionSource&&S.fragmentUniformsCount<=16&&(v+=_.viewNormalVS,P+="   vNormalV    = getViewNormal();\n"),m.hasTangents&&(m.heightMapEnabled||m.normalMapEnabled||m.enableGGXSpecular)?(this.attributes.vertex_tangent=r,v+=_.tangentBinormalVS,P+="   vTangentW   = getTangent();\n",P+="   vBinormalW  = getBinormal();\n"):!m.enableGGXSpecular&&S.extStandardDerivatives||(v+=_.tangentBinormalVS,P+="   vObjectSpaceUpW  = getObjectSpaceUp();\n"));for(let i=0;i<2;i++)e[i]&&(this.attributes["vertex_texCoord"+i]="TEXCOORD"+i,v+=_["uv"+i+"VS"],P+="   vec2 uv"+i+" = getUv"+i+"();\n"),t[i]&&(P+="   vUv"+i+" = uv"+i+";\n");const b=[v,this.varyings,P,[]];p.forEach((e=>{this._setMapTransform(b,e.name,e.id,e.uv)})),v=b[0],this.varyings=b[1],P=b[2],m.vertexColors&&(this.attributes.vertex_color=l,P+="   vVertexColor = vertex_color;\n"),m.useMsdf&&m.msdfTextAttribute&&(this.attributes.vertex_outlineParameters=c,this.attributes.vertex_shadowParameters=d,P+="    unpackMsdfParams();\n",v+=_.msdfVS),(m.useMorphPosition||m.useMorphNormal)&&(m.useMorphTextureBased?(v+="#define MORPHING_TEXTURE_BASED\n",m.useMorphPosition&&(v+="#define MORPHING_TEXTURE_BASED_POSITION\n"),m.useMorphNormal&&(v+="#define MORPHING_TEXTURE_BASED_NORMAL\n"),this.attributes.morph_vertex_id=s,v+="attribute float morph_vertex_id;\n"):(v+="#define MORPHING\n",m.useMorphPosition?(this.attributes.morph_pos0=c,this.attributes.morph_pos1=d,this.attributes.morph_pos2=h,this.attributes.morph_pos3=u,v+="#define MORPHING_POS03\n",v+="attribute vec3 morph_pos0;\n",v+="attribute vec3 morph_pos1;\n",v+="attribute vec3 morph_pos2;\n",v+="attribute vec3 morph_pos3;\n"):m.useMorphNormal&&(this.attributes.morph_nrm0=c,this.attributes.morph_nrm1=d,this.attributes.morph_nrm2=h,this.attributes.morph_nrm3=u,v+="#define MORPHING_NRM03\n",v+="attribute vec3 morph_nrm0;\n",v+="attribute vec3 morph_nrm1;\n",v+="attribute vec3 morph_nrm2;\n",v+="attribute vec3 morph_nrm3;\n"),m.useMorphNormal?(this.attributes.morph_nrm4=i,this.attributes.morph_nrm5=n,this.attributes.morph_nrm6=a,this.attributes.morph_nrm7=s,v+="#define MORPHING_NRM47\n",v+="attribute vec3 morph_nrm4;\n",v+="attribute vec3 morph_nrm5;\n",v+="attribute vec3 morph_nrm6;\n",v+="attribute vec3 morph_nrm7;\n"):(this.attributes.morph_pos4=i,this.attributes.morph_pos5=n,this.attributes.morph_pos6=a,this.attributes.morph_pos7=s,v+="#define MORPHING_POS47\n",v+="attribute vec3 morph_pos4;\n",v+="attribute vec3 morph_pos5;\n",v+="attribute vec3 morph_pos6;\n",v+="attribute vec3 morph_pos7;\n"))),m.skin?(this.attributes.vertex_boneWeights=g,this.attributes.vertex_boneIndices=f,v+=q(S,_),v+="#define SKIN\n"):m.useInstancing&&(v+="#define INSTANCING\n"),m.screenSpace&&(v+="#define SCREENSPACE\n"),m.pixelSnap&&(v+="#define PIXELSNAP\n"),v=this._vsAddTransformCode(v,S,_,m),this.needsNormal&&(v+=_.normalVS),v+="\n",v+=_.startVS,v+=P,v+=_.endVS,v+="}",Object.keys(ie).forEach((e=>{v.indexOf(e)>=0&&(this.varyings+=`varying ${ie[e]} ${e};\n`)}));const C=z.getPassShaderDefine(this.options.pass);this.vshader=C+this.varyings+v}_fsGetBeginCode(){let e=z.getPassShaderDefine(this.options.pass);for(let t=0;t<this.defines.length;t++)e+=`#define ${this.defines[t]}\n`;return e}_fsGetPickPassCode(){let e=this._fsGetBeginCode();return e+="uniform vec4 uColor;\n",e+=this.varyings,e+=this.frontendDecl,e+=this.frontendCode,e+=Q(),e+=this.frontendFunc,e+="    gl_FragColor = uColor;\n",e+=Y(),e}_fsGetDepthPassCode(){const e=this.chunks;let t=this._fsGetBeginCode();return t+="varying float vDepth;\n",t+=this.varyings,t+=e.packDepthPS,t+=this.frontendDecl,t+=this.frontendCode,t+=Q(),t+=this.frontendFunc,t+="    gl_FragColor = packFloat(vDepth);\n",t+=Y(),t}_fsGetShadowPassCode(){const e=this.device,i=this.options,n=this.chunks,a=this.varyings,s=z.toLightType(i.pass),o=z.toShadowType(i.pass);let r=this._fsGetBeginCode();e.extStandardDerivatives&&!e.webgl2&&e.deviceType!==t&&(r+="uniform vec2 polygonOffset;\n"),o===A?e.textureFloatHighPrecision?r+="#define VSM_EXPONENT 15.0\n\n":r+="#define VSM_EXPONENT 5.54\n\n":o===k&&(r+="#define VSM_EXPONENT 5.54\n\n"),s!==x&&(r+="uniform vec3 view_position;\n",r+="uniform float light_radius;\n"),r+=a,r+=this.frontendDecl,r+=this.frontendCode,o!==T||e.webgl2&&e.deviceType===t&&s!==N?o===y&&(r+="vec2 encodeFloatRG( float v ) {\n",r+="    vec2 enc = vec2(1.0, 255.0) * v;\n",r+="    enc = fract(enc);\n",r+="    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n",r+="    return enc;\n",r+="}\n\n"):r+=n.packDepthPS,r+=Q(),r+=this.frontendFunc;const l=o===y||o===k||o===A,c=!e.webgl2&&e.extStandardDerivatives&&e.deviceType!==t;return r+=s===N||l&&s!==x?"    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n":"    float depth = gl_FragCoord.z;\n",c&&(r+="    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n",r+="    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n"),o!==T||e.webgl2&&(s!==N||i.clusteredLightingEnabled)?o===T||o===F?(r+="    gl_FragColor = vec4(1.0);\n",i.clusteredLightingEnabled&&s===N&&e.webgl2&&(r+="    gl_FragDepth = depth;\n")):r+=o===y?"    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n":n.storeEVSMPS:r+="    gl_FragColor = packFloat(depth);\n",r+=Y(),r}_fsGetLitPassCode(){const e=this.device,i=this.options,n=this.chunks;let a="";!1===i.opacityFadesSpecular&&(a+="uniform float material_alphaFade;\n"),i.useSpecular&&(this.defines.push("LIT_SPECULAR"),this.reflections&&this.defines.push("LIT_REFLECTIONS"),i.useClearCoat&&this.defines.push("LIT_CLEARCOAT"),i.fresnelModel>0&&this.defines.push("LIT_SPECULAR_FRESNEL"),i.conserveEnergy&&this.defines.push("LIT_CONSERVE_ENERGY"),i.useSheen&&this.defines.push("LIT_SHEEN"),i.useIridescence&&this.defines.push("LIT_IRIDESCENCE"));const s=[];let o=0,r=!1,l=!1,c=!1,d=i.lights.some((function(e){return e._shape&&e._shape!==W}));i.clusteredLightingEnabled&&i.clusteredLightingAreaLightsEnabled&&(d=!0);let h="highp";e.areaLightLutFormat===p&&(a+="#define AREA_R8_G8_B8_A8_LUTS\n",h="lowp"),(d||i.clusteredLightingEnabled)&&(a+="#define AREA_LIGHTS\n",a+=`uniform ${h} sampler2D areaLightsLutTex1;\n`,a+=`uniform ${h} sampler2D areaLightsLutTex2;\n`);for(let t=0;t<i.lights.length;t++){const n=i.lights[t],h=n._type;if(i.clusteredLightingEnabled&&h!==x)continue;const u=d&&n._shape?n._shape:W;a+="uniform vec3 light"+t+"_color;\n",h===x?a+="uniform vec3 light"+t+"_direction;\n":(a+="uniform vec3 light"+t+"_position;\n",a+="uniform float light"+t+"_radius;\n",h===L&&(a+="uniform vec3 light"+t+"_direction;\n",a+="uniform float light"+t+"_innerConeAngle;\n",a+="uniform float light"+t+"_outerConeAngle;\n")),u!==W&&(h===x&&(a+="uniform vec3 light"+t+"_position;\n"),a+="uniform vec3 light"+t+"_halfWidth;\n",a+="uniform vec3 light"+t+"_halfHeight;\n"),n.castShadows&&!i.noShadow&&(a+="uniform mat4 light"+t+"_shadowMatrix;\n",a+="uniform float light"+t+"_shadowIntensity;\n",h===x&&(a+="uniform mat4 light"+t+"_shadowMatrixPalette[4];\n",a+="uniform float light"+t+"_shadowCascadeDistances[4];\n",a+="uniform float light"+t+"_shadowCascadeCount;\n"),h!==x?a+="uniform vec4 light"+t+"_shadowParams;\n":(r=!0,a+="uniform vec3 light"+t+"_shadowParams;\n"),h===N?a+="uniform samplerCube light"+t+"_shadowMap;\n":n._isPcf&&e.supportsDepthShadow?a+="uniform sampler2DShadow light"+t+"_shadowMap;\n":a+="uniform sampler2D light"+t+"_shadowMap;\n",o++,s[n._shadowType]=!0,n._isVsm&&(l=!0),n._isPcf&&(e.supportsDepthShadow||e.extStandardDerivatives)&&h===L&&(c=!0)),n._cookie&&(n._cookie._cubemap?h===N&&(a+="uniform samplerCube light"+t+"_cookie;\n",a+="uniform float light"+t+"_cookieIntensity;\n",n.castShadows&&!i.noShadow||(a+="uniform mat4 light"+t+"_shadowMatrix;\n")):h===L&&(a+="uniform sampler2D light"+t+"_cookie;\n",a+="uniform float light"+t+"_cookieIntensity;\n",n.castShadows&&!i.noShadow||(a+="uniform mat4 light"+t+"_shadowMatrix;\n"),n._cookieTransform&&(a+="uniform vec4 light"+t+"_cookieMatrix;\n",a+="uniform vec2 light"+t+"_cookieOffset;\n")))}a+="\n";const u=this.needsNormal&&(i.normalMapEnabled||i.clearCoatNormalMapEnabled||i.enableGGXSpecular&&!i.heightMapEnabled);u&&(i.hasTangents?a+=i.fastTbn?n.TBNfastPS:n.TBNPS:e.extStandardDerivatives&&(i.normalMapEnabled||i.clearCoatNormalMapEnabled)?a+=n.TBNderivativePS.replace(/\$UV/g,this.lightingUv):a+=n.TBNObjectSpacePS),a+=n.sphericalPS,a+=n.decodePS,a+=Z(i.gamma,n),a+=K(i.toneMap,n),a+=J(i.fog,n),a+=this.frontendCode,i.useCubeMapRotation&&(a+="#define CUBEMAP_ROTATION\n"),this.needsNormal&&(a+=n.cubeMapRotatePS,a+=i.cubeMapProjection>0?n.cubeMapProjectBoxPS:n.cubeMapProjectNonePS,a+=i.skyboxIntensity?n.envMultiplyPS:n.envConstPS),(this.lighting&&i.useSpecular||this.reflections)&&(i.useMetalness&&(a+=n.metalnessModulatePS),i.fresnelModel===R&&(a+=n.fresnelSchlickPS),i.useIridescence&&(a+=n.iridescenceDiffractionPS));const g=i.aoMapEnabled||i.useAoVertexColors;if(g)switch(a+=n.aoDiffuseOccPS,i.occludeSpecular){case V:a+=i.occludeSpecularFloat?n.aoSpecOccSimplePS:n.aoSpecOccConstSimplePS;break;case O:a+=i.occludeSpecularFloat?n.aoSpecOccPS:n.aoSpecOccConstPS}if("envAtlasHQ"===i.reflectionSource)a+=i.fixSeams?n.fixCubemapSeamsStretchPS:n.fixCubemapSeamsNonePS,a+=n.envAtlasPS,a+=n.reflectionEnvHQPS.replace(/\$DECODE/g,P.decodeFunc(i.reflectionEncoding));else if("envAtlas"===i.reflectionSource)a+=n.envAtlasPS,a+=n.reflectionEnvPS.replace(/\$DECODE/g,P.decodeFunc(i.reflectionEncoding));else if("cubeMap"===i.reflectionSource)a+=i.fixSeams?n.fixCubemapSeamsStretchPS:n.fixCubemapSeamsNonePS,a+=n.reflectionCubePS.replace(/\$DECODE/g,P.decodeFunc(i.reflectionEncoding));else if("sphereMap"===i.reflectionSource){a+=(e.fragmentUniformsCount>16?n.reflectionSpherePS:n.reflectionSphereLowPS).replace(/\$DECODE/g,P.decodeFunc(i.reflectionEncoding))}this.reflections&&(i.useClearCoat&&(a+=n.reflectionCCPS),i.useSheen&&(a+=n.reflectionSheenPS)),i.useRefraction&&(i.useDynamicRefraction?a+=n.refractionDynamicPS:this.reflections&&(a+=n.refractionCubePS)),i.useSheen&&(a+=n.lightSheenPS),i.clusteredLightingEnabled&&(a+=n.clusteredLightUtilsPS,i.clusteredLightingCookiesEnabled&&(a+=n.clusteredLightCookiesPS),i.clusteredLightingShadowsEnabled&&!i.noShadow&&(s[T]=!0,s[F]=!0),c=!0),(o>0||i.clusteredLightingEnabled)&&(r&&(a+=n.shadowCascadesPS),s[T]&&(a+=n.shadowStandardPS),s[F]&&(e.webgl2||e.deviceType===t)&&(a+=n.shadowStandardGL2PS),l&&(a+=n.shadowVSM_commonPS,s[y]&&(a+=n.shadowVSM8PS),s[k]&&(a+=e.extTextureHalfFloatLinear?n.shadowEVSMPS.replace(/\$/g,"16"):n.shadowEVSMnPS.replace(/\$/g,"16")),s[A]&&(a+=e.extTextureFloatLinear?n.shadowEVSMPS.replace(/\$/g,"32"):n.shadowEVSMnPS.replace(/\$/g,"32"))),e.webgl2||e.extStandardDerivatives||e.deviceType===t||(a+=n.biasConstPS),a+=n.shadowCoordPS+n.shadowCommonPS,c&&(a+=n.shadowCoordPerspZbufferPS)),i.enableGGXSpecular&&(a+="uniform float material_anisotropy;\n"),this.lighting&&(a+=n.lightDiffuseLambertPS,(d||i.clusteredLightingAreaLightsEnabled)&&(a+=n.ltcPS)),a+="\n";let f=!1;i.useSpecular&&(this.lighting&&(a+=i.shadingModel===I?n.lightSpecularPhongPS:i.enableGGXSpecular?n.lightSpecularAnisoGGXPS:n.lightSpecularBlinnPS),i.fresnelModel||this.reflections||i.diffuseMapEnabled||(a+="    uniform vec3 material_ambient;\n",a+="#define LIT_OLD_AMBIENT",f=!0)),a+=n.combinePS,(i.lightMapEnabled||i.useLightMapVertexColors)&&(a+=i.useSpecular&&i.dirLightMapEnabled?n.lightmapDirAddPS:n.lightmapAddPS);const S=!i.lightMapEnabled&&!i.useLightMapVertexColors||i.lightMapWithoutAmbient;S&&("ambientSH"===i.ambientSource?a+=n.ambientSHPS:"envAtlas"===i.ambientSource?("envAtlas"!==i.reflectionSource&&"envAtlasHQ"!==i.reflectionSource&&(a+=n.envAtlasPS),a+=n.ambientEnvPS.replace(/\$DECODE/g,P.decodeFunc(i.ambientEncoding))):a+=n.ambientConstantPS),i.useAmbientTint&&!f&&(a+="uniform vec3 material_ambient;\n"),i.useMsdf&&(i.msdfTextAttribute||(a+="\n#define UNIFORM_TEXT_PARAMETERS"),a+=n.msdfPS),this.needsNormal&&(a+=n.viewDirPS,i.useSpecular&&(a+=i.enableGGXSpecular?n.reflDirAnisoPS:n.reflDirPS));let m,_=!1,v=!1,b=!1,C=!1,w=!1;if(i.clusteredLightingEnabled&&this.lighting&&(C=!0,_=!0,v=!0,w=!0,a+=n.floatUnpackingPS,i.lightMaskDynamic&&(a+="\n#define CLUSTER_MESH_DYNAMIC_LIGHTS"),i.clusteredLightingCookiesEnabled&&(a+="\n#define CLUSTER_COOKIES"),i.clusteredLightingShadowsEnabled&&!i.noShadow&&(a+="\n#define CLUSTER_SHADOWS",a+="\n#define CLUSTER_SHADOW_TYPE_"+G[i.clusteredLightingShadowType]),i.clusteredLightingAreaLightsEnabled&&(a+="\n#define CLUSTER_AREALIGHTS"),a+=X.shaderDefines,i.clusteredLightingShadowsEnabled&&!i.noShadow&&(a+=n.clusteredLightShadowsPS),a+=n.clusteredLightPS),i.twoSidedLighting&&(a+="uniform float twoSidedLightingNegScaleFactor;\n"),a+=this._fsGetStartCode(a,e,n,i),this.needsNormal&&(i.twoSidedLighting?a+="    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n":a+="    dVertexNormalW = normalize(vNormalW);\n",(i.heightMapEnabled||i.normalMapEnabled)&&i.hasTangents&&(i.twoSidedLighting?(a+="    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n",a+="    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n"):(a+="    dTangentW = vTangentW;\n",a+="    dBinormalW = vBinormalW;\n")),a+="    getViewDir();\n",u&&(a+="    getTBN();\n")),a+=this.frontendFunc,this.needsNormal&&(i.useSpecular&&(a+="    getReflDir();\n"),i.useClearCoat&&(a+="    ccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n")),(this.lighting&&i.useSpecular||this.reflections)&&(i.useMetalness&&(a+="    getMetalnessModulate();\n"),i.useIridescence&&(a+="    getIridescence(saturate(dot(dViewDirW, dNormalW)));\n")),S&&(a+="    addAmbient();\n",i.conserveEnergy&&i.useSpecular&&(a+="   dDiffuseLight = dDiffuseLight * (1.0 - dSpecularity);"),i.separateAmbient&&(a+="\n\t\t\t\t\t\t\t\t\t\tvec3 dAmbientLight = dDiffuseLight;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = vec3(0);\n\t\t\t\t\t\t\t\t")),i.useAmbientTint&&!f&&(a+="    dDiffuseLight *= material_ambient;\n"),g&&!i.occludeDirect&&(a+="    occludeDiffuse();\n"),(i.lightMapEnabled||i.useLightMapVertexColors)&&(a+="    addLightMap();\n"),this.lighting||this.reflections){this.reflections&&(i.useClearCoat&&(a+="    addReflectionCC();\n",i.fresnelModel>0?(a+="    ccFresnel = getFresnelCC(dot(dViewDirW, ccNormalW));\n",a+="    ccReflection.rgb *= ccFresnel;\n"):a+="    ccFresnel = 0.0;\n"),i.useSpecularityFactor&&(a+="    ccReflection.rgb *= dSpecularityFactor;\n"),i.useSheen&&(a+="    addReflectionSheen();\n"),a+="    addReflection();\n",i.fresnelModel>0?a+="    dReflection.rgb *= getFresnel(dot(dViewDirW, dNormalW), dSpecularity);\n":a+="    dReflection.rgb *= dSpecularity;\n",i.useSpecularityFactor&&(a+="    dReflection.rgb *= dSpecularityFactor;\n")),d&&(a+="    dSpecularLight *= dSpecularity;\n",i.useSpecular&&(a+="    calcLTCLightValues();\n"));for(let t=0;t<i.lights.length;t++){const n=i.lights[t],s=n._type;if(i.clusteredLightingEnabled&&s!==x)continue;m=!1;const o=d&&n._shape?n.shape:W,r=d&&n._shape?this._getLightSourceShapeString(o):"";if(o!==W&&(a+="    calc"+r+"LightValues(light"+t+"_position, light"+t+"_halfWidth, light"+t+"_halfHeight);\n"),s===x?(a+="    dLightDirNormW = light"+t+"_direction;\n",a+="    dAtten = 1.0;\n"):(n._cookie&&(s!==L||n._cookie._cubemap?s===N&&n._cookie._cubemap&&(w=!0,m=!0):(w=!0,m=!0)),a+="    getLightDirPoint(light"+t+"_position);\n",_=!0,m&&(a+=s===L?"    dAtten3 = getCookie2D"+(n._cookieFalloff?"":"Clip")+(n._cookieTransform?"Xform":"")+"(light"+t+"_cookie, light"+t+"_shadowMatrix, light"+t+"_cookieIntensity"+(n._cookieTransform?", light"+t+"_cookieMatrix, light"+t+"_cookieOffset":"")+")."+n._cookieChannel+";\n":"    dAtten3 = getCookieCube(light"+t+"_cookie, light"+t+"_shadowMatrix, light"+t+"_cookieIntensity)."+n._cookieChannel+";\n"),o===W?n._falloffMode===$?(a+="    dAtten = getFalloffLinear(light"+t+"_radius);\n",v=!0):(a+="    dAtten = getFalloffInvSquared(light"+t+"_radius);\n",b=!0):(a+="    dAtten = getFalloffWindow(light"+t+"_radius);\n",b=!0),a+="    if (dAtten > 0.00001) {\n",s===L&&(m&&!n._cookieFalloff||(a+="    dAtten *= getSpotEffect(light"+t+"_direction, light"+t+"_innerConeAngle, light"+t+"_outerConeAngle);\n",C=!0))),a+=o!==W?s===x?"    dAttenD = getLightDiffuse();\n":"    dAttenD = get"+r+"LightDiffuse() * 16.0;\n":"    dAtten *= getLightDiffuse();\n",n.castShadows&&!i.noShadow){let o,r=null;if(n._shadowType===y?(r="VSM8",o="0.0"):n._shadowType===k?(r="VSM16",o="5.54"):n._shadowType===A?(r="VSM32",o=e.textureFloatHighPrecision?"15.0":"5.54"):r=n._shadowType===F?"PCF5x5":"PCF3x3",null!==r)if(s===N){const e="(light"+t+"_shadowMap, light"+t+"_shadowParams);\n";n._normalOffsetBias&&(a+="    normalOffsetPointShadow(light"+t+"_shadowParams);\n"),a+=`    float shadow${t} = getShadowPoint${r}${e}`,a+=`    dAtten *= mix(1.0, shadow${t}, light${t}_shadowIntensity);\n`}else{const l=`light${t}_shadowMatrix`,c=`light${t}_shadowParams`;a+=this._nonPointShadowMapProjection(e,i.lights[t],l,c,t),s===L&&(r="Spot"+r),a+=`    float shadow${t} = getShadow${r}(SHADOWMAP_PASS(light${t}_shadowMap), light${t}_shadowParams${n._isVsm?", "+o:""});\n`,a+=`    dAtten *= mix(1.0, shadow${t}, light${t}_shadowIntensity);\n`}}if(o!==W?i.conserveEnergy&&i.useSpecular?a+="    dDiffuseLight += ((dAttenD * dAtten) * light"+t+"_color"+(m?" * dAtten3":"")+") * (1.0 - dLTCSpecFres);\n":a+="    dDiffuseLight += (dAttenD * dAtten) * light"+t+"_color"+(m?" * dAtten3":"")+";\n":d&&i.conserveEnergy&&i.useSpecular?a+="    dDiffuseLight += (dAtten * light"+t+"_color"+(m?" * dAtten3":"")+") * (1.0 - dSpecularity);\n":a+="    dDiffuseLight += dAtten * light"+t+"_color"+(m?" * dAtten3":"")+";\n",i.useSpecular&&(a+="    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);\n"),o!==W)i.useClearCoat&&(a+="    ccSpecularLight += ccLTCSpecFres * get"+r+"LightSpecularCC() * dAtten * light"+t+"_color"+(m?" * dAtten3":"")+";\n"),i.useSpecular&&(a+="    dSpecularLight += dLTCSpecFres * get"+r+"LightSpecular() * dAtten * light"+t+"_color"+(m?" * dAtten3":"")+";\n");else{var M=!1;s===x&&i.fresnelModel>0&&(M=!0),i.useClearCoat&&(a+="    ccSpecularLight += getLightSpecularCC(dHalfDirW) * dAtten * light"+t+"_color",a+=m?" * dAtten3":"",a+=M?" * getFresnelCC(dot(dViewDirW, dHalfDirW))":"",a+=";\n"),i.useSheen&&(a+="    sSpecularLight += getLightSpecularSheen(dHalfDirW) * dAtten * light"+t+"_color",a+=m?" * dAtten3":"",a+=";\n"),i.useSpecular&&(a+="    dSpecularLight += getLightSpecular(dHalfDirW) * dAtten * light"+t+"_color",a+=m?" * dAtten3":"",a+=M?" * getFresnel(dot(dViewDirW, dHalfDirW), dSpecularity)":"* dSpecularity",a+=";\n")}s!==x&&(a+="    }\n"),a+="\n"}i.clusteredLightingEnabled&&this.lighting&&(v=!0,b=!0,_=!0,a+="    addClusteredLights();\n"),d&&(i.useClearCoat&&(a+="    ccSpecularity = 1.0;\n"),i.useSpecular&&(a+="    dSpecularity = vec3(1);\n")),i.useRefraction&&(a+="    addRefraction();\n")}a+="\n",g&&(i.occludeDirect&&(a+="    occludeDiffuse();\n"),i.occludeSpecular!==V&&i.occludeSpecular!==O||(a+="    occludeSpecular();\n")),i.useSpecularityFactor&&(a+="    dSpecularLight *= dSpecularityFactor;\n"),!1===i.opacityFadesSpecular&&(i.blendType!==B&&i.blendType!==H||(a+="float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));\n",a+="#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n",a+="dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n"),a+="dAlpha *= material_alphaFade;\n"),a+=n.endPS,i.blendType===B||i.blendType===U||i.alphaToCoverage?a+=n.outputAlphaPS:i.blendType===H?a+=n.outputAlphaPremulPS:a+=n.outputAlphaOpaquePS,i.useMsdf&&(a+="    gl_FragColor = applyMsdf(gl_FragColor);\n"),a+="\n",a+=Y(),_&&(a=n.lightDirPointPS+a),v&&(a=n.falloffLinearPS+a),b&&(a=n.falloffInvSquaredPS+a),C&&(a=n.spotPS+a),w&&!i.clusteredLightingEnabled&&(a=n.cookiePS+a);let D="";a.includes("dReflection")&&(D+="vec4 dReflection;\n"),a.includes("dTBN")&&(D+="mat3 dTBN;\n"),a.includes("dVertexNormalW")&&(D+="vec3 dVertexNormalW;\n"),a.includes("dTangentW")&&(D+="vec3 dTangentW;\n"),a.includes("dBinormalW")&&(D+="vec3 dBinormalW;\n"),a.includes("dViewDirW")&&(D+="vec3 dViewDirW;\n"),a.includes("dReflDirW")&&(D+="vec3 dReflDirW;\n"),a.includes("dHalfDirW")&&(D+="vec3 dHalfDirW;\n"),a.includes("dDiffuseLight")&&(D+="vec3 dDiffuseLight;\n"),a.includes("dSpecularLight")&&(D+="vec3 dSpecularLight;\n"),a.includes("dLightDirNormW")&&(D+="vec3 dLightDirNormW;\n"),a.includes("dLightDirW")&&(D+="vec3 dLightDirW;\n"),a.includes("dLightPosW")&&(D+="vec3 dLightPosW;\n"),a.includes("dShadowCoord")&&(D+="vec3 dShadowCoord;\n"),a.includes("dAtten")&&(D+="float dAtten;\n"),a.includes("dAttenD")&&(D+="float dAttenD;\n"),a.includes("dAtten3")&&(D+="vec3 dAtten3;\n"),a.includes("dMsdf")&&(D+="vec4 dMsdf;\n"),a.includes("ccFresnel")&&(D+="float ccFresnel;\n"),a.includes("ccReflection")&&(D+="vec3 ccReflection;\n"),a.includes("ccReflDirW")&&(D+="vec3 ccReflDirW;\n"),a.includes("ccSpecularLight")&&(D+="vec3 ccSpecularLight;\n"),a.includes("ccSpecularityNoFres")&&(D+="float ccSpecularityNoFres;\n"),a.includes("sSpecularLight")&&(D+="vec3 sSpecularLight;\n"),a.includes("sReflection")&&(D+="vec3 sReflection;\n");return this._fsGetBeginCode()+this.varyings+this._fsGetBaseCode()+(i.detailModes?n.detailModesPS:"")+D+this.frontendDecl+a}generateFragmentShader(e,t,i,n){const a=this.options;this.frontendDecl=e,this.frontendCode=t,this.frontendFunc=i,this.lightingUv=n,a.pass===j?this.fshader=this._fsGetPickPassCode():a.pass===E?this.fshader=this._fsGetDepthPassCode():this.shadowPass?this.fshader=this._fsGetShadowPassCode():a.customFragmentShader?this.fshader=this._fsGetBeginCode()+a.customFragmentShader:this.fshader=this._fsGetLitPassCode()}getDefinition(){const e=ee.createDefinition(this.device,{name:"LitShader",attributes:this.attributes,vertexCode:this.vshader,fragmentCode:this.fshader});return z.isForward(this.options.pass)&&(e.tag=S),e}}export{ne as LitShader};
