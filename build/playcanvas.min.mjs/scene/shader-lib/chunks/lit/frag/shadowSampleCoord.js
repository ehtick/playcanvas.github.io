var t="\n\nvec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\n\t\tvec3 surfacePosition = worldPosition;\n\n#ifdef SHADOW_SAMPLE_POINT\n\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\t\tfloat distScale = length(lightDir);\n\t\t\t\tsurfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\t\t\tlightDir = surfacePosition - lightPos;\n\t\t\t\treturn lightDir;\n\t\t#endif\n#else\n\t\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\t\t\t\tsurfacePosition = worldPosition + normal * shadowParams.y;\n\t\t\t\t#endif\n\t\t#else\n\t\t\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\t\t\t\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\t\t\t\t\t\t\tfloat distScale = 1.0;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tfloat distScale = abs(dot(vPositionW - lightPos, lightDirNorm));\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tsurfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\t\t\t#endif\n\t\t#endif\n\n\t\tvec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);\n\t\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\t\t\tpositionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n\t\t#else\n\t\t\t\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t\t\t\t\tpositionInShadowSpace.xyz /= positionInShadowSpace.w;\n\t\t\t\t#else\n\t\t\t\t\t\tpositionInShadowSpace.xy /= positionInShadowSpace.w;\n\t\t\t\t\t\tpositionInShadowSpace.z = length(lightDir) * shadowParams.w;\n\t\t\t\t#endif\n\t\t#endif\n\n\t\t#ifdef SHADOW_SAMPLE_Z_BIAS\n\t\t\t\tpositionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t\t#endif\n\t\tsurfacePosition = positionInShadowSpace.xyz;\n#endif\n\n\t\treturn surfacePosition;\n}\n";export{t as default};
