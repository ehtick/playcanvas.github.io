var t="\n\n/**\n * PCSS is a shadow sampling method that provides contact hardening soft shadows. \n * Based on: \n * - https://www.gamedev.net/tutorials/programming/graphics/effect-area-light-shadows-part-1-pcss-r4971/\n * - https://github.com/pboechat/PCSS \n */\n\n\n#define PCSS_SAMPLE_COUNT 16\nuniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];\nuniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];\n\nvec2 vogelDisk(int sampleIndex, float count, float phi, float r) {\n\t\tconst float GoldenAngle = 2.4;\n\t\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\n\t\tfloat sine = sin(theta);\n\t\tfloat cosine = cos(theta);\n\t\treturn vec2(r * cosine, r * sine);\n}\n\nvec3 vogelSphere(int sampleIndex, float count, float phi, float r) {\n\t\tconst float GoldenAngle = 2.4;\n\t\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\n\t\tfloat weight = float(sampleIndex) / count;\n\t\treturn vec3(cos(theta) * r, weight, sin(theta) * r);\n}\n\nfloat gradientNoise(vec2 screenPos) {\n\t\tvec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\treturn fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\t\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\t\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n\nfloat viewSpaceDepth(float depth, mat4 invProjection) {\n\t\tfloat z = depth * 2.0 - 1.0;\n\t\tvec4 clipSpace = vec4(0.0, 0.0, z, 1.0);\n\t\tvec4 viewSpace = invProjection * clipSpace;\n\t\treturn viewSpace.z;\n}\n\n\nfloat PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {\n\n\t\tfloat blockers = 0.0;\n\t\tfloat averageBlocker = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\t\t\tvec2 offset = sampleCoords[i] * searchSize;\n\t\t\t\tvec2 sampleUV = shadowCoords + offset;\n\n\t\t#ifdef GL2\n\t\t\t\tfloat blocker = textureLod(shadowMap, sampleUV, 0.0).r;\n\t\t#else // GL1\n\t\t\t\tfloat blocker = unpackFloat(texture2D(shadowMap, sampleUV));\n\t\t#endif        \n\t\t\t\tfloat isBlocking = step(blocker, z);\n\t\t\t\tblockers += isBlocking;\n\t\t\t\taverageBlocker += blocker * isBlocking;\n\t\t}\n\n\t\tif (blockers > 0.0)\n\t\t\t\treturn averageBlocker /= blockers;\n\t\treturn -1.0;\n}\n\nfloat PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n\t\tfloat receiverDepth = linearizeDepth(shadowCoords.z, cameraParams);\n#ifndef GL2\n\t\t// If using packed depth on GL1, we need to normalize to get the correct receiver depth\n\t\treceiverDepth *= 1.0 / (cameraParams.y - cameraParams.z);\n#endif\n\n\t\tvec2 samplePoints[PCSS_SAMPLE_COUNT];\n\t\tfloat noise = gradientNoise( gl_FragCoord.xy ) * 2.0 * PI;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\t\t\tfloat pcssPresample = pcssDiskSamples[i];\n\t\t\t\tsamplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n\t\t}\n\n\t\t// Calculate the ratio of FOV between 45.0 degrees (tan(45) == 1) and the FOV of the camera    \n\t\tfloat averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);\n\t\tif (averageBlocker == -1.0) {\n\t\t\t\treturn 1.0;\n\t\t} else {\n\n\t\t\t\tvec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n\t\t\t\t{\n\t\t\t\t\t\tvec2 sampleUV = samplePoints[i] * filterRadius;\n\t\t\t\t\t\tsampleUV = shadowCoords.xy + sampleUV;\n\n\t\t\t\t#ifdef GL2\n\t\t\t\t\t\tfloat depth = textureLod(shadowMap, sampleUV, 0.0).r;\n\t\t\t\t#else // GL1\n\t\t\t\t\t\tfloat depth = unpackFloat(texture2D(shadowMap, sampleUV));\n\t\t\t\t#endif\n\t\t\t\t\t\tshadow += step(receiverDepth, depth);\n\t\t\t\t}\n\t\t\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t\t} \n}\n\nfloat PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {\n\t\tfloat blockers = 0.0;\n\t\tfloat averageBlocker = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\t\t\tvec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;\n\t\t\t\tsampleDir = normalize(sampleDir);\n\n\t\t#ifdef GL2\n\t\t\t\tfloat blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n\t\t#else // GL1\n\t\t\t\tfloat blocker = unpackFloat(textureCube(shadowMap, sampleDir));\n\t\t#endif\n\t\t\t\tfloat isBlocking = step(blocker, z);\n\t\t\t\tblockers += isBlocking;\n\t\t\t\taverageBlocker += blocker * isBlocking;\n\t\t}\n\n\t\tif (blockers > 0.0)\n\t\t\t\treturn averageBlocker /= float(blockers);\n\t\treturn -1.0;\n}\n\nfloat PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {\n\t\t\n\t\tvec3 samplePoints[PCSS_SAMPLE_COUNT];\n\t\tfloat noise = gradientNoise( gl_FragCoord.xy ) * 2.0 * PI;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\t\t\tfloat r = pcssSphereSamples[i];\n\t\t\t\tsamplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);\n\t\t}\n\n\t\tfloat receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 lightDirNorm = normalize(lightDir);\n\t\t\n\t\tfloat averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);\n\t\tif (averageBlocker == -1.0) {\n\t\t\t\treturn 1.0;\n\t\t} else {\n\n\t\t\t\tfloat filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n\n\t\t\t\tfloat shadow = 0.0;\n\t\t\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++)\n\t\t\t\t{\n\t\t\t\t\t\tvec3 offset = samplePoints[i] * filterRadius;\n\t\t\t\t\t\tvec3 sampleDir = lightDirNorm + offset;\n\t\t\t\t\t\tsampleDir = normalize(sampleDir);\n\n\t\t\t\t\t\t#ifdef GL2\n\t\t\t\t\t\t\t\tfloat depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n\t\t\t\t\t\t#else // GL1\n\t\t\t\t\t\t\t\tfloat depth = unpackFloat(textureCube(shadowMap, sampleDir));\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tshadow += step(receiverDepth, depth);\n\t\t\t\t}\n\t\t\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t\t}\n}\n\nfloat getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\t\treturn PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);\n}\n\nfloat getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\t\treturn PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\t\treturn PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n\n";export{t as default};
