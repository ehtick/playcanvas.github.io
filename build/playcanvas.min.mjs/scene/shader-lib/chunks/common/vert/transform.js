var t="\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\n\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED\n\t\tuniform vec4 morph_tex_params;\n\n\t\t#ifdef WEBGPU\n\t\t\t\tivec2 getTextureMorphCoords() {\n\n\t\t\t\t\t\t// turn morph_vertex_id into int grid coordinates\n\t\t\t\t\t\tivec2 textureSize = ivec2(morph_tex_params.xy);\n\t\t\t\t\t\tint morphGridV = int(morph_vertex_id / textureSize.x);\n\t\t\t\t\t\tint morphGridU = int(morph_vertex_id - (morphGridV * textureSize.x));\n\t\t\t\t\t\tmorphGridV = textureSize.y - morphGridV - 1;\n\t\t\t\t\t\treturn ivec2(morphGridU, morphGridV);\n\t\t\t\t}\n\t\t#else\n\t\t\t\tvec2 getTextureMorphCoords() {\n\t\t\t\t\t\tvec2 textureSize = morph_tex_params.xy;\n\t\t\t\t\t\tvec2 invTextureSize = morph_tex_params.zw;\n\n\t\t\t\t\t\t// turn morph_vertex_id into int grid coordinates\n\t\t\t\t\t\tfloat morphGridV = floor(morph_vertex_id * invTextureSize.x);\n\t\t\t\t\t\tfloat morphGridU = morph_vertex_id - (morphGridV * textureSize.x);\n\n\t\t\t\t\t\t// convert grid coordinates to uv coordinates with half pixel offset\n\t\t\t\t\t\treturn vec2(morphGridU, morphGridV) * invTextureSize + (0.5 * invTextureSize);\n\t\t\t\t}\n\t\t#endif\n\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\n\nmat4 getModelMatrix() {\n\t\t#ifdef DYNAMICBATCH\n\t\treturn getBoneMatrix(vertex_boneIndices);\n\t\t#elif defined(SKIN)\n\t\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t\t#elif defined(INSTANCING)\n\t\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t\t#else\n\t\treturn matrix_model;\n\t\t#endif\n}\n\nvec4 getPosition() {\n\t\tdModelMatrix = getModelMatrix();\n\t\tvec3 localPos = vertex_position;\n\n\t\t#ifdef NINESLICED\n\t\t// outer and inner vertices are at the same position, scale both\n\t\tlocalPos.xz *= outerScale;\n\n\t\t// offset inner vertices inside\n\t\t// (original vertices must be in [-1;1] range)\n\t\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\t\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\t\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n\t\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n\n\t\tlocalPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n\t\tlocalPos = localPos.xzy;\n\t\t#endif\n\n\t\t#ifdef MORPHING\n\t\t#ifdef MORPHING_POS03\n\t\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\t\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\t\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\t\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t\t#endif // MORPHING_POS03\n\t\t#ifdef MORPHING_POS47\n\t\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\t\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\t\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\t\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t\t#endif // MORPHING_POS47\n\t\t#endif // MORPHING\n\n\t\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\n\t\t\t\t#ifdef WEBGPU\n\t\t\t\t\t\tivec2 morphUV = getTextureMorphCoords();\n\t\t\t\t\t\tvec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;\n\t\t\t\t#else\n\t\t\t\t\t\tvec2 morphUV = getTextureMorphCoords();\n\t\t\t\t\t\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\t\t\t\t#endif\n\n\t\t\t\tlocalPos += morphPos;\n\n\t\t#endif\n\n\t\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t\t#ifdef SCREENSPACE\n\t\tposW.zw = vec2(0.0, 1.0);\n\t\t#endif\n\t\tdPositionW = posW.xyz;\n\n\t\tvec4 screenPos;\n\t\t#ifdef UV1LAYOUT\n\t\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t\t#else\n\t\t#ifdef SCREENSPACE\n\t\tscreenPos = posW;\n\t\tscreenPos.y *= projectionFlipY;\n\t\t#else\n\t\tscreenPos = matrix_viewProjection * posW;\n\t\t#endif\n\n\t\t#ifdef PIXELSNAP\n\t\t// snap vertex to a pixel boundary\n\t\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\t\tscreenPos.xy *= uScreenSize.xy;\n\t\tscreenPos.xy = floor(screenPos.xy);\n\t\tscreenPos.xy *= uScreenSize.zw;\n\t\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t\t#endif\n\t\t#endif\n\n\t\treturn screenPos;\n}\n\nvec3 getWorldPosition() {\n\t\treturn dPositionW;\n}\n";export{t as default};
