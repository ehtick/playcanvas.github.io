import"../../../core/tracing.js";import{WebgpuVertexBufferLayout as e}from"./webgpu-vertex-buffer-layout.js";const t=["point-list","line-list",void 0,"line-strip","triangle-list","triangle-strip",void 0],o=["add","subtract","reverse-subtract","min","max"],r=["zero","one","src","one-minus-src","dst","one-minus-dst","src-alpha","src-alpha-saturated","one-minus-src-alpha","dst-alpha","one-minus-dst-alpha","constant","one-minus-constant",void 0,void 0],i=[];class n{constructor(t){this.device=t,this.vertexBufferLayout=new e,this.cache=new Map}get(e,o,r,i,n,a,l){const s=this.getKey(e,o,r,i,n,a,l);let c=this.cache.get(s);if(!c){const d=t[e.type],p=this.getPipelineLayout(a),u=this.vertexBufferLayout.get(o,r);c=this.create(d,i.impl,n,p,l,u),this.cache.set(s,c)}return c}getKey(e,t,o,r,i,n,a){let l="";for(let e=0;e<n.length;e++)l+=n[e].key;const s=this.vertexBufferLayout.getKey(t,o),c=i.impl.key,d=a.blendKey;return s+r.impl.vertexCode+r.impl.fragmentCode+c+d+e.type+l}getPipelineLayout(e){e.forEach((e=>{i.push(e.bindGroupLayout)}));const t={bindGroupLayouts:i},o=this.device.wgpu.createPipelineLayout(t);return i.length=0,o}getBlend(e){let t;return e.blending&&(t={color:{operation:o[e.blendEquationColor],srcFactor:r[e.blendSrcColor],dstFactor:r[e.blendDstColor]},alpha:{operation:o[e.blendEquationAlpha],srcFactor:r[e.blendSrcAlpha],dstFactor:r[e.blendDstAlpha]}}),t}create(e,t,o,r,i,n){const a=this.device.wgpu,l=o.depth?{depthWriteEnabled:!0,depthCompare:"less",format:o.impl.depthFormat}:void 0,s={vertex:{module:a.createShaderModule({code:t.vertexCode}),entryPoint:"main",buffers:n},primitive:{topology:e,cullMode:"none"},depthStencil:l,multisample:{count:o.samples},layout:r};if(o.impl.colorFormat){const e=a.createShaderModule({code:t.fragmentCode});s.fragment={module:e,entryPoint:"main",targets:[{format:o.impl.colorFormat,writeMask:GPUColorWrite.ALL,blend:this.getBlend(i)}]}}return a.createRenderPipeline(s)}}export{n as WebgpuRenderPipeline};
