import{semanticToLocation as t,TYPE_INT8 as n,TYPE_UINT8 as e,TYPE_INT16 as s,TYPE_UINT16 as r,TYPE_INT32 as o,TYPE_UINT32 as i,TYPE_FLOAT32 as a}from"../constants.js";const c=[];c[n]="sint8",c[e]="uint8",c[s]="sint16",c[r]="uint16",c[o]="sint32",c[i]="uint32",c[a]="float32";const l=[];l[n]="snorm8",l[e]="unorm8",l[s]="snorm16",l[r]="unorm16",l[o]="sint32",l[i]="uint32",l[a]="float32";class u{constructor(){this.cache=new Map}get(t,n=null){const e=this.getKey(t,n);let s=this.cache.get(e);return s||(s=this.create(t,n),this.cache.set(e,s)),s}getKey(t,n=null){return`VB[${null==t?void 0:t.renderingHashString}, ${null==n?void 0:n.renderingHashString}]`}create(n,e){const s=[],r=n=>{const e=n.interleaved,r=n.instancing?"instance":"vertex";let o=[];const i=n.elements.length;for(let a=0;a<i;a++){const u=n.elements[a],m=t[u.name],h=u.normalize?l:c;o.push({shaderLocation:m,offset:e?u.offset:0,format:`${h[u.dataType]}${u.numComponents>1?"x"+u.numComponents:""}`}),e&&a!==i-1||(s.push({attributes:o,arrayStride:u.stride,stepMode:r}),o=[])}};return n&&r(n),e&&r(e),s}}export{u as WebgpuVertexBufferLayout};
