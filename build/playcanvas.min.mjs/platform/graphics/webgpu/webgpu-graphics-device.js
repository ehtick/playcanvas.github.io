import"../../../core/tracing.js";import{DEVICETYPE_WEBGPU as e,PIXELFORMAT_RGBA32F as t,PIXELFORMAT_RGBA8 as r,PIXELFORMAT_BGRA8 as s,CULLFACE_BACK as i}from"../constants.js";import{GraphicsDevice as n}from"../graphics-device.js";import{RenderTarget as o}from"../render-target.js";import{WebgpuBindGroup as a}from"./webgpu-bind-group.js";import{WebgpuBindGroupFormat as h}from"./webgpu-bind-group-format.js";import{WebgpuIndexBuffer as u}from"./webgpu-index-buffer.js";import{WebgpuRenderPipeline as p}from"./webgpu-render-pipeline.js";import{WebgpuRenderState as d}from"./webgpu-render-state.js";import{WebgpuRenderTarget as m}from"./webgpu-render-target.js";import{WebgpuShader as c}from"./webgpu-shader.js";import{WebgpuTexture as l}from"./webgpu-texture.js";import{WebgpuUniformBuffer as f}from"./webgpu-uniform-buffer.js";import{WebgpuVertexBuffer as g}from"./webgpu-vertex-buffer.js";import{WebgpuClearRenderer as w}from"./webgpu-clear-renderer.js";class x extends n{constructor(t,r={}){super(t),this.frameBuffer=void 0,this.renderState=new d,this.renderPipeline=new p(this),this.clearRenderer=new w,this.pipeline=void 0,this.bindGroupFormats=[],this.commandEncoder=void 0,this.deviceType=e,this.writeRed=!0,this.writeGreen=!0,this.writeBlue=!0,this.writeAlpha=!0,this.initDeviceCaps()}destroy(){super.destroy()}initDeviceCaps(){this.precision="highp",this.maxPrecision="highp",this.maxSamples=4,this.maxTextures=16,this.maxTextureSize=4096,this.maxCubeMapSize=4096,this.maxVolumeSize=2048,this.maxPixelRatio=1,this.supportsInstancing=!0,this.supportsUniformBuffers=!0,this.supportsBoneTextures=!0,this.supportsMorphTargetTexturesCore=!0,this.supportsAreaLights=!0,this.supportsDepthShadow=!0,this.extUintElement=!0,this.extTextureFloat=!0,this.textureFloatRenderable=!0,this.extTextureHalfFloat=!0,this.textureHalfFloatRenderable=!0,this.textureHalfFloatUpdatable=!0,this.boneLimit=1024,this.supportsImageBitmap=!0,this.extStandardDerivatives=!0,this.areaLightLutFormat=t,this.supportsTextureFetch=!0}async initWebGpu(e,t){if(!window.navigator.gpu)throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.");const i=e=>new Promise((function(t,r){const s=document.createElement("script");s.src=e,s.async=!1,s.onload=function(){t(e)},s.onerror=function(){r(new Error(`Failed to download script ${e}`))},document.body.appendChild(s)}));await i(e),await i(t),this.glslang=await glslang();const n=t.replace(".js",".wasm");this.twgsl=await twgsl(n),this.gpuAdapter=await window.navigator.gpu.requestAdapter(),this.wgpu=await this.gpuAdapter.requestDevice(),this.setResolution(window.innerWidth,window.innerHeight),this.gpuContext=this.canvas.getContext("webgpu");const o=navigator.gpu.getPreferredCanvasFormat();return this.framebufferFormat="rgba8unorm"===o?r:s,this.canvasConfig={device:this.wgpu,colorSpace:"srgb",alphaMode:"opaque",format:o,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,viewFormats:[]},this.gpuContext.configure(this.canvasConfig),this.createFramebuffer(),this.postInit(),this}createFramebuffer(){this.frameBuffer=new o({name:"WebgpuFramebuffer",graphicsDevice:this,depth:!0,samples:4})}createUniformBufferImpl(e){return new f(e)}createVertexBufferImpl(e,t){return new g(e,t)}createIndexBufferImpl(e){return new u(e)}createShaderImpl(e){return new c(e)}createTextureImpl(e){return new l(e)}createRenderTargetImpl(e){return new m(e)}createBindGroupFormatImpl(e){return new h(e)}createBindGroupImpl(e){return new a}setBindGroup(e,t){this.passEncoder&&(this.passEncoder.setBindGroup(e,t.impl.bindGroup),this.bindGroupFormats[e]=t.format.impl)}submitVertexBuffer(e,t){const r=e.format,s=r.elements.length,i=e.impl.buffer;for(let e=0;e<s;e++){const s=r.elements[e];this.passEncoder.setVertexBuffer(t+e,i,s.offset)}return s}draw(e,t=1,r){if(this.shader.ready){const r=this.passEncoder,s=this.vertexBuffers[0],i=this.submitVertexBuffer(s,0),n=this.vertexBuffers[1];n&&this.submitVertexBuffer(n,i),this.vertexBuffers.length=0;const o=this.renderPipeline.get(e,s.format,null==n?void 0:n.format,this.shader,this.renderTarget,this.bindGroupFormats,this.renderState);this.pipeline!==o&&(this.pipeline=o,r.setPipeline(o));const a=this.indexBuffer;a?(this.indexBuffer=null,r.setIndexBuffer(a.impl.buffer,a.impl.format),r.drawIndexed(a.numIndices,t,0,0,0)):r.draw(s.numVertices,t,0,0)}}setShader(e){return this.shader=e,!0}setBlending(e){this.renderState.setBlending(e)}setBlendFunction(e,t){this.renderState.setBlendFunction(e,t)}setBlendEquation(e){this.renderState.setBlendEquation(e)}setDepthFunc(e){}setDepthTest(e){}getDepthTest(){return!0}setCullMode(e){}getCullMode(){return i}setAlphaToCoverage(e){}setColorWrite(e,t,r,s){}setDepthWrite(e){}getDepthWrite(){return!0}initializeContextCaches(){super.initializeContextCaches()}startPass(e){const t=e.renderTarget||this.frameBuffer;this.renderTarget=t;const r=t.impl;let s;t===this.frameBuffer&&(s=this.gpuContext.getCurrentTexture(),r.colorFormat=s.format),this.initRenderTarget(t),s&&r.assignColorTexture(s),r.setupForRenderPass(e),this.commandEncoder=this.wgpu.createCommandEncoder(),this.pipeline=null,this.passEncoder=this.commandEncoder.beginRenderPass(r.renderPassDescriptor);const{width:i,height:n}=t;this.setViewport(0,0,i,n),this.setScissor(0,0,i,n),this.insideRenderPass=!0}endPass(e){this.passEncoder.end(),this.passEncoder=null,this.wgpu.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.bindGroupFormats.length=0,this.insideRenderPass=!1}clear(e){e.flags&&this.clearRenderer.clear(this,this.renderTarget,e)}get width(){return this._width}get height(){return this._height}setDepthBias(e){}setDepthBiasValues(e,t){}setStencilTest(e){}setViewport(e,t,r,s){this.passEncoder&&(this.vx=e,this.vy=t,this.vw=r,this.vh=s,this.passEncoder.setViewport(e,this.renderTarget.height-t-s,r,s,0,1))}setScissor(e,t,r,s){this.passEncoder&&(this.sx=e,this.sy=t,this.sw=r,this.sh=s,this.passEncoder.setScissorRect(e,this.renderTarget.height-t-s,r,s))}copyRenderTarget(e,t,r,s){var i;const n={width:e?e.width:t.width,height:e?e.height:t.height,depthOrArrayLayers:1},o=null!=(i=this.commandEncoder)?i:this.wgpu.createCommandEncoder();if(r){const r={texture:e?e.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0},s={texture:t?t.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0};o.copyTextureToTexture(r,s,n)}if(s){const r={texture:(e||this.renderTarget).impl.depthTexture,mipLevel:0},s={texture:t?t.depthBuffer.impl.gpuTexture:this.renderTarget.impl.depthTexture,mipLevel:0};o.copyTextureToTexture(r,s,n)}return this.commandEncoder||this.wgpu.queue.submit([o.finish()]),!0}}export{x as WebgpuGraphicsDevice};
