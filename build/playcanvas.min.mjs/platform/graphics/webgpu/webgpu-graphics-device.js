import"../../../core/debug.js";import{Vec2 as e}from"../../../core/math/vec2.js";import{DEVICETYPE_WEBGPU as t,PIXELFORMAT_RGBA32F as s,PIXELFORMAT_RGBA8 as i,PIXELFORMAT_BGRA8 as r}from"../constants.js";import{GraphicsDevice as n}from"../graphics-device.js";import{RenderTarget as a}from"../render-target.js";import{StencilParameters as o}from"../stencil-parameters.js";import{WebgpuBindGroup as h}from"./webgpu-bind-group.js";import{WebgpuBindGroupFormat as u}from"./webgpu-bind-group-format.js";import{WebgpuIndexBuffer as p}from"./webgpu-index-buffer.js";import{WebgpuRenderPipeline as m}from"./webgpu-render-pipeline.js";import{WebgpuRenderTarget as d}from"./webgpu-render-target.js";import{WebgpuShader as f}from"./webgpu-shader.js";import{WebgpuTexture as l}from"./webgpu-texture.js";import{WebgpuUniformBuffer as c}from"./webgpu-uniform-buffer.js";import{WebgpuVertexBuffer as g}from"./webgpu-vertex-buffer.js";import{WebgpuClearRenderer as x}from"./webgpu-clear-renderer.js";import{WebgpuMipmapRenderer as w}from"./webgpu-mipmap-renderer.js";import"./webgpu-debug.js";import{WebgpuDynamicBuffers as b}from"./webgpu-dynamic-buffers.js";class T extends n{constructor(e,s={}){super(e,s),this.frameBuffer=void 0,this.renderPipeline=new m(this),this.clearRenderer=void 0,this.mipmapRenderer=void 0,this.pipeline=void 0,this.bindGroupFormats=[],this.commandEncoder=void 0,this.commandBuffers=[],this.limits=void 0,s=this.initOptions,this.isWebGPU=!0,this._deviceType=t,this.samples=s.antialias?4:1,this.setupPassEncoderDefaults()}destroy(){super.destroy()}initDeviceCaps(){this.disableParticleSystem=!0;const e=this.gpuAdapter.limits;this.limits=e,this.precision="highp",this.maxPrecision="highp",this.maxSamples=4,this.maxTextures=16,this.maxTextureSize=e.maxTextureDimension2D,this.maxCubeMapSize=e.maxTextureDimension2D,this.maxVolumeSize=e.maxTextureDimension3D,this.maxColorAttachments=e.maxColorAttachments,this.maxPixelRatio=1,this.maxAnisotropy=16,this.supportsInstancing=!0,this.supportsUniformBuffers=!0,this.supportsVolumeTextures=!0,this.supportsBoneTextures=!0,this.supportsMorphTargetTexturesCore=!0,this.supportsAreaLights=!0,this.supportsDepthShadow=!0,this.supportsGpuParticles=!1,this.supportsMrt=!0,this.extUintElement=!0,this.extTextureFloat=!0,this.textureFloatRenderable=!0,this.extTextureHalfFloat=!0,this.textureHalfFloatRenderable=!0,this.textureHalfFloatUpdatable=!0,this.boneLimit=1024,this.supportsImageBitmap=!0,this.extStandardDerivatives=!0,this.extBlendMinmax=!0,this.areaLightLutFormat=this.floatFilterable?s:i,this.supportsTextureFetch=!0}async initWebGpu(e,t){if(!window.navigator.gpu)throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.");const s=e=>new Promise((function(t,s){const i=document.createElement("script");i.src=e,i.async=!1,i.onload=function(){t(e)},i.onerror=function(){s(new Error(`Failed to download script ${e}`))},document.body.appendChild(i)}));await s(e),await s(t),this.glslang=await glslang();const n=t.replace(".js",".wasm");this.twgsl=await twgsl(n);const a={powerPreference:"default"!==this.initOptions.powerPreference?this.initOptions.powerPreference:void 0};this.gpuAdapter=await window.navigator.gpu.requestAdapter(a);const o=[],h=e=>!!this.gpuAdapter.features.has(e)&&(o.push(e),!0);this.floatFilterable=h("float32-filterable"),this.extCompressedTextureS3TC=h("texture-compression-bc"),this.extCompressedTextureETC=h("texture-compression-etc2"),this.extCompressedTextureASTC=h("texture-compression-astc");const u={requiredFeatures:o,requiredLimits:{},defaultQueue:{label:"Default Queue"}};this.wgpu=await this.gpuAdapter.requestDevice(u),this.initDeviceCaps(),this.setResolution(window.innerWidth,window.innerHeight),this.gpuContext=this.canvas.getContext("webgpu");const p=navigator.gpu.getPreferredCanvasFormat();return this.framebufferFormat="rgba8unorm"===p?i:r,this.canvasConfig={device:this.wgpu,colorSpace:"srgb",alphaMode:"opaque",format:p,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,viewFormats:[]},this.gpuContext.configure(this.canvasConfig),this.createFramebuffer(),this.clearRenderer=new x(this),this.mipmapRenderer=new w(this),this.postInit(),this}postInit(){super.postInit(),this.dynamicBuffers=new b(this,4024e3,this.limits.minUniformBufferOffsetAlignment)}createFramebuffer(){this.supportsStencil=this.initOptions.stencil,this.frameBufferDimensions=new e,this.frameBuffer=new a({name:"WebgpuFramebuffer",graphicsDevice:this,depth:this.initOptions.depth,stencil:this.supportsStencil,samples:this.samples})}resizeCanvas(e,t){this._width=e,this._height=t,this.canvas.width===e&&this.canvas.height===t||(this.canvas.width=e,this.canvas.height=t,this.fire(n.EVENT_RESIZE,e,t))}frameStart(){super.frameStart(),this.submit();const e=this.gpuContext.getCurrentTexture();this.frameBufferDimensions.x===e.width&&this.frameBufferDimensions.y===e.height||(this.frameBufferDimensions.set(e.width,e.height),this.frameBuffer.destroy(),this.frameBuffer=null,this.createFramebuffer());const t=this.frameBuffer,s=t.impl;s.setColorAttachment(0,void 0,e.format),this.initRenderTarget(t),s.assignColorTexture(e)}frameEnd(){super.frameEnd(),this.submit()}createUniformBufferImpl(e){return new c(e)}createVertexBufferImpl(e,t){return new g(e,t)}createIndexBufferImpl(e){return new p(e)}createShaderImpl(e){return new f(e)}createTextureImpl(e){return new l(e)}createRenderTargetImpl(e){return new d(e)}createBindGroupFormatImpl(e){return new u(e)}createBindGroupImpl(e){return new h}setBindGroup(e,t){this.passEncoder&&(this.passEncoder.setBindGroup(e,t.impl.bindGroup,t.uniformBufferOffsets),this.bindGroupFormats[e]=t.format.impl)}submitVertexBuffer(e,t){const s=e.format.elements,i=s.length,r=e.impl.buffer;for(let e=0;e<i;e++)this.passEncoder.setVertexBuffer(t+e,r,s[e].offset);return i}draw(e,t=1,s){if(this.shader.ready&&!this.shader.failed){const s=this.passEncoder,i=this.vertexBuffers[0],r=this.vertexBuffers[1];if(this.vertexBuffers.length=0,i){const e=this.submitVertexBuffer(i,0);r&&this.submitVertexBuffer(r,e)}const n=this.renderPipeline.get(e,null==i?void 0:i.format,null==r?void 0:r.format,this.shader,this.renderTarget,this.bindGroupFormats,this.blendState,this.depthState,this.cullMode,this.stencilEnabled,this.stencilFront,this.stencilBack);this.pipeline!==n&&(this.pipeline=n,s.setPipeline(n));const a=this.indexBuffer;a?(this.indexBuffer=null,s.setIndexBuffer(a.impl.buffer,a.impl.format),s.drawIndexed(e.count,t,0,0,0)):s.draw(e.count,t,0,0)}}setShader(e){return this.shader=e,!0}setBlendState(e){this.blendState.copy(e)}setDepthState(e){this.depthState.copy(e)}setStencilState(e,t){if(e||t){this.stencilEnabled=!0,this.stencilFront.copy(null!=e?e:o.DEFAULT),this.stencilBack.copy(null!=t?t:o.DEFAULT);const s=this.stencilFront.ref;this.stencilRef!==s&&(this.stencilRef=s,this.passEncoder.setStencilReference(s))}else this.stencilEnabled=!1}setBlendColor(e,t,s,i){}setCullMode(e){this.cullMode=e}setAlphaToCoverage(e){}initializeContextCaches(){super.initializeContextCaches()}setupPassEncoderDefaults(){this.stencilRef=0}startPass(e){const t=e.renderTarget||this.frameBuffer;this.renderTarget=t;const s=t.impl;this.commandEncoder=this.wgpu.createCommandEncoder(),t!==this.frameBuffer&&this.initRenderTarget(t),s.setupForRenderPass(e),this.pipeline=null,this.passEncoder=this.commandEncoder.beginRenderPass(s.renderPassDescriptor),this.setupPassEncoderDefaults();const{width:i,height:r}=t;this.setViewport(0,0,i,r),this.setScissor(0,0,i,r),this.insideRenderPass=!0}endPass(e){this.passEncoder.end(),this.passEncoder=null,this.insideRenderPass=!1,this.bindGroupFormats.length=0;for(let t=0;t<e.colorArrayOps.length;t++){e.colorArrayOps[t].mipmaps&&this.mipmapRenderer.generate(e.renderTarget._colorBuffers[t].impl)}const t=this.commandEncoder.finish();this.addCommandBuffer(t),this.commandEncoder=null}addCommandBuffer(e,t=!1){t?this.commandBuffers.unshift(e):this.commandBuffers.push(e)}submit(){this.commandBuffers.length>0&&(this.dynamicBuffers.submit(),this.wgpu.queue.submit(this.commandBuffers),this.commandBuffers.length=0,this.dynamicBuffers.onCommandBuffersSubmitted())}clear(e){e.flags&&this.clearRenderer.clear(this,this.renderTarget,e,this.defaultClearOptions)}get width(){return this._width}get height(){return this._height}setDepthBias(e){}setDepthBiasValues(e,t){}setViewport(e,t,s,i){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-i),this.vx=e,this.vy=t,this.vw=s,this.vh=i,this.passEncoder.setViewport(e,t,s,i,0,1))}setScissor(e,t,s,i){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-i),this.sx=e,this.sy=t,this.sw=s,this.sh=i,this.passEncoder.setScissorRect(e,t,s,i))}copyRenderTarget(e,t,s,i){var r;const n={width:e?e.width:t.width,height:e?e.height:t.height,depthOrArrayLayers:1},a=null!=(r=this.commandEncoder)?r:this.wgpu.createCommandEncoder();if(s){const s={texture:e?e.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0},i={texture:t?t.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0};a.copyTextureToTexture(s,i,n)}if(i){const s={texture:(e||this.renderTarget).impl.depthTexture,mipLevel:0},i={texture:t?t.depthBuffer.impl.gpuTexture:this.renderTarget.impl.depthTexture,mipLevel:0};a.copyTextureToTexture(s,i,n)}if(!this.commandEncoder){const e=a.finish();this.addCommandBuffer(e)}return!0}}export{T as WebgpuGraphicsDevice};
