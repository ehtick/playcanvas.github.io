import"../../../core/debug.js";import{math as e}from"../../../core/math/math.js";import{PIXELFORMAT_DEPTHSTENCIL as t,SAMPLETYPE_DEPTH as r,SAMPLETYPE_UNFILTERABLE_FLOAT as a,PIXELFORMAT_RGBA32F as s,PIXELFORMAT_RGBA16F as i,pixelFormatInfo as l,PIXELFORMAT_A8 as o,PIXELFORMAT_L8 as n,PIXELFORMAT_LA8 as m,PIXELFORMAT_RGB565 as u,PIXELFORMAT_RGBA5551 as p,PIXELFORMAT_RGBA4 as d,PIXELFORMAT_RGB8 as h,PIXELFORMAT_RGBA8 as c,PIXELFORMAT_DXT1 as g,PIXELFORMAT_DXT3 as f,PIXELFORMAT_DXT5 as x,PIXELFORMAT_RGB16F as v,PIXELFORMAT_RGB32F as y,PIXELFORMAT_R32F as b,PIXELFORMAT_DEPTH as T,PIXELFORMAT_111110F as w,PIXELFORMAT_SRGB as L,PIXELFORMAT_SRGBA as A,PIXELFORMAT_ETC1 as C,PIXELFORMAT_ETC2_RGB as U,PIXELFORMAT_ETC2_RGBA as E,PIXELFORMAT_PVRTC_2BPP_RGB_1 as I,PIXELFORMAT_PVRTC_2BPP_RGBA_1 as M,PIXELFORMAT_PVRTC_4BPP_RGB_1 as _,PIXELFORMAT_PVRTC_4BPP_RGBA_1 as F,PIXELFORMAT_ASTC_4x4 as D,PIXELFORMAT_ATC_RGB as V,PIXELFORMAT_ATC_RGBA as O,PIXELFORMAT_BGRA8 as P,ADDRESS_REPEAT as R,ADDRESS_CLAMP_TO_EDGE as G,ADDRESS_MIRRORED_REPEAT as j,FILTER_NEAREST as z,FILTER_LINEAR as S,FILTER_NEAREST_MIPMAP_NEAREST as q,FILTER_NEAREST_MIPMAP_LINEAR as B,FILTER_LINEAR_MIPMAP_NEAREST as N,FILTER_LINEAR_MIPMAP_LINEAR as H}from"../constants.js";import{TextureUtils as Y}from"../texture-utils.js";import"./webgpu-debug.js";const W=[];W[o]="",W[n]="r8unorm",W[m]="rg8unorm",W[u]="",W[p]="",W[d]="",W[h]="rgba8unorm",W[c]="rgba8unorm",W[g]="bc1-rgba-unorm",W[f]="bc2-rgba-unorm",W[x]="bc3-rgba-unorm",W[v]="",W[i]="rgba16float",W[y]="",W[s]="rgba32float",W[b]="r32float",W[T]="depth32float",W[t]="depth24plus-stencil8",W[w]="rg11b10ufloat",W[L]="",W[A]="",W[C]="",W[U]="etc2-rgb8unorm",W[E]="etc2-rgba8unorm",W[I]="",W[M]="",W[_]="",W[F]="",W[D]="astc-4x4-unorm",W[V]="",W[O]="",W[P]="bgra8unorm";const X=[];X[R]="repeat",X[G]="clamp-to-edge",X[j]="mirror-repeat";const k=[];k[z]={level:"nearest",mip:"nearest"},k[S]={level:"linear",mip:"nearest"},k[q]={level:"nearest",mip:"nearest"},k[B]={level:"nearest",mip:"linear"},k[N]={level:"linear",mip:"nearest"},k[H]={level:"linear",mip:"linear"};class J{constructor(e){this.gpuTexture=void 0,this.view=void 0,this.samplers=[],this.descr=void 0,this.format=void 0,this.texture=e,this.format=W[e.format],this.create(e.device)}create(e){const r=this.texture,a=e.wgpu,s=r.requiredMipLevels;let i;this.descr={size:{width:r.width,height:r.height,depthOrArrayLayers:r.cubemap?6:1},format:this.format,mipLevelCount:s,sampleCount:1,dimension:r.volume?"3d":"2d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},this.gpuTexture=a.createTexture(this.descr),this.texture.format===t&&(i={format:"depth24plus",aspect:"depth-only"}),this.view=this.createView(i)}destroy(e){}propertyChanged(e){this.samplers.length=0}getView(e){return this.uploadImmediate(e,this.texture),this.view}createView(e){var t,r,a,s,i,l,o;const n=null!=e?e:{},m=this.descr,u=this.texture,p={format:null!=(t=n.format)?t:m.format,dimension:null!=(r=n.dimension)?r:u.cubemap?"cube":u.volume?"3d":"2d",aspect:null!=(a=n.aspect)?a:"all",baseMipLevel:null!=(s=n.baseMipLevel)?s:0,mipLevelCount:null!=(i=n.mipLevelCount)?i:m.mipLevelCount,baseArrayLayer:null!=(l=n.baseArrayLayer)?l:0,arrayLayerCount:null!=(o=n.arrayLayerCount)?o:m.depthOrArrayLayers};return this.gpuTexture.createView(p)}getSampler(l,o){let n=this.samplers[o];if(!n){const m=this.texture,u={addressModeU:X[m.addressU],addressModeV:X[m.addressV],addressModeW:X[m.addressW],maxAnisotropy:e.clamp(Math.round(m._anisotropy),1,l.maxTextureAnisotropy)};!o&&m.compareOnRead&&(o=r),o===r?(u.compare="less",u.magFilter="linear",u.minFilter="linear"):o===a||this.texture.format===s||this.texture.format===t||this.texture.format===i?(u.magFilter="nearest",u.minFilter="nearest",u.mipmapFilter="nearest"):(u.magFilter=k[m.magFilter].level,u.minFilter=k[m.minFilter].level,u.mipmapFilter=k[m.minFilter].mip),n=l.wgpu.createSampler(u),this.samplers[o]=n}return n}loseContext(){}uploadImmediate(e,t){(t._needsUpload||t._needsMipmapsUpload)&&(this.uploadData(e),t._needsUpload=!1,t._needsMipmapsUpload=!1)}uploadData(e){const t=this.texture;if(t._levels){let r=!1;const a=t.requiredMipLevels;for(let s=0;s<a;s++){const a=t._levels[s];if(a)if(t.cubemap)for(let t=0;t<6;t++){const i=a[t];i&&(this.isExternalImage(i)?(this.uploadExternalImage(e,i,s,t),r=!0):ArrayBuffer.isView(i)&&(this.uploadTypedArrayData(e,i,s,t),r=!0))}else t._volume||(this.isExternalImage(a)?(this.uploadExternalImage(e,a,s,0),r=!0):ArrayBuffer.isView(a)&&(this.uploadTypedArrayData(e,a,s,0),r=!0))}r&&t.mipmaps&&e.mipmapRenderer.generate(this)}}isExternalImage(e){return e instanceof ImageBitmap||e instanceof HTMLVideoElement||e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas}uploadExternalImage(e,t,r,a){const s={source:t,origin:[0,0],flipY:!1},i={texture:this.gpuTexture,mipLevel:r,origin:[0,0,a],aspect:"all"},l={width:this.descr.size.width,height:this.descr.size.height,depthOrArrayLayers:1};e.submit(),e.wgpu.queue.copyExternalImageToTexture(s,i,l)}uploadTypedArrayData(e,t,r,a){var s;const i=this.texture,o=e.wgpu,n={texture:this.gpuTexture,origin:[0,0,a],mipLevel:r},m=Y.calcLevelDimension(i.width,r),u=Y.calcLevelDimension(i.height,r);Y.calcLevelGpuSize(m,u,i.format);const p={offset:0,bytesPerRow:(null!=(s=l.get(i.format).size)?s:0)*m,rowsPerImage:u},d={width:m,height:u,depthOrArrayLayers:1};e.submit(),o.queue.writeTexture(n,t,p,d)}}export{J as WebgpuTexture};
