import{Shader as t}from"../shader.js";import{SHADERLANGUAGE_WGSL as e}from"../constants.js";import"../../../core/debug.js";class r{constructor(r){this.device=void 0,this.device=r;const n=r.wgpu,o="\n \n\t\t\t\t\t\tvar<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n\t\t\t\t\t\t\t\tvec2(-1.0, 1.0), vec2(1.0, 1.0),\n\t\t\t\t\t\t\t\tvec2(-1.0, -1.0), vec2(1.0, -1.0)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tstruct VertexOutput {\n\t\t\t\t\t\t\t\t@builtin(position) position : vec4f,\n\t\t\t\t\t\t\t\t@location(0) texCoord : vec2f\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t@vertex\n\t\t\t\t\t\tfn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n\t\t\t\t\t\t\tvar output : VertexOutput;\n\t\t\t\t\t\t\toutput.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);\n\t\t\t\t\t\t\toutput.position = vec4f(pos[vertexIndex], 0, 1);\n\t\t\t\t\t\t\treturn output;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@group(0) @binding(0) var imgSampler : sampler;\n\t\t\t\t\t\t@group(0) @binding(1) var img : texture_2d<f32>;\n\n\t\t\t\t\t\t@fragment\n\t\t\t\t\t\tfn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {\n\t\t\t\t\t\t\treturn textureSample(img, imgSampler, texCoord);\n\t\t\t\t\t\t}\n\t\t\t\t";this.shader=new t(r,{name:"WebGPUMipmapRendererShader",shaderLanguage:e,vshader:o,fshader:o}),this.minSampler=n.createSampler({minFilter:"linear"})}generate(t){var e;const r=t.descr;if(r.mipLevelCount<=1)return;if(t.texture.volume)return;const n=this.device,o=n.wgpu,i=this.shader.impl,a=o.createRenderPipeline({layout:"auto",vertex:{module:i.getVertexShaderModule(),entryPoint:i.vertexEntryPoint},fragment:{module:i.getFragmentShaderModule(),entryPoint:i.fragmentEntryPoint,targets:[{format:r.format}]},primitive:{topology:"triangle-strip"}}),s=t.texture.cubemap?6:1,u=[];for(let e=0;e<s;e++)u.push(t.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:e}));const d=null!=(e=n.commandEncoder)?e:o.createCommandEncoder();for(let e=1;e<r.mipLevelCount;e++)for(let r=0;r<s;r++){const n=t.createView({dimension:"2d",baseMipLevel:e,mipLevelCount:1,baseArrayLayer:r}),i=d.beginRenderPass({colorAttachments:[{view:n,loadOp:"clear",storeOp:"store"}]}),s=o.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:this.minSampler},{binding:1,resource:u[r]}]});i.setPipeline(a),i.setBindGroup(0,s),i.draw(4),i.end(),u[r]=n}if(!n.commandEncoder){const t=d.finish();n.addCommandBuffer(t)}n.pipeline=null}}export{r as WebgpuMipmapRenderer};
