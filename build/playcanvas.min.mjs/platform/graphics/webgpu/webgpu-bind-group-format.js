import"../../../core/tracing.js";import{SAMPLETYPE_FLOAT as t,SAMPLETYPE_UNFILTERABLE_FLOAT as e,SAMPLETYPE_DEPTH as i}from"../constants.js";import{WebgpuUtils as s}from"./webgpu-utils.js";const r={};r[t]="filtering",r[e]="non-filtering",r[i]="comparison";class o{constructor(t){const e=t.device,{key:i,descr:s}=this.createDescriptor(t);this.key=i,this.bindGroupLayout=e.wgpu.createBindGroupLayout(s)}destroy(){this.bindGroupLayout=null}loseContext(){}getTextureSlot(t,e){return t.bufferFormats.length+2*e}createDescriptor(t){const e=[];let i="",o=0;t.bufferFormats.forEach((t=>{const r=s.shaderStage(t.visibility);i+=`#${o}U:${r}`,e.push({binding:o++,visibility:r,buffer:{type:"uniform",hasDynamicOffset:!1}})})),t.textureFormats.forEach((t=>{const n=s.shaderStage(t.visibility),a=t.sampleType,u=t.textureDimension;i+=`#${o}T:${n}-${a}-${u}-false`,e.push({binding:o++,visibility:n,texture:{sampleType:a,viewDimension:u,multisampled:false}});const c=r[a];i+=`#${o}S:${n}-${c}`,e.push({binding:o++,visibility:n,sampler:{type:c}})}));return{key:i,descr:{entries:e}}}}export{o as WebgpuBindGroupFormat};
