import"../../core/tracing.js";import{hashCode as t}from"../../core/hash.js";import{math as e}from"../../core/math/math.js";import{typedArrayTypesByteSize as s,SEMANTIC_TEXCOORD0 as n,SEMANTIC_TEXCOORD1 as i,SEMANTIC_COLOR as a,SEMANTIC_TANGENT as o,SEMANTIC_ATTR12 as h,TYPE_FLOAT32 as r,SEMANTIC_ATTR13 as m,SEMANTIC_ATTR14 as c,SEMANTIC_ATTR15 as l}from"./constants.js";class p{constructor(t,h,r){this.device=t,this._elements=[],this.hasUv0=!1,this.hasUv1=!1,this.hasColor=!1,this.hasTangents=!1,this.verticesByteSize=0,this.vertexCount=r,this.interleaved=void 0===r,this.instancing=!1,this.size=h.reduce(((t,e)=>t+4*Math.ceil(e.components*s[e.type]/4)),0);let m,c=0;for(let t=0,l=h.length;t<l;t++){const l=h[t];m=l.components*s[l.type],r&&(c=e.roundUp(c,m));const p={name:l.semantic,offset:r?c:l.hasOwnProperty("offset")?l.offset:c,stride:r?m:l.hasOwnProperty("stride")?l.stride:this.size,dataType:l.type,numComponents:l.components,normalize:void 0!==l.normalize&&l.normalize,size:m};this._elements.push(p),c+=r?m*r:4*Math.ceil(m/4),l.semantic===n?this.hasUv0=!0:l.semantic===i?this.hasUv1=!0:l.semantic===a?this.hasColor=!0:l.semantic===o&&(this.hasTangents=!0)}r&&(this.verticesByteSize=c),this._evaluateHash()}get elements(){return this._elements}static getDefaultInstancingFormat(t){return p._defaultInstancingFormat||(p._defaultInstancingFormat=new p(t,[{semantic:h,components:4,type:r},{semantic:m,components:4,type:r},{semantic:c,components:4,type:r},{semantic:l,components:4,type:r}])),p._defaultInstancingFormat}update(){this._evaluateHash()}_evaluateHash(){let e;const s=[];let n;const i=[],a=this._elements.length;for(let t=0;t<a;t++){const a=this._elements[t];e=a.name,e+=a.dataType,e+=a.numComponents,e+=a.normalize,s.push(e),n=e,n+=a.offset,n+=a.stride,n+=a.size,i.push(n)}s.sort(),this.batchingHash=t(s.join()),this.renderingingHashString=i.join("_"),this.renderingingHash=t(this.renderingingHashString)}}p._defaultInstancingFormat=null;export{p as VertexFormat};
