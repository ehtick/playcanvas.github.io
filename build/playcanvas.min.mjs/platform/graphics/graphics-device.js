import"../../core/tracing.js";import{EventHandler as e}from"../../core/event-handler.js";import{platform as t}from"../../core/platform.js";import"../../core/time.js";import{PRIMITIVE_TRIFAN as i,SEMANTIC_POSITION as s,TYPE_FLOAT32 as r,BUFFER_STATIC as h,PRIMITIVE_POINTS as a}from"./constants.js";import{ScopeSpace as n}from"./scope-space.js";import{VertexBuffer as o}from"./vertex-buffer.js";import{VertexFormat as d}from"./vertex-format.js";const l="resizecanvas";class m extends e{constructor(e){super(),this.canvas=void 0,this.deviceType=void 0,this.scope=void 0,this.boneLimit=void 0,this.maxAnisotropy=void 0,this.maxCubeMapSize=void 0,this.maxTextureSize=void 0,this.maxVolumeSize=void 0,this.precision=void 0,this.renderTarget=null,this.insideRenderPass=!1,this.supportsInstancing=void 0,this.supportsUniformBuffers=!1,this.textureFloatRenderable=void 0,this.textureHalfFloatRenderable=void 0,this.quadVertexBuffer=void 0,this.canvas=e,this._width=0,this._height=0,this._maxPixelRatio=t.browser?Math.min(1,window.devicePixelRatio):1,this.shaders=[],this.buffers=[],this.textures=[],this.targets=[],this._vram={tex:0,vb:0,ib:0,ub:0},this._shaderStats={vsCompiled:0,fsCompiled:0,linked:0,materialShaders:0,compileTime:0},this.initializeContextCaches(),this._drawCallsPerFrame=0,this._shaderSwitchesPerFrame=0,this._primsPerFrame=[];for(let e=a;e<=i;e++)this._primsPerFrame[e]=0;this._renderTargetCreationTime=0,this.scope=new n("Device"),this.textureBias=this.scope.resolve("textureBias"),this.textureBias.setValue(0)}postInit(){const e=new d(this,[{semantic:s,components:2,type:r}]),t=new Float32Array([-1,-1,1,-1,-1,1,1,1]);this.quadVertexBuffer=new o(this,e,4,h,t)}destroy(){var e;this.fire("destroy"),null==(e=this.quadVertexBuffer)||e.destroy(),this.quadVertexBuffer=null}onDestroyShader(e){this.fire("destroy:shader",e);const t=this.shaders.indexOf(e);-1!==t&&this.shaders.splice(t,1)}postDestroy(){this.scope=null,this.canvas=null}toJSON(e){}initializeContextCaches(){this.indexBuffer=null,this.vertexBuffers=[],this.shader=null,this.renderTarget=null}initializeRenderState(){this.vx=this.vy=this.vw=this.vh=0,this.sx=this.sy=this.sw=this.sh=0}setRenderTarget(e){this.renderTarget=e}setIndexBuffer(e){this.indexBuffer=e}setVertexBuffer(e){e&&this.vertexBuffers.push(e)}getRenderTarget(){return this.renderTarget}initRenderTarget(e){e.initialized||(e.init(),this.targets.push(e))}_isBrowserInterface(e){return this._isImageBrowserInterface(e)||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement}_isImageBrowserInterface(e){return"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement}resizeCanvas(e,i){this._width=e,this._height=i;const s=Math.min(this._maxPixelRatio,t.browser?window.devicePixelRatio:1);e=Math.floor(e*s),i=Math.floor(i*s),this.canvas.width===e&&this.canvas.height===i||(this.canvas.width=e,this.canvas.height=i,this.fire(l,e,i))}setResolution(e,t){this._width=e,this._height=t,this.canvas.width=e,this.canvas.height=t,this.fire(l,e,t)}updateClientRect(){this.clientRect=this.canvas.getBoundingClientRect()}get width(){return this.canvas.width}get height(){return this.canvas.height}set fullscreen(e){}get fullscreen(){return!1}set maxPixelRatio(e){this._maxPixelRatio=e,this.resizeCanvas(this._width,this._height)}get maxPixelRatio(){return this._maxPixelRatio}getBoneLimit(){return this.boneLimit}setBoneLimit(e){this.boneLimit=e}}export{m as GraphicsDevice};
