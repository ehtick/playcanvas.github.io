import"../../core/tracing.js";import{uniformTypeToName as t,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as r,SHADERSTAGE_VERTEX as s,SHADERSTAGE_FRAGMENT as e,BINDGROUP_MESH as a,semanticToLocation as o,TEXTUREDIMENSION_2D as n,TEXTUREDIMENSION_3D as i,TEXTUREDIMENSION_CUBE as c,TEXTUREDIMENSION_2D_ARRAY as u,SAMPLETYPE_FLOAT as p,SAMPLETYPE_UNFILTERABLE_FLOAT as m,SAMPLETYPE_DEPTH as h}from"./constants.js";import{UniformFormat as l,UniformBufferFormat as f}from"./uniform-buffer-format.js";import{BindBufferFormat as d,BindTextureFormat as b,BindGroupFormat as g}from"./bind-group-format.js";const y=/[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g,w=/(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)([;]+)/g,x="@@@",S=/([\w-]+)\[(.*?)\]/,D=new Set(["highp","mediump","lowp"]),$=new Set(["sampler2DShadow","samplerCubeShadow"]),v={sampler2D:n,sampler3D:i,samplerCube:c,samplerCubeShadow:c,sampler2DShadow:n,sampler2DArray:u,sampler2DArrayShadow:u};class E{constructor(t,r){this.line=t;const s=t.trim().split(/\s+/);if(D.has(s[0])&&(this.precision=s.shift()),this.type=s.shift(),t.includes(","),t.includes("[")){const t=s.join(" "),e=S.exec(t);this.name=e[1],this.arraySize=Number(e[2]),isNaN(this.arraySize)&&(r.failed=!0)}else this.name=s.shift(),this.arraySize=1;this.isSampler=-1!==this.type.indexOf("sampler")}}class F{static run(t,r,s){const e=new Map,a=F.extract(r.vshader),o=F.extract(r.fshader),n=F.processAttributes(a.attributes,r.attributes),i=F.processVaryings(a.varyings,e,!0),c=F.processVaryings(o.varyings,e,!1),u=F.processOuts(o.outs),p=a.uniforms.concat(o.uniforms),m=Array.from(new Set(p)).map((t=>new E(t,s))),h=F.processUniforms(t,m,r.processingOptions,s),l=n+"\n"+i+"\n"+h.code,f=a.src.replace(x,l),d=c+"\n"+u+"\n"+h.code;return{vshader:f,fshader:o.src.replace(x,d),meshUniformBufferFormat:h.meshUniformBufferFormat,meshBindGroupFormat:h.meshBindGroupFormat}}static extract(t){const r=[],s=[],e=[],a=[];let o,n=`${x}\n`;for(;null!==(o=y.exec(t));){const i=o[1];switch(i){case"attribute":case"varying":case"uniform":case"out":{w.lastIndex=o.index;const c=w.exec(t);"attribute"===i?r.push(c[2]):"varying"===i?s.push(c[2]):"out"===i?e.push(c[2]):"uniform"===i&&a.push(c[2]),t=F.cutOut(t,o.index,w.lastIndex,n),y.lastIndex=o.index+n.length,n="";break}}}return{src:t,attributes:r,varyings:s,outs:e,uniforms:a}}static processUniforms(o,n,i,c){const u=[],y=[];n.forEach((t=>{t.isSampler?u.push(t):y.push(t)}));const w=[];y.forEach((r=>{if(!i.hasUniform(r.name)){const s=t.indexOf(r.type),e=new l(r.name,s,r.arraySize);w.push(e)}}));const x=w.length?new f(o,w):null,S=[];x&&S.push(new d(r,s|e));const D=[];u.forEach((t=>{if(!i.hasTexture(t.name)){let r=p;"highp"===t.precision&&(r=m),$.has(t.type)&&(r=h);const a=v[t.type];D.push(new b(t.name,s|e,a,r))}}));const E=new g(o,S,D);let F="";return i.uniformFormats.forEach(((t,r)=>{t&&(F+=t.getShaderDeclaration(r,0))})),x&&(F+=x.getShaderDeclaration(a,0)),i.bindGroupFormats.forEach(((t,r)=>{t&&(F+=t.getShaderDeclarationTextures(r))})),F+=E.getShaderDeclarationTextures(a),{code:F,meshUniformBufferFormat:x,meshBindGroupFormat:E}}static processVaryings(t,r,s){let e="";const a=s?"out":"in";return t.forEach(((t,o)=>{const n=F.splitToWords(t),i=n[0],c=n[1];s?r.set(c,o):o=r.get(c),e+=`layout(location = ${o}) ${a} ${i} ${c};\n`})),e}static processOuts(t){let r="";return t.forEach(((t,s)=>{r+=`layout(location = ${s}) out ${t};\n`})),r}static processAttributes(t,r){let s="";return t.forEach((t=>{const e=F.splitToWords(t),a=e[0],n=e[1];if(r.hasOwnProperty(n)){const t=r[n],e=o[t];s+=`layout(location = ${e}) in ${a} ${n};\n`}})),s}static splitToWords(t){return(t=t.replace(/\s+/g," ").trim()).split(" ")}static cutOut(t,r,s,e){return t.substring(0,r)+e+t.substring(s)}}export{F as ShaderProcessor};
