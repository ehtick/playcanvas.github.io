import{AnimTargetValue as t}from"./anim-target-value.js";class e{constructor(t){this._binder=t,this._clips=[],this._inputs=[],this._outputs=[],this._targets={}}get clips(){return this._clips}static _dot(t,e){const s=t.length;let n=0;for(let r=0;r<s;++r)n+=t[r]*e[r];return n}static _normalize(t){let s=e._dot(t,t);if(s>0){s=1/Math.sqrt(s);const e=t.length;for(let n=0;n<e;++n)t[n]*=s}}static _set(t,s,n){const r=t.length;if("quaternion"===n){let n=e._dot(s,s);n>0&&(n=1/Math.sqrt(n));for(let e=0;e<r;++e)t[e]=s[e]*n}else for(let e=0;e<r;++e)t[e]=s[e]}static _blendVec(t,e,s,n){const r=n?1:1-s,a=t.length;for(let n=0;n<a;++n)t[n]=t[n]*r+e[n]*s}static _blendQuat(t,s,n,r){const a=t.length,o=r?1:1-n;e._dot(t,s)<0&&(n=-n);for(let e=0;e<a;++e)t[e]=t[e]*o+s[e]*n;r||e._normalize(t)}static _blend(t,s,n,r,a){"quaternion"===r?e._blendQuat(t,s,n,a):e._blendVec(t,s,n,a)}static _stableSort(t,e){const s=t.length;for(let n=0;n<s-1;++n)for(let r=n+1;r<s;++r)if(e(t[r],t[n])){const e=t[n];t[n]=t[r],t[r]=e}}addClip(e){const s=this._targets,n=this._binder,r=e.track.curves,a=e.snapshot,o=[],i=[];for(let e=0;e<r.length;++e){const l=r[e].paths;for(let r=0;r<l.length;++r){const h=l[r],u=n.resolve(h);let c=s[u&&u.targetPath||null];if(!c&&u){c={target:u,value:[],curves:0,blendCounter:0};for(let t=0;t<c.target.components;++t)c.value.push(0);if(s[u.targetPath]=c,n.animComponent){if(!n.animComponent.targets[u.targetPath]){let e;e="localRotation"===u.targetPath.substring(u.targetPath.length-13)?t.TYPE_QUAT:t.TYPE_VEC3,n.animComponent.targets[u.targetPath]=new t(n.animComponent,e)}n.animComponent.targets[u.targetPath].layerCounter++,n.animComponent.targets[u.targetPath].setMask(n.layerIndex,1)}}c&&(c.curves++,o.push(a._results[e]),i.push(c))}}this._clips.push(e),this._inputs.push(o),this._outputs.push(i)}removeClip(t){const e=this._targets,s=this._binder,n=this._clips,r=n[t].track.curves;for(let t=0;t<r.length;++t){const n=r[t].paths;for(let t=0;t<n.length;++t){const r=n[t],a=this._binder.resolve(r);a&&(a.curves--,0===a.curves&&(s.unresolve(r),delete e[a.targetPath],s.animComponent&&s.animComponent.targets[a.targetPath].layerCounter--))}}n.splice(t,1),this._inputs.splice(t,1),this._outputs.splice(t,1)}removeClips(){for(;this._clips.length>0;)this.removeClip(0)}findClip(t){const e=this._clips;for(let s=0;s<e.length;++s){const n=e[s];if(n.name===t)return n}return null}rebind(){this._binder.rebind(),this._targets={};const t=[...this.clips];this.removeClips(),t.forEach((t=>{this.addClip(t)}))}assignMask(t){return this._binder.assignMask(t)}update(t){const s=this._clips,n=s.map((function(t,e){return e}));e._stableSort(n,(function(t,e){return s[t].blendOrder<s[e].blendOrder}));for(let r=0;r<n.length;++r){const a=n[r],o=s[a],i=this._inputs[a],l=this._outputs[a],h=o.blendWeight;let u,c,p;if(h>0&&o._update(t),h>=1)for(let t=0;t<i.length;++t)u=i[t],c=l[t],p=c.value,e._set(p,u,c.target.type),c.blendCounter++;else if(h>0)for(let t=0;t<i.length;++t)u=i[t],c=l[t],p=c.value,0===c.blendCounter?e._set(p,u,c.target.type):e._blend(p,u,h,c.target.type),c.blendCounter++}const r=this._targets,a=this._binder;for(const t in r)if(r.hasOwnProperty(t)){const e=r[t];if(a.animComponent&&e.target.isTransform){const s=a.animComponent.targets[t];s.counter===s.layerCounter&&(s.counter=0),s.path||(s.path=t,s.baseValue=e.target.get(),s.setter=e.target.set),s.updateValue(a.layerIndex,e.value),s.counter++}else e.target.set(e.value);e.blendCounter=0}a.update(t)}}export{e as AnimEvaluator};
