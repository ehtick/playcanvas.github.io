import{extend as t}from"../core/core.js";import{CURVE_SMOOTHSTEP as e}from"./constants.js";import{CurveEvaluator as s}from"./curve-evaluator.js";class r{constructor(t){if(this.keys=[],this.type=e,this.tension=.5,this._eval=new s(this),t)for(let e=0;e<t.length-1;e+=2)this.keys.push([t[e],t[e+1]]);this.sort()}get length(){return this.keys.length}add(t,e){const s=this.keys,r=s.length;let n=0;for(;n<r&&!(s[n][0]>t);n++);const o=[t,e];return this.keys.splice(n,0,o),o}get(t){return this.keys[t]}sort(){this.keys.sort((function(t,e){return t[0]-e[0]}))}value(t){return this._eval.evaluate(t,!0)}closest(t){const e=this.keys,s=e.length;let r=2,n=null;for(let o=0;o<s;o++){const s=Math.abs(t-e[o][0]);if(!(r>=s))break;r=s,n=e[o]}return n}clone(){const e=new this.constructor;return e.keys=t(e.keys,this.keys),e.type=this.type,e.tension=this.tension,e}quantize(t){t=Math.max(t,2);const e=new Float32Array(t),s=1/(t-1);e[0]=this._eval.evaluate(0,!0);for(let r=1;r<t;r++)e[r]=this._eval.evaluate(s*r);return e}quantizeClamped(t,e,s){const r=this.quantize(t);for(let t=0;t<r.length;++t)r[t]=Math.min(s,Math.max(e,r[t]));return r}}export{r as Curve};
